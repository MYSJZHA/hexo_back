---
title: 面试总结
date: 2018-06-03 14:30:54
tags: [Android,面试]
---
最近的面试过程中遇到的面试题，涉及的方面比较广泛，大致分成了一下几个方面：
操作系统、Java、Android、计算机网络、其他(kotlin、react、安全之类的)。
<!-- more -->

### 操作系统相关：

** 进程和线程的区别 **
> * 进程是资源的分配和调度的一个独立单元，而线程是CPU调度的基本单元 
> * 同一个进程中可以包括多个线程，并且线程共享整个进程的资源（寄存器、堆栈、上下文），一个进行至少包括一个线程。
> * 进程的创建调用fork或者vfork，而线程的创建调用pthread_create，进程结束后它拥有的所有线程都将销毁，而线程的结束不会影响同个进程中的其他线程的结束
> * 线程是轻两级的进程，它的创建和销毁所需要的时间比进程小很多，所有操作系统中的执行功能都是创建线程去完成的
> * 线程中执行时一般都要进行同步和互斥，因为他们共享同一进程的所有资源
> * 线程有自己的私有属性TCB，线程id，寄存器、硬件上下文，而进程也有自己的私有属性进程控制块PCB，这些私有属性是不被共享的，用来标示一个进程或一个线程的标志

** 线程调度算法 **
> * SCHED_OTHER：普通任务调度策略。
> * SCHED_FIFO：实时任务调度策略，先到先服务。一旦占用cpu则一直运行，直到有更高优先级任务到达或自己放弃。
> * SCHED_RR：实时任务调度策略，时间片轮转。当任务的时间片用完，系统将重新分配时间片，并置于就绪队列尾。放在队列尾
>具体涉及到N多内容，自行搜索

** 内存页面置换算法 **
为提高内存利用率，解决内存供不应求的问题，更加合理的使用内存，人们创造了分页式内存抽象。同时有一个虚拟内存的概念，是指将内存中暂时不需要的部分写入硬盘，看上去硬盘扩展了内存的容量，所以叫做“虚拟”内存。使用虚拟内存，应用程序可以使用比实际物理内存更大的内存空间。可以认为这个更大的内存空间就在硬盘上，只有将某一部分需要被用到时，才被写入真实内存；当它暂时不再被用到时，又被写回硬盘。分页式内存管理将物理内存分为等大的小块，每块大小通常为1K、2K、4K等，称为页帧；逻辑内存（使用虚拟内存技术扩大的内存，可认为其位于硬盘上）也被分为等大的小块，称为页；且页和页帧的大小一定是一样的，它是写入真实内存和写回硬盘最小单位。
> ** Optimal算法（最优算法） **
　　从内存中移除永远都不再需要的页面或者说是未来最长时间内不再被访问的页面，如果这样的页面存在，则选择最长时间不需要访问的页面。采用最佳置换算法，可以保证较低的页面更新频率。从理论上讲，由于无法预知哪一个页面是未来最长时间内不再被访问的，因而该算法无法实现，但是可用来衡量其他算法。

> ** FIFO（First-In First-Out，先进先出）算法 **
    该算法总是淘汰最早进入内存的页面，即选择在内存中停留时间最久的页面予以淘汰。
　　这个算法的实现简单，只需要将进程已调入内存中的页面，按照先后顺序连接成一个队列，设置一个替换指针，总是指向最老的页面。
　　但是该算法与进程实际的规律并不相适应，因为在进程中，有些页面经常被访问，比如：含有全局变量、常用函数、例程等的页面，FIFO不能保证这些页面不会被淘汰。
　　正是由于没有考虑页面的重要性的问题，FIFO算法很容易将重要的页换出内存。

> ** Second Chance（第二次机会）算法 **
　　为了避免FIFO算法将重要的页换出内存，Second Chance算法提供了一些改进。Second Chance算法在将页面换出内存前检查其使用位，如果其使用位为1，证明此页最近有被使用，猜测它还可能被使用，于是不把它置换出内存，但是把其使用位置为0，随后检查下一个页面，直到发现某页的使用位为0，将此页置换出内存。

> ** LRU（Least Recent Used, 最近最少使用）算法 **
　　在之前的FIFO算法中，依据的是各个页面调入内存的时间，这并不能反映页面的真实使用情况。而LRU（Latest Recently Used）是根据页面调入内存之后的使用情况。由于无法预测页面未来的情况，所以只能利用“最近的过去”来作为预测未来的方法，LRU选择的是最近最久未使用的页面予以淘汰。
　　该算法赋予每个页面一个访问字段，用来记录一个页面从上次被访问以来所经历的时间t，当需要淘汰一个页面的时候，选择现有页面中t的值最大的页面进行淘汰。
　　LRU是一种优秀的页面置换算法，但是需要硬件的支持，为了了解一个进程在内存中各个页面各有多少时间未被进程访问，以及如何快速地知道哪一个页面是最近最久未使用的页面，需要 寄存器+栈 来支持。

#### java相关：
##### synchronized 和Lock的区别 以及实现原理
>   教科书式的应试回答：
    主要相同点：Lock能完成synchronized所实现的所有功能
    主要不同点：Lock有比synchronized更精确的线程语义和更好的性能。synchronized会自动释放锁，而Lock一定要求程序员手工释放，并且必须在finally从句中释放。

| 类别 | synchronized | synchronized | 
|: - :| :-: | : -: | 
| 存在层次 | Java的关键字，在jvm层面上 | 是一个类|
| 锁的释放 | 1、以获取锁的线程执行完同步代码，释放锁 2、线程执行发生异常，jvm会让线程释放锁	| 在finally中必须释放锁，不然容易造成线程死锁 |
| 锁的获取 | 假设A线程获得锁，B线程等待。如果A线程阻塞，B线程会一直等待	| 分情况而定，Lock有多个锁获取的方式，具体下面会说道，大致就是可以尝试获得锁，线程可以不用一直等待|
| 锁状态 | 无法判断	| 可以判断|
| 锁类型 | 可重入 不可中断 非公平 | 可重入 可判断 可公平（两者皆可）|
|性能 | 少量同步 | 大量同步|
关于同步类(java.util.concurrent包下)的介绍可以看这个 http://blog.huangyuanlove.com/2018/03/20/Java%E5%B9%B6%E5%8F%91%E5%A4%9A%E7%BA%BF%E7%A8%8B%E5%90%8C%E6%AD%A5/#more
关于Lock的底层实现可以看这篇：https://blog.csdn.net/Luxia_24/article/details/52403033
关于synchronized可以看这篇 https://blog.csdn.net/u012403290/article/details/64910926?locationNum=11&fps=1

##### Map、Set、List区别
这个自己翻一下源码看一下就好
Map-> HashMap(存入数据的过程，hash冲突了怎么办),TreeMap,LinkedHashMap
Set-> 使用Map实现的，set中存放的数据对应map中的key，value是内部的一个object字段
list-> ArrayList(数组),LinkedList(链表)区别，优缺点

##### Java虚拟机
这个主要是问内存区域，垃圾回收算法，可以参考这里：
JVM-内存分配与回收策略 http://blog.huangyuanlove.com/2017/04/07/JVM-%E5%86%85%E5%AD%98%E5%88%86%E9%85%8D%E4%B8%8E%E5%9B%9E%E6%94%B6%E7%AD%96%E7%95%A5/
JVM-垃圾收集算法与实现  http://blog.huangyuanlove.com/2017/03/30/JVM-%E5%9E%83%E5%9C%BE%E6%94%B6%E9%9B%86%E7%AE%97%E6%B3%95/
JVM垃圾回收-对象已死？ http://blog.huangyuanlove.com/2017/03/29/JVM%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6-%E5%AF%B9%E8%B1%A1%E5%B7%B2%E6%AD%BB%EF%BC%9F/
JVM内存区域 http://blog.huangyuanlove.com/2017/03/27/JVM%E5%86%85%E5%AD%98%E5%8C%BA%E5%9F%9F/

##### 捕获子线程异常
``` java
new Thread().setUncaughtExceptionHandler(new Thread.UncaughtExceptionHandler() {
           @Override
           public void uncaughtException(Thread t, Throwable e) {
               
           }
       });
Thread.setDefaultUncaughtExceptionHandler(new Thread.UncaughtExceptionHandler() {
           @Override
           public void uncaughtException(Thread t, Throwable e) {

           }
       });
```
如果一个线程没有显式的设置它的UncaughtExceptionHandler，JVM就会检查该线程所在的线程组是否设置了UncaughtExceptionHandler，如果已经设置，就是用该UncaughtExceptionHandler；否则查看是否在Thread层面通过静态方法setDefaultUncaughtExceptionHandler()设置了UncaughtExceptionHandler，如果已经设置就是用该UncaughtExceptionHandler；如果上述都没有找到，JVM会在对应的console中打印异常的堆栈信息。
具体情况可以看一下Java并发编程的艺术

##### 线程池 
这是个大坑，看源码吧ThreadPoolExecutor.java，还有就是常见线程池的比较。

##### 单例模式 线程安全
单例的模式的N种写法，像什么double check、懒汉模式、静态内部类，还有就是枚举方式。这里会引出来`volatile`关键字，然后就是线程安全的问题。


#### Android相关：
##### 多进程写sp的问题
还是线程安全的问题，因为SP不支持两个进程同事去执行写操作，否则会导致一定几率的数据丢失，这是因为SP底层通过读写xml文件来实现的，并发写显然是有问题的
##### sp底层实现
读写xml文件
##### Activity和Fragment生命周期,生命周期函数是谁调用的
声明周期函数是由ActivityThread调度的，具体逻辑封装在Instrumentation类里面。具体读一下这两个类就好。
##### Activity启动模式，启动过程

启动模式：
* standard：标准模式，这也是系统的默认模式。每次启动一个Activity都会重新创建一个新的实例，不管这个实例是否已经存在。
* singleTop：栈顶复用模式。在这种模式下，如果新Activity已经位于任务栈的栈顶，那么此Activity不会被重新创建，同时它的onNewIntent方法会被回调，通过此方法的参数我们可以取出当前请求的信息。需要注意的是，这个Activity的onCreate、onStart不会被系统调用，因为它并没有发生改变。如果新Activity的实例已存在但不是位于栈顶，那么新Activity仍然会重新重建。
* singleTask：栈内复用模式。这是一种单实例模式，在这种模式下，只要Activity在一个栈中存在，那么多次启动此Activity都不会重新创建实例，和singleTop一样，系统也会回调其onNewIntent。
* singleInstance：单实例模式。这是一种加强的singleTask模式，它除了具有singleTask模式的所有特性外，还加强了一点，那就是具有此种模式的Activity只能单独地位于一个任务栈中，

还有一个参数 `TaskAffinity`,这个参数标识了一个Activity所需要的任务栈的名字，默认情况下，所有Activity所需的任务栈的名字为应用的包名。当然，我们可以为每个Activity都单独指定TaskAffinity属性，这个属性值必须不能和包名相同，否则就相当于没有指定。TaskAffinity属性主要和singleTask启动模式或者allowTaskReparenting属性配对使用，在其他情况下没有意义。
还有Activity中能够影响启动模式、运行状态的标记位：

** FLAG_ACTIVITY_NEW_TASK **
这个标记位的作用是为Activity指定“singleTask”启动模式，其效果和在XML中指定该启动模式相同。
** FLAG_ACTIVITY_SINGLE_TOP **
这个标记位的作用是为Activity指定“singleTop”启动模式，其效果和在XML中指定该启动模式相同。
** FLAG_ACTIVITY_CLEAR_TOP **
具有此标记位的Activity，当它启动时，在同一个任务栈中所有位于它上面的Activity都要出栈。这个模式一般需要和FLAG_ACTIVITY_NEW_TASK配合使用，在这种情况下，被启动Activity的实例如果已经存在，那么系统会调用它的onNewIntent。如果被启动的Activity采用standard模式启动，那么它连同它之上的Activity都要出栈，系统会创建新的Activity实例并放入栈顶。通过1.2.1节中的分析可以知道，singleTask启动模式默认就具有此标记位的效果。
** FLAG_ACTIVITY_EXCLUDE_FROM_RECENTS **
具有这个标记的Activity不会出现在历史Activity的列表中，当某些情况下我们不希望用户通过历史列表回到我们的Activity的时候这个标记比较有用。它等同于在XML中指定Activity的属性android:excludeFromRecents="true"。

##### Intent匹配规则
启动Activity分为两种，显式调用和隐式调用。显式调用需要明确地指定被启动对象的组件信息，包括包名和类名，而隐式调用则不需要明确指定组件信息。原则上一个Intent不应该既是显式调用又是隐式调用，如果二者
共存的话以显式调用为主。显式调用很简单，这里主要介绍一下隐式调用。隐式调用需要Intent能够匹配目标组件的IntentFilter中所设置的过滤信息，如果不匹配将无法启动目标Activity。
为了匹配过滤列表，需要同时匹配过滤列表中的action、category、data信息，否则匹配失败。一个过滤列表中的action、category和data可以有多个，所有的action、category、data分别构成不同类别，同一类别的信息共同约束当前类别的匹配过程。只有一个Intent同时匹配action类别、category类别、data类别才算完全匹配，只有完全匹配才能成功启动目标Activity。另外一点，一个Activity中可以有多个intent-filter，一个Intent只要能匹配任何一组intent-filter即可成功启动对应的Activity。

* action的匹配规则
action是一个字符串，系统预定义了一些action，同时我们也可以在应用中定义自己的action。action的匹配规则是Intent中的action必须能够和过滤规则中的action匹配，这里说的匹配是指action的字符串值完全一样。一个过滤规则中可以有多个action，那么只要Intent中的action能够和过滤规则中的任何一个action相同即可匹配成功。需要注意的是，Intent中如果没有指定action，那么匹配失败。另外，action区分大小写，大小写不同字符串相同的action会匹配失败。
* category的匹配规则
category是一个字符串，系统预定义了一些category，同时我们也可以在应用中定义自己的category。category的匹配规则和action不同，它要求Intent中如果含有category，那么所有的category都必须和过滤规则中的其中一个category相同。换句话说，Intent中如果出现了category，不管有几个category，对于每个category来说，它必须是过滤规则中已经定义了的category。当然，Intent中可以没有category，如果没有category的话，按照上面的描述，这个Intent仍然可以匹配成功。这里要注意下它和action匹配过程的不同，action是要求Intent中必须有一个action且必须能够和过滤规则中的某个action相同，而category要求
Intent可以没有category，但是如果你一旦有category，不管有几个，每个都要能够和过滤规则中的任何一个category相同。
* data的匹配规则
data的匹配规则和action类似，如果过滤规则中定义了data，那么Intent中必须也要定义可匹配的data。在介绍data的匹配规则之前，我们需要先了解一下data的结构，因为data稍微有些复杂
``` xml
<data   android:scheme="string"
        android:host="string"
        android:port="string"
        android:path="string"
        android:pathPattern="string"
        android:pathPrefix="string"
        android:mimeType="string" />
```
data由两部分组成，mimeType和URI。mimeType指媒体类型，比如image/jpeg、audio/mpeg4-generic和video/*等，可以表示图片、文本、视频等不同的媒体格式，而URI中包含的数据就比较多了，下面是URI的结构：
` <scheme>://<host>:<port>/[<path>|<pathPrefix>|<pathPattern>] `
有如下过滤规则

` <data android:mimeType="image/*" /> `
这种规则指定了媒体类型为所有类型的图片，那么Intent中的mimeType属性必须为“image/*”才能匹配，这种情况下虽然过滤规则没有指定URI，但是却有默认值，URI的默认值为content和file。也就是说，虽然没有指定URI，但是Intent中的URI部分的schema必须为content或者file才能匹配，这点是需要尤其注意的。为了匹配上面中规则，我们可以写出如下示例
`intent.setDataAndType(Uri.parse("file://abc"),"image/png")。`
另外，如果要为Intent指定完整的data，必须要调用setDataAndType方法，不能先调用setData再调用setType，因为这两个方法彼此会清除对方的值。
最后，当我们通过隐式方式启动一个Activity的时候，可以做一下判断，看是否有Activity能够匹配我们的隐式Intent，如果不做判断就有可能出现上述的错误了。判断方法有两种：采用PackageManager的resolveActivity方法或者Intent的resolveActivity方法，如果它们找不到匹配的Activity就会返回null，我们通过判断返回值就可以规避上述错误了。另外，PackageManager还提供了queryIntentActivities方法，这个方法和resolveActivity方法不同的是：它不是返回最佳匹配的Activity信息而是返回所有成功匹配的Activity信息。
``` java
public abstract List<ResolveInfo> queryIntentActivities(Intent intent,int flags);
public abstract ResolveInfo resolveActivity(Intent intent,int flags);
```
上述两个方法的第一个参数比较好理解，第二个参数需要注意，我们要使用MATCH_DEFAULT_ONLY这个标记位，这个标记位的含义是仅仅匹配那些在intent-filter中声明了
`<category  android:name="android.intent.category.DEFAULT"/>`这个category的Activity。使用这个标记位的意义在于，只要上述两个方法不返回null，那么startActivity一定可以成功。如果不用这个标记位，就可以把intent-filter中category不含DEFAULT的那些Activity给匹配出来，从而导致startActivity可能失败。因为不含有DEFAULT这个category的Activity是无法接收隐式Intent的。

6. View点击事件分发流程
7. View绘制过程
8. Handler
9. 省电优化  不打扰系统休眠（不监听电量变化等，三方的可以hook  oop  hook住oncreat） 不做不必要的动作（界面后台要停止动画）
10. onmeasure  rl和fl经过几次measure
11. 广播的底层实现（binder）
12. 性能优化
13. recyclerview中瀑布流

#### 计算机网络相关：
1. websocket为什么能保持长连接
2. http  tcp/udp 热启动冷启动  tcp怎么解决拥塞  滑动窗口 udp

#### 其他：

加固原理 加的什么壳
kt var  val区别  when中的 is  in

