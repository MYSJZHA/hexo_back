[{"title":"elk简单环境搭建 for linux","date":"2017-06-13T11:39:30.000Z","path":"2017/06/13/elk简单环境搭建-for-linux/","text":"环境：ubuntu 16.06虚拟机：4核8G内存在官网下载的tag.gz包，官网地址https://www.elastic.co/webinars/introduction-elk-stack安装版本是5.4.1，本文只安装了Elasticsearch、Logstash、Kibana Elasticsearch 下载压缩包并解压 在es的根目录下config/elasticsearch.yml文件，内容如下1234567891011121314151617181920# Use a descriptive name for the node:node.name: xuannode ##不要有'-'、'_'、'+'# Path to directory where to store the data (separate multiple locations by comma):#path.data: /home/huangyuan/elk/elasticsearch/data## Path to log files:#path.logs: /home/huangyuan/elk/elasticsearch/logs/*## Set the bind address to a specific IP (IPv4 or IPv6):#network.host: 0.0.0.0## Set a custom port for HTTP:#http.port: 9200discovery.zen.ping.unicast.hosts: [\"0.0.0.0\"]http.cors.enabled: truehttp.cors.allow-origin: \"*\" logstash 下载压缩包并解压 创建一个logstash.conf文件，输入以下内容并保存: 123456789101112input&#123; file &#123; path =&gt; &quot;/home/huangyuan/elkdata/*.log&quot; &#125;&#125;output &#123; elasticsearch &#123; hosts =&gt; &quot;http://192.168.1.179:9200&quot; index =&gt; &quot;logstash-%&#123;+YYYY.MM.dd&#125;&quot; &#125; stdout &#123;&#125;&#125; 启动时执行 bin/logstash -f logstash.conf kibana 下载压缩包并解压缩 编辑config/kibana.yml12345678910# Kibana is served by a back end server. This setting specifies the port to use.server.port: 5601# Specifies the address to which the Kibana server will bind. IP addresses and host names are both valid values.# The default is 'localhost', which usually means remote machines will not be able to connect.# To allow connections from remote users, set this parameter to a non-loopback address.server.host: \"192.168.1.179\"# The Kibana server's name. This is used for display purposes.server.name: \"xuankibina\"# The URL of the Elasticsearch instance to use for all your queries.elasticsearch.url: \"http://192.168.1.179:9200\" 启动的时候依次启动 es、logstash、kibana就可以了PS:1.在LogStash的配置文件logstash.conf中,input配置的就是logstash要监听的文件路径，启动之后，先在监听的文件夹中创建一个log文件并输入随意内容。 elasticsearch不能用root用户启动 启动es报错max virtual memory areas vm.max_map_count [65530]is too low, increase to at least [262144]:解决方法是修改/etc/sysctl.conf配置文件，添加vm.max_map_count=262144，重启机器才起作用.以上","tags":[{"name":"elk","slug":"elk","permalink":"http://www.huangyuanlove.com/tags/elk/"}]},{"title":"git工具","date":"2017-05-10T08:51:11.000Z","path":"2017/05/10/git工具/","text":"公司代码版本管理系统由svn迁到了git，对于AndroidStudio来讲，内置的GUI工具足以应付日常开发，但在请求失败的情况下，对失败原因的提示不够清晰。个人习惯上用命令行，但是对于命令行中比较两个文件差异以及合并来说，个人还是不大习惯，于是就配置成了使用其他软件进行合并。可以使用$ git difftool --tool-help查看对比文件差异支持的软件，用$ git mergetool --tool-help查看合并代码支持的软件，个人只试过两种:codecompare和beyond compare。不习惯bc的界面，最后决定使用codecompare。 配置codecompare为diff和merge工具 安装codecompare软件 配置codecompare为diff工具 git config --global diff.tool codecompare 配置codecompare的路径path 后面是软件的安装路径 git config --global difftool.codecompare.path D://CodeCompare//CodeCompare.exe 配置codecompare为merge工具 git config --global merge.tool codecompare 配置codecompare的路径path 后面是软件的安装路径 git config --global difftool.codecompare.path D://CodeCompare//CodeMerge.exe 在比较本地修改后的文件与本地仓库中的文件差异时，执行 git difftool &lt;filename&gt;即可。当更新代码自动合并失败的时候，执行 git mergetool即可。 配置beyond compare为diff和merge工具配置方式和codecompare一样，需要注意的是： 如果beyond compare软件是4.X1) 如果git的版本低于2.2.0,配置的时候用bc32) 如果git的版本大于等于2.2.0,配置的时候用bc这个如何配置官网有说明，就不再赘述在比较本地修改后的文件与本地仓库中的文件差异时，执行 git difftool &lt;filename&gt;即可。当更新代码自动合并失败的时候，执行 git mergetool即可。有人不习惯git自动merge成功后填写merge信息的编辑器，说明一下，默认的编辑器是vim,不习惯用的话可以使用 git config --global core.edit &lt;软件路径&gt;来修改。需要注意的是，git命令行似乎读不到windows系统的path，需要写软件的绝对路径。 以上","tags":[{"name":"git","slug":"git","permalink":"http://www.huangyuanlove.com/tags/git/"},{"name":"git工具","slug":"git工具","permalink":"http://www.huangyuanlove.com/tags/git工具/"}]},{"title":"搭建git服务","date":"2017-04-15T02:25:31.000Z","path":"2017/04/15/搭建git服务/","text":"公司的版本控制要从SVN迁移到git，正式的开发环境还没有搭建好，于是自己做了一个简单git服务。环境：本机: win10，服务器：ubuntu 16.04 LTS,ip:192.168.1.103本地安装git环境，配置用户名和邮箱之类的信息，然后生成秘钥，生成方式见 http://blog.csdn.net/huangyuan_xuan/article/details/49125597。服务器： 安装git,ssh服务sudo apt install git ssh 新增用户，用户名为gitadduser git 初始化git仓库，我放在/home/git/repositorycd /home/git/repositorygit init --bare test.git--base参数是初始化裸仓库。执行tree命令可以查看目录结构如下： 添加秘钥将本地生成的id_rsa.pub文件里面的内容追加到/home/git/.ssh/authorized_keys文件中。可以先将秘钥文件上传到服务器，然后在服务器上操作文件，添加内容。 修改权限将 /home/git 所有者更改为git用户chown -R git:git /home/git用户home目录755权限chmod 755 /home/git.ssh目录700权限chmod 700 .sshauthorized_keys 600权限chmod 600 .ssh/authorized_keys 修改ssh配置文件配置文件是/etc/ssh/sshd_config，取消这行 AuthorizedKeysFile %h/.ssh/authorized_keys 前面的注释 重启ssh服务sudo service ssh restart 可选项：为了安全 禁止git用户shell登录，需要修改/etc/passwd将 git:x:1001:1001:,,,:/home/git:/bin/bash改为 git:x:1001:1001:,,,:/home/git:/usr/bin/git-shell 回到本地，进行克隆git clone git@192.168.1.103:/home/git/code/test.git或者git clone git@192.168.1.103:code/test.git如果ssh不是默认的22端口，则在ip后添加端口。","tags":[{"name":"git","slug":"git","permalink":"http://www.huangyuanlove.com/tags/git/"}]},{"title":"JVM-内存分配与回收策略","date":"2017-04-07T07:27:46.000Z","path":"2017/04/07/JVM-内存分配与回收策略/","text":"Java技术体系中所提倡的自动内存管理最终可以归结为自动化的解决了两个问题：给对象分配内存以及回收分配给对象的内存。对象的内存分配，往大方向讲，就是在堆上分配(但也可能经过JIT编译后被拆散为标量类型并间接地栈上分配)，对象主要分配在新生代的Eden区上，如果启动了本地线程分配缓冲，将按线程优先在TLAB上分配。少数情况下也可能会直接分配在老年代中，分配的规则并不是百分百固定的，其细节取决于当前使用的是哪一种垃圾回收器组合，还有虚拟机中与内存相关的参数设置。 对象优先在Eden分配大多数情况下，对象在新生代Eden区中分配，当Eden区没有足够空间进行分配时，虚拟机将发起一次Minor GC。虚拟机提供了-XX：+PrintGCDetails这个收集器日志参数，告诉虚拟机在发生垃圾收集行为时打印内存回收日志，并且在进程退出的时候输出当前的内存各区域分配情况。新生代GC(Minor GC):指发生在新生代的垃圾收集动作，因为Java对象大多都具备朝生夕灭的特性，所以Minor GC非常频繁，一般回收速度也比较快。老年代GC(Major GC/Full GC):指发生在老年代的GC，出现了Major GC，经常会伴随至少一次的Minor GC，(但非绝对的，在Parallel Scavenge收集器的手机策略里就有直接进行Major GC的策略选择过程)。Major GC的速度一般会比Minor GC慢10倍以上。 大对象直接进入老年代所谓的大对象是指，需要大量连续内存空间的Java对象，最典型的大对象就是那种很长的字符串以及数组，大对象对虚拟机的内存分配来说就是一个坏消息，经常出现大对象容易导致内存还有不少空间时就提前出发垃圾收集以获取足够的连续空间来”安置”它们。 长期存活的对象将进入老年代既然虚拟机采用了分代收集的思想来管理内存，那么内存回收时就必须能识别哪些对象应放在新生代，哪些对象应放在老年代中。为了做到这点，虚拟机给每个对象定义了一个对象年龄(Age)计数器。如果对象在Eden出生并经过第一个Minor GC后仍然存活，并且能被Survivor容纳的话，将被移动到Survivor空间中，并且对象年龄设为1。对象在Survivor区中每经过一个Minor GC，年龄就增加1岁，当它的年龄增加到一定程度(默认是15岁)，就会被晋升到老年代中。对象晋升老年代的年龄阈值，可以通过参数-XX：MaxTenuringThreshold设置。 动态对象年龄判定为了能更好的适应不同程序的内存状况，虚拟机并不是永远的要求对象的年龄必须达到了MaxTenuringThreshold才能晋升到老年代，如果Survivor空间中相同的年龄所有对象大小的总和大于Survivor空间的一般，年龄大于或等于改年龄的对象就可以直接进入老年代，无序等到MaxTenuringThreshold中要求的年龄。 空间分配担保在发生Minor GC之前，虚拟机会先检查老年代最大可用的连续空间是否大于新生代所有对象总空间，如果这个条件成立，那么Minor GC可以确保是安全的。如果不成立，则虚拟机会查看HandlePromotionFailure设置值是否允许担保失败。如果允许，那么会继续检查老年代最大可用的连续空间是否大于历次晋升到老年代对象的平均大小，如果大于，将尝试着进行一次Minor GC，尽管这次Minor GC是有风险的；如果小于，或者HandlePromotionFailure设置不允许冒险，那这时也要改为进行一次Full GC。新生代使用复制收集算法，但为了内存利用率，只使用其中一个Survivor空间来作为轮换备份，因此当出现大量对象在Minor GC后仍然存活的情况(最极端的情况就是内存回收后新生代中所有对象都存活)，就需要老年代进行分配担保，把Survivor无法容纳的对象直接进入老年代。 与生活中的贷款担保类似，老年代要进行这样的担保，前提是老年代本身还有容纳这些对象的剩余空间，一共有多少对象会活下来在实际完成内存回收之前是无法明确知道的，所以只好取之前每一次回收晋升到老年代对象容量的平均大小值作为经验值，与老年代的剩余空间进行比较，决定是否进行Full GC来让老年代腾出更多空间。取平均值进行比较其实仍然是一种动态概率的手段，也就是说，如果某次Minor GC存活后的对象突增，远远高于平均值的话，依然会导致担保失败(Handle Promotion Failure)。如果出现了HandlePromotionFailure失败，那就只好在失败后重新发起一次Full GC。 虽然担保失败时绕的圈子是最大的，但大部分情况下都还是会将HandlePromotionFailure开关打开，避免Full GC过于频繁。 以上","tags":[{"name":"JVM","slug":"JVM","permalink":"http://www.huangyuanlove.com/tags/JVM/"},{"name":"java","slug":"java","permalink":"http://www.huangyuanlove.com/tags/java/"}]},{"title":"JVM-垃圾收集算法与实现","date":"2017-03-30T02:27:05.000Z","path":"2017/03/30/JVM-垃圾收集算法/","text":"由于垃圾收集算法的实现涉及大量的程序细节，而且各个平台的虚拟机操作内存的方法又各不相同，这里只是介绍几种算法的思想及其发展过程。 垃圾收集算法标记-清除算法最基础的算法是”标记-清除”(Mark-Sweep)算法，算法分为’标记’和’清除’两个阶段：首先标记处所有需要回收的对象，在标记后统一回收所有被标记的对象。它的主要不足有两个：一个事效率问题，标记和清除两个过程的效率都不高；另外一个事空间问题，标记清除之后会产生大量不连续的内存碎片，空间碎片太多可能会导致以后再程序运行过程中需要分配较大对象时，无法找到足够的连续内存而不得不提前触发另一次垃圾收集动作。 1. 复制算法它将可用内存按容量划分为大小相等的两块，每次只使用其中的一块，当这一块的内存用完了，就将还存活着的对象复制到另外一块上面，然后把已经使用过的内存空间一次清理掉。这样使得每次都是对整个半区进行内存回收，内存分配时也就不用考虑内存碎片等复杂情况。只要移动堆顶指针，按顺序分配内存即可，实现简单，运行高效，只是这种算法的代价是将内存缩小为了原来的一般，代价太高。现在的商业虚拟机都采用这种手机算法回收新生代，IBM公司的专门研究表明，新生代中的对象98%是朝生夕死的，所以并不需要按照1:1的比例来划分内存空间，而是将内存分为一块较大的Eden空间和两块较小的Survivor空间，每次使用Eden和其中一块Survivor空间上，最后清理掉Eden和刚才用过的Survivor中还存活着的对象一次性复制到另外一块Survivor空间上，最后清理掉Eden和刚才用过的Survivor空间。 2. 标记-整理算法复制收集短发在对象存活率较高时就要进行较多的复制操作，效率将会变低。更关键的是，如果不想浪费一半的空间，就需要额外的控件进行分配担保，以应对被使用的的内存中所有对象都100%存活的极端情况，所以在老年代一半不能直接选用这种算法。根据老年代的特点，有人提出了另外一种”标记-整理”(Mark-Compact)算法，标记过程任然与”标记-清除”算法一样，但后续步骤不是直接对可回收对象进行清理，而是让所有存活的对象都向一端移动，然后直接清理掉端便捷以外的内存。 3. 分代收集算法当前商业虚拟机的垃圾收集都采用”分代收集”(Generational Collection)算法，这种算法并没有什么新的思想，只是根据对象的存货周期的不同将内存划分为几块，一般是把Java堆分为新生代和老年代，这样就可以根据各个年代的特点采用最适当的收集算法。在新生代中，每次垃圾收集时都发现有大批对象死去，只有少量存活，那就选用复制算法，只需要付出少量存活对象的复制成本就可以完成收集。而老年代中因为对象存活率高、没有额外空间对它进行分配担保，就必须使用”标记-清理”或者”标记-整理”算法来进行回收。 HotSpot算法实现枚举根节点从可达性分析中从GC Roots节点引用链这个操作为例，可作为GC Roots的节点主要在全局性的引用(例如常量或类静态属性)与执行上下文(例如栈帧中的本地变量表)中，现在很多应用仅仅方法区就有数百兆，如果要逐个检查这里面的引用，那么必然会消耗很多时间。另外，可达性分析对执行时间的敏感还体现在GC停顿上，因为这项分析工作必须在一个能确保一致性的快照中进行—-这里一致性的意思是指在这个分析期间整个执行系统看起来就像被冻结在某个时间点上，不可以出现分析过程中对象引用关系还在不断变化的情况，该点不满足的话分析结果准确性就无法得到抱枕。这点是导致GC进行时必须停顿所有Java执行线程(Sun将这件事情称为”Stop The World”)的其中一个重要原因，即使是在号称几乎不会发生停顿的CMS收集器中，枚举根节点时也是必须要停顿的。由于目前的主流java虚拟机使用的都是准确式GC，所以当执行系统停顿下来后，并不需要一个不漏的检查完所有执行上下文和全局引用位置，虚拟机应当是有办法直接得知哪些地方存放着对象引用。在HotSpot的实现中，是使用一组称为OopMap的数据结构来达到这个目的的，在类加载完成的时候，HotSpot就把对象内什么偏移量上是什么类型的数据计算出来，在JIT编译过程中，也会在特定的位置记录下栈和寄存器中哪些位置是引用，这样，GC在扫描时就可以直接得知这些信息了。 安全点在OopMap的协助下，HotSpot可以快速且准确地完成GC Roots枚举，但一个很现实的问题随之而来：可能导致引用关系变化，或者说OopMap内容变化的指令非常多，如果为每一条指令都生成对应的OopMap，那将会需要大量的额外空间，这样GC的空间成本将会变得很高。实际上，HotSpot也的确没有为每条指令都生成OopMap，前面已经提到，只是在“特定的位置”记录了这些信息，这些位置称为安全点（Safepoint），即程序执行时并非在所有地方都能停顿下来开始GC，只有在到达安全点时才能暂停。 Safepoint的选定既不能太少以致于让GC等待时间太长，也不能过于频繁以致于过分增大运行时的负荷。 所以，安全点的选定基本上是以程序“是否具有让程序长时间执行的特征”为标准进行选定的——因为每条指令执行的时间都非常短暂，程序不太可能因为指令流长度太长这个原因而过长时间运行，“长时间执行”的最明显特征就是指令序列复用，例如方法调用、循环跳转、 异常跳转等，所以具有这些功能的指令才会产生Safepoint。对于Sefepoint，另一个需要考虑的问题是如何在GC发生时让所有线程（这里不包括执行JNI调用的线程）都“跑”到最近的安全点上再停顿下来。 这里有两种方案可供选择：抢先式中断（Preemptive Suspension）和主动式中断（Voluntary Suspension），其中抢先式中断不需要线程的执行代码主动去配合，在GC发生时，首先把所有线程全部中断，如果发现有线程中断的地方不在安全点上，就恢复线程，让它“跑”到安全点上。 现在几乎没有虚拟机实现采用抢先式中断来暂停线程从而响应GC事件。而主动式中断的思想是当GC需要中断线程的时候，不直接对线程操作，仅仅简单地设置一个标志，各个线程执行时主动去轮询这个标志，发现中断标志为真时就自己中断挂起。轮询标志的地方和安全点是重合的，另外再加上创建对象需要分配内存的地方。 安全区域使用Safepoint似乎已经完美地解决了如何进入GC的问题，但实际情况却并不一定。Safepoint机制保证了程序执行时，在不太长的时间内就会遇到可进入GC的Safepoint。但是，程序“不执行”的时候呢？所谓的程序不执行就是没有分配CPU时间，典型的例子就是线程处于Sleep状态或者Blocked状态，这时候线程无法响应JVM的中断请求，“走”到安全的地方去中断挂起，JVM也显然不太可能等待线程重新被分配CPU时间。 对于这种情况，就需要安全区域（Safe Region）来解决。安全区域是指在一段代码片段之中，引用关系不会发生变化。 在这个区域中的任意地方开始GC都是安全的。 我们也可以把Safe Region看做是被扩展了的Safepoint。 在线程执行到Safe Region中的代码时，首先标识自己已经进入了Safe Region，那样，当在这段时间里JVM要发起GC时，就不用管标识自己为Safe Region状态的线程了。在线程要离开Safe Region时，它要检查系统是否已经完成了根节点枚举（或者是整个GC过程），如果完成了，那线程就继续执行，否则它就必须等待直到收到可以安全离开Safe Region的信号为止。以上","tags":[{"name":"Java","slug":"Java","permalink":"http://www.huangyuanlove.com/tags/Java/"},{"name":"JVM","slug":"JVM","permalink":"http://www.huangyuanlove.com/tags/JVM/"}]},{"title":"JVM垃圾回收-对象已死？","date":"2017-03-29T09:23:36.000Z","path":"2017/03/29/JVM垃圾回收-对象已死？/","text":"在堆里面存放着Java世界中几乎所有的对象实例，垃圾收集器在对堆进行回收前，第一件事情就是要确定这些对象之中哪些还存活着，哪些已经死去(即不能再被任何途径使用的对象)。 引用计数算法很多教科书判断对象是否存活的算法是这样的：给对象中添加一个引用计数器，每当有一个地方引用它时，计数器值就加1;当引用失效时，计数器就减1；任何时刻计数器为0的对象就是不可能再被使用的。客观来讲，引用计数法(Reference Counting)的实现简单，判定效率也很高，在大部分情况下它都是一个不错的算法，但是，至少主流的Java虚拟机里面没有选用引用计数器算法来管理内存，其中主要的原因是它很难解决对象之间相互循环引用的问题。 可达性分析算法在主流的商用程序语言的主流实现中，都是通过可达性分析(Reachability Analysis)来判定对象是否存活的。这个算吗的基本思路就是通过一系列的称为GC Roots的对象作为起始点，从这些节点开始向下搜索，搜索所走过的路径称为引用链(Reference Chain),当一个对象到GC Roots没有任何引用链相连时(在图论中，就是从GC Roots到这个对象不可达)，则证明此对象是不可用的。在Java语言中，可作为GC Roots的对象包括一下几种： 虚拟机栈(栈帧中的本地变量表)中引用的对象。 方法区中静态属性引用的对象。 方法区中常量引用的对象。 本地方法栈中JNI(一般说的Native方法)引用的对象 生存还是死亡即使在可达性分析算法中不可达的对象，也并非是非死不可的，这时候他们暂时处于缓刑阶段，要真正宣告一个对象死亡，至少要经历两次标记过程：如果对象在进行可达性分析后发现没有与GC Roots相连接的引用链，那它将会被第一次标记并且进行一次筛选，筛选的条件是此对象是否有必要执行finalize()方法。当对象没有覆盖finalize()方法，或者finalize()方法已经被虚拟机调用过，虚拟机将这两种情况都视为”没有必要执行”。如果这个对象呗判定为有必要执行finalize()方法，那么这个对象将会放置在一个叫做F-Queue的队列之中，并在稍后由一个虚拟机自动建立的、优先级低的Finalizer线程去执行它。这里所谓的执行是指虚拟机会触发这个方法，但并不承诺会等待它运行结束，这样做的原因是：如果一个对象在finalize()方法中执行缓慢，或者发生了死循环，将很可能会导致F-Queue队列中其他对象永久处于等待，甚至导致整个内存回收系统崩溃。finalize()方法是对象 逃脱死亡命运的最后一次机会，稍后GC将对F-Queue中的对象进行第二次小规模的标记。 回收方法区很多人认为方法区是没有垃圾收集的，Java虚拟机规范中确实说过可以不要求虚拟机方法区实现垃圾收集，而且在方法区中进行垃圾收集的性价比一般比较低：在堆中，尤其是在新生代中，常规应用进行一次垃圾收集一般可以回收70%-95%的空间，而永久代的垃圾收集效率远低于此。永久代的垃圾收集主要回收两部分内容：废弃常量和无用的类。回收废弃常量与回收Java堆中的对象非常类似。以常量池中字面量的回收为例：假如一个字符串”ABC”已经进入了常量池中，但是当前系统没有任何一个String对象是叫做”ABC”的，换句话说，就是没有任何String对象引用常量池中的”ABC”常量，也没有其他地方引用了这个字面量，如果这时繁盛内存回收，而且必要的话，这个”ABC”常量就会被系统清理出常量池，常量池中的其他类、方法、字段的符号引用也与此类似。判定一个常量是否是”废弃常量”比较简单，而要判定一个类是否是”无用的类”的条件则相对苛刻许多。类需要同时满足下面三个调教才能算是”无用的类”： 该类所有的实例都已经被回收，也就是Java堆中不存在该类的任何实例。 加载该类的ClassLoader已经被回收。 该类对用的java.lang.Class对象没有在任何对方被引用，无法在任何地方通过反射访问该类的方法。虚拟机可以对满足上述3个条件的无用类进行回收，这里说的仅仅是“可以”，而并不是和对象一样，不使用了就必然会回收。 是否对类进行回收，HotSpot虚拟机提供了-Xnoclassgc参数进行控制，还可以使用-verbose：class以及-XX：+TraceClassLoading、 -XX：+TraceClassUnLoading查看类加载和卸载信息，其中-verbose：class和-XX：+TraceClassLoading可以在Product版的虚拟机中使用，-XX：+TraceClassUnLoading参数需要FastDebug版的虚拟机支持。在大量使用反射、 动态代理、 CGLib等ByteCode框架、 动态生成JSP以及OSGi这类频繁自定义ClassLoader的场景都需要虚拟机具备类卸载的功能，以保证永久代不会溢出。 以上","tags":[{"name":"Java","slug":"Java","permalink":"http://www.huangyuanlove.com/tags/Java/"},{"name":"JVM","slug":"JVM","permalink":"http://www.huangyuanlove.com/tags/JVM/"}]},{"title":"Android N 应用内更新","date":"2017-03-28T02:30:31.000Z","path":"2017/03/28/Android-N-应用内更新/","text":"继之前跪在Android M的动态权限之后，最近又跪在了Android N的StrictMode上了。所以啊，要对技术持有敬畏的态度。场景如下：我司内部员工使用的APP需要有应用内更新的功能，意思就是在应用内下载最新版本的应用并且调起安装界面。方案：由于每次从新打开app都需要重新登录，那就在登录界面加上检查更新的接口请求，后台对比当前版本App的VersionCode 和 数据库存储的VersionCode对比，如果需要更新，则返回最新版本软件的下载地址，前端进行下载安装。当前端解析出下载地址后，弹出提示框，下载或者取消。点击下载则开启线程下载，同时在界面上显示下载进度，下载完成后，调起安装界面进行安装。代码很简单，这里放出不涉及我司业务的代码：1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950private void downLoadAPK() &#123; downLoadThread = new Thread(new Runnable() &#123; @Override public void run() &#123; try &#123; URL url = new URL(downLoadUrl); HttpURLConnection conn = (HttpURLConnection) url .openConnection(); conn.connect(); int length = conn.getContentLength(); InputStream is = conn.getInputStream(); File file = new File(\"\"); if (!file.exists()) &#123; file.mkdir(); &#125; File apkFile = new File(saveFilePath); if (apkFile.exists()) &#123; apkFile.delete(); &#125; FileOutputStream fos = new FileOutputStream(apkFile); int count = 0; byte buf[] = new byte[1024]; // 点击取消就停止下载. while (!interceptFlag) &#123; int numread = is.read(buf); count += numread; progress = (int) (((float) count / length) * 100); // 更新进度 getHandler().sendEmptyMessage(DOWN_UPDATE); if (numread &lt;= 0) &#123; // 下载完成通知安装 getHandler().sendEmptyMessage(DOWN_OVER); interceptFlag = false; &#125; fos.write(buf, 0, numread); &#125; fos.close(); is.close(); &#125; catch (Exception e) &#123; e.printStackTrace(); &#125; &#125; &#125;); downLoadThread.start(); &#125; 以上为下载文件的代码，逻辑很简单，起一个新线程，使用HttpURLConnection进行文件下载。123456789private void installAPK(String filePath) &#123; File apkFile = new File(filePath); Intent intent = new Intent(Intent.ACTION_VIEW); if (!apkFile.exists()) &#123; return; &#125; intent.setDataAndType(Uri.fromFile(apkFile), \"application/vnd.android.package-archive\"); context.startActivity(intent);&#125; 以上代码是刚开始写的安装软件的代码，在Android N 以下运行正常，但是在Android N上却爆出了如下错误，12345678910111213141516171819android.os.FileUriExposedException: file: exposed beyond app through Intent.getData() at android.os.StrictMode.onFileUriExposed(StrictMode.java:1799) at android.net.Uri.checkFileUriExposed(Uri.java:2346) at android.content.Intent.prepareToLeaveProcess(Intent.java:8949) at android.content.Intent.prepareToLeaveProcess(Intent.java:8908) at android.app.Instrumentation.execStartActivity(Instrumentation.java:1519) at android.app.ContextImpl.startActivity(ContextImpl.java:829) at android.app.ContextImpl.startActivity(ContextImpl.java:806) at android.content.ContextWrapper.startActivity(ContextWrapper.java:366) at com.mmuu.travel.service.ui.LoginFrg.installAPK(LoginFrg.java:349) at com.mmuu.travel.service.ui.LoginFrg.access$200(LoginFrg.java:66) at com.mmuu.travel.service.ui.LoginFrg$1.onFinish(LoginFrg.java:134) at android.os.CountDownTimer$1.handleMessage(CountDownTimer.java:127) at android.os.Handler.dispatchMessage(Handler.java:102) at android.os.Looper.loop(Looper.java:154) at android.app.ActivityThread.main(ActivityThread.java:6114) at java.lang.reflect.Method.invoke(Native Method) at com.android.internal.os.ZygoteInit$MethodAndArgsCaller.run(ZygoteInit.java:874) at com.android.internal.os.ZygoteInit.main(ZygoteInit.java:764) 网上搜了一下，是Android N在权限上做了一些修改：参考链接 https://developer.android.google.cn/about/versions/nougat/android-7.0-changes.html 系统权限更改为了提高私有文件的安全性，面向 Android 7.0 或更高版本的应用私有目录被限制访问 (0700)。此设置可防止私有文件的元数据泄漏，如它们的大小或存在性。此权限更改有多重副作用：私有文件的文件权限不应再由所有者放宽，为使用 MODE_WORLD_READABLE 和/或 MODE_WORLD_WRITEABLE 而进行的此类尝试将触发 SecurityException。 注：迄今为止，这种限制尚不能完全执行。应用仍可能使用原生 API 或 File API 来修改它们的私有目录权限。但是，我们强烈反对放宽私有目录的权限。 传递软件包网域外的 file:// URI 可能给接收器留下无法访问的路径。因此，尝试传递 file:// URI 会触发 FileUriExposedException。分享私有文件内容的推荐方法是使用 FileProvider。DownloadManager 不再按文件名分享私人存储的文件。旧版应用在访问 COLUMN_LOCAL_FILENAME 时可能出现无法访问的路径。面向 Android 7.0 或更高版本的应用在尝试访问 COLUMN_LOCAL_FILENAME 时会触发 SecurityException。通过使用 DownloadManager.Request.setDestinationInExternalFilesDir() 或 DownloadManager.Request.setDestinationInExternalPublicDir() 将下载位置设置为公共位置的旧版应用仍可以访问 COLUMN_LOCAL_FILENAME 中的路径，但是我们强烈反对使用这种方法。对于由 DownloadManager 公开的文件，首选的访问方式是使用ContentResolver.openFileDescriptor()。 解决方案： FileProvider1.1 在mainfest中加入FileProvider注册123456789101112&lt;application&gt; &lt;provider android:authorities=\"你的应用名.fileprovider\" android:name=\"android.support.v4.content.FileProvider\" android:grantUriPermissions=\"true\" android:exported=\"false\"&gt; &lt;meta-data android:name=\"android.support.FILE_PROVIDER_PATHS\" android:resource=\"@xml/filepaths\"/&gt; &lt;/provider&gt;&lt;/application&gt; 1.2 在res文件夹下新建xml文件夹，在xml文件夹中新建filepaths文件，这个文件名字和上面的 Android:resource后面的名字要一致编辑该文件：123456&lt;?xml version=\"1.0\" encoding=\"utf-8\"?&gt;&lt;paths&gt; &lt;external-path name=\"external_storage_root\" path=\"\" /&gt;&lt;/paths&gt; 1.3 修改安装代码1234567891011121314151617private void installAPK(String filePath) &#123; File apkFile = new File(filePath); Intent intent = new Intent(Intent.ACTION_VIEW); if (!apkFile.exists()) &#123; return; &#125; if (Build.VERSION.SDK_INT &gt;= Build.VERSION_CODES.N) &#123; intent.setFlags(Intent.FLAG_GRANT_READ_URI_PERMISSION); Uri contentUri = FileProvider.getUriForFile(context, BuildConfig.APPLICATION_ID + \".fileProvider\", apkFile); intent.setDataAndType(contentUri, \"application/vnd.android.package-archive\"); &#125; else &#123; intent.setDataAndType(Uri.fromFile(apkFile), \"application/vnd.android.package-archive\"); &#125; getActivity().getApplicationContext().startActivity(intent); context.finish(); &#125; 首先判断设备的Android版本，N或者N以上使用FileProvider进行安装，N一下还是原来的方式。注意调用startActivity要使用ApplicationContext，使用Activity.this会报错。 使用DownloadManager123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154public class ApkDownLoad &#123; public static final String DOWNLOAD_FOLDER_NAME = getLocalForderPath(); public static final String DOWNLOAD_FILE_NAME = \"XXX.apk\"; public static final String APK_DOWNLOAD_ID = \"apkDownloadId\"; private Context context; private String url; private String notificationTitle; private String notificationDescription; private DownloadManager downloadManager; private CompleteReceiver completeReceiver; /** * @param context * @param url 下载apk的url * @param notificationTitle 通知栏标题 * @param notificationDescription 通知栏描述 */ public ApkDownLoad(Context context, String url, String notificationTitle, String notificationDescription) &#123; super(); this.context = context; this.url = url; this.notificationTitle = notificationTitle; this.notificationDescription = notificationDescription; downloadManager = (DownloadManager) context .getSystemService(Context.DOWNLOAD_SERVICE); completeReceiver = new CompleteReceiver(); /** register download success broadcast **/ context.registerReceiver(completeReceiver, new IntentFilter( DownloadManager.ACTION_DOWNLOAD_COMPLETE)); &#125; public void execute() &#123; // 清除已下载的内容重新下载 long downloadId = UpdateUtils.getLong(context, APK_DOWNLOAD_ID); if (downloadId != -1) &#123; downloadManager.remove(downloadId); UpdateUtils.removeSharedPreferenceByKey(context, APK_DOWNLOAD_ID); &#125; Request request = new Request(Uri.parse(url)); // 设置Notification中显示的文字 request.setTitle(notificationTitle); request.setDescription(notificationDescription); // 设置可用的网络类型 request.setAllowedNetworkTypes(Request.NETWORK_MOBILE | Request.NETWORK_WIFI); // 设置状态栏中显示Notification request.setNotificationVisibility(DownloadManager.Request.VISIBILITY_VISIBLE_NOTIFY_COMPLETED); // 不显示下载界面 request.setVisibleInDownloadsUi(false); // 设置下载后文件存放的位置 File folder = Environment .getExternalStoragePublicDirectory(DOWNLOAD_FOLDER_NAME); if (!folder.exists() || !folder.isDirectory()) &#123; folder.mkdirs(); &#125; // 设置下载文件的保存路径 request.setDestinationInExternalPublicDir(DOWNLOAD_FOLDER_NAME, DOWNLOAD_FILE_NAME); // 设置文件类型 MimeTypeMap mimeTypeMap = MimeTypeMap.getSingleton(); String mimeString = mimeTypeMap.getMimeTypeFromExtension(MimeTypeMap .getFileExtensionFromUrl(url)); request.setMimeType(mimeString); // 保存返回唯一的downloadId UpdateUtils.putLong(context, APK_DOWNLOAD_ID, downloadManager.enqueue(request)); &#125; class CompleteReceiver extends BroadcastReceiver &#123; @Override public void onReceive(Context context, Intent intent) &#123; /** * get the id of download which have download success, if the id is * my id and it's status is successful, then install it **/ long completeDownloadId = intent.getLongExtra( DownloadManager.EXTRA_DOWNLOAD_ID, 0); long downloadId = UpdateUtils.getLong(context, APK_DOWNLOAD_ID); if (completeDownloadId == downloadId) &#123; // if download successful if (queryDownloadStatus(downloadManager, downloadId) == DownloadManager.STATUS_SUCCESSFUL) &#123; // clear downloadId UpdateUtils.removeSharedPreferenceByKey(context, APK_DOWNLOAD_ID); // unregisterReceiver context.unregisterReceiver(completeReceiver); // install apk String apkFilePath = new StringBuilder(Environment .getExternalStorageDirectory().getAbsolutePath()) .append(File.separator) .append(DOWNLOAD_FOLDER_NAME) .append(File.separator).append(DOWNLOAD_FILE_NAME) .toString(); install(context, apkFilePath); &#125; &#125; &#125; &#125; /** * 查询下载状态 */ public static int queryDownloadStatus(DownloadManager downloadManager, long downloadId) &#123; int result = -1; DownloadManager.Query query = new DownloadManager.Query() .setFilterById(downloadId); Cursor c = null; try &#123; c = downloadManager.query(query); if (c != null &amp;&amp; c.moveToFirst()) &#123; result = c.getInt(c .getColumnIndex(DownloadManager.COLUMN_STATUS)); &#125; &#125; finally &#123; if (c != null) &#123; c.close(); &#125; &#125; return result; &#125; /** * install app * * @param context * @param filePath * @return whether apk exist */ public static boolean install(Context context, String filePath) &#123; Intent i = new Intent(Intent.ACTION_VIEW); File file = new File(filePath); if (file != null &amp;&amp; file.length() &gt; 0 &amp;&amp; file.exists() &amp;&amp; file.isFile()) &#123; i.setDataAndType(Uri.parse(\"file://\" + filePath), \"application/vnd.android.package-archive\"); i.addFlags(Intent.FLAG_ACTIVITY_NEW_TASK); context.startActivity(i); return true; &#125; return false; &#125;&#125; 检测到需要升级时 new ApkDownLoad().execute()就可以了，其中UpdateUtils.getLong()是一个SharedPreferences封装。以上两种方式在小米5Android N 上实测有效以上","tags":[{"name":"Android爬坑之旅","slug":"Android爬坑之旅","permalink":"http://www.huangyuanlove.com/tags/Android爬坑之旅/"},{"name":"Android N","slug":"Android-N","permalink":"http://www.huangyuanlove.com/tags/Android-N/"}]},{"title":"JVM内存区域","date":"2017-03-27T10:00:21.000Z","path":"2017/03/27/JVM内存区域/","text":"Java虚拟机在执行Java程序的过程中会把它所管理的内存划分为若干个不同的数据区域.这些区域都有各自的用途,以及创建和销毁的时间.有的区域随着虚拟机进程的启动而存在,有些区域则依赖用户线程的启动和结束而建立和销毁.根据《Java虚拟机规范(JavaSE 7版)》的规定,Java虚拟机所管理的内存将会包括以下几个运行时数据区域.如下所示: 程序计数器程序计数器(Program Counter Register)是一块较小的内存空间,它可以看作是当前线程所执行的字节码的行号指示器.在虚拟机的概念模型里(仅是概念模型,各种虚拟机可能会通过一些更高效的方式去实现),字节码解释器工作时就是通过改变这个计数器的值来选取下一条需要执行的字节码指令,分支、循环、跳转、异常处理、线程恢复等基础功能都需要依赖这个计数器来完成.由于Java虚拟机的多线程是通过线程轮流切换并分配处理器执行时间的方式来实现的,在任何一个确定的时刻,一个处理器(对于多核处理器来说是一个内核)都只会执行一条线程中的指令.因此,为了线程切换后能恢复到正确的执行位置,每条线程都需要有一个独立的程序计数器,各条线程之间计数器互不影响,独立存储,我们称这类内存区域为”线程私有”的内存.如果线程正在执行的是一个Java方法,这个计数器记录的是正在执行的虚拟机字节码指令的地址;如果正在执行的是Native方法,这个计数器值则为空(Undefined).此内存区域是唯一一个在Java虚拟机规范中没有规定任何OutOfMemoryError情况的区域. Java虚拟机栈与程序计数器一样,Java虚拟机栈(Java Virtual Machine Stacks)也是线程私有的,它的生命周期与线程相同.虚拟机栈描述的是Java方法执行的内存模型:每个方法在执行的同时都会创建一个栈帧(Stack Frame)用于存储局部变量表、操作数栈、动态链接、方法出口等信息.每一个方法从调用直至执行完成的过程,就对应着一个栈帧在虚拟机栈中入栈到出栈的过程.经常有人把Java内存区分为堆内存(Heap)和栈内存(Stack),这种分法比较粗糙,Java内存区域的划分实际上远比这复杂. 这种划分方式的流行只能说明大多数程序员最关注的、与对象内存分配关系最密切的内存区域是这两块.所指的”栈”就是现在讲的虚拟机栈,或者说是虚拟机栈中局部变量表部分.局部变量表存放了编译期可知的各种基本数据类型(boolean、byte、char、short、int、float、long、double)、对象引用(reference类型,它不等同于对象本身,可能是一个指向对象起始地址的引用指针,也可能是指向一个代表对象的句柄或其他与此对象相关的位置)和returnAddress类型(指向了一条字节码指令的地址).其中64位长度的long和double类型的数据会占用2个局部变量空间(Slot),其余的数据类型只占用1个. 局部变量表所需的内存空间在编译期间完成分配,当进入一个方法时,这个方法需要在帧中分配多大的局部变量空间是完全确定的,在方法运行期间不会改变局部变量表的大小.在Java虚拟机规范中,对这个区域规定了两种异常状况:如果线程请求的栈深度大于虚拟机所允许的深度,将抛出StackOverflowError异常;如果虚拟机栈可以动态扩展(当前大部分的Java虚拟机都可动态扩展,只不过Java虚拟机规范中也允许固定长度的虚拟机栈),如果扩展时无法申请到足够的内存,就会抛出OutOfMemoryError异常. 本地方法栈本地方法栈(Native Method Stack)与虚拟机栈所发挥的作用是非常相似的,它们之间的区别不过是虚拟机栈为虚拟机执行Java方法(也就是字节码)服务,而本地方法栈则为虚拟机使用到的Native方法服务. 在虚拟机规范中对本地方法栈中方法使用的语言、 使用方式与数据结构并没有强制规定,因此具体的虚拟机可以自由实现它. 甚至有的虚拟机(譬如Sun HotSpot虚拟机)直接就把本地方法栈和虚拟机栈合二为一. 与虚拟机栈一样,本地方法栈区域也会抛出StackOverflowError和OutOfMemoryError异常. Java堆对于大多数应用来说,Java堆(Java Heap)是Java虚拟机所管理的内存中最大的一块.Java堆是被所有线程共享的一块内存区域,在虚拟机启动时创建.此内存区域的唯一目的就是存放对象实例,几乎所有的对象实例都在这里分配内存.这一点在Java虚拟机规范中的描述是:所有的对象实例以及数组都要在堆上分配,但是随着JIT编译器的发展与逃逸分析技术逐渐成熟,栈上分配、标量替换优化技术将会导致一些微妙的变化发生,所有的对象都分配在堆上也渐渐变得不是那么”绝对”了.Java堆是垃圾收集器管理的主要区域,因此很多时候也被称做”GC堆”(Garbage Collected Heap).从内存回收的角度来看,由于现在收集器基本都采用分代收集算法,所以Java堆中还可以细分为:新生代和老年代;再细致一点的有Eden空间、From Survivor空间、To Survivor空间等.从内存分配的角度来看,线程共享的Java堆中可能划分出多个线程私有的分配缓冲区(Thread Local Allocation Buffer,TLAB).不过无论如何划分,都与存放内容无关,无论哪个区域,存储的都仍然是对象实例,进一步划分的目的是为了更好地回收内存,或者更快地分配内存.根据Java虚拟机规范的规定,Java堆可以处于物理上不连续的内存空间中,只要逻辑上是连续的即可,就像我们的磁盘空间一样.在实现时,既可以实现成固定大小的,也可以是可扩展的,不过当前主流的虚拟机都是按照可扩展来实现的(通过-Xmx和-Xms控制). 如果在堆中没有内存完成实例分配,并且堆也无法再扩展时,将会抛出OutOfMemoryError异常. 方法区方法区(Method Area)与Java堆一样,是各个线程共享的内存区域,它用于存储已被虚拟机加载的类信息、常量、静态变量、即时编译器编译后的代码等数据.虽然Java虚拟机规范把方法区描述为堆的一个逻辑部分,但是它却有一个别名叫做Non-Heap(非堆),目的应该是与Java堆区分开来.对于习惯在HotSpot虚拟机上开发、 部署程序的开发者来说,很多人都更愿意把方法区称为”永久代”(Permanent Generation),本质上两者并不等价,仅仅是因为HotSpot虚拟机的设计团队选择把GC分代收集扩展至方法区,或者说使用永久代来实现方法区而已,这样HotSpot的垃圾收集器可以像管理Java堆一样管理这部分内存,能够省去专门为方法区编写内存管理代码的工作.对于其他虚拟机(如BEA JRockit、 IBM J9等)来说是不存在永久代的概念的.原则上,如何实现方法区属于虚拟机实现细节,不受虚拟机规范约束,但使用永久代来实现方法区,现在看来并不是一个好主意,因为这样更容易遇到内存溢出问题(永久代有-XX:MaxPermSize的上限,J9和JRockit只要没有触碰到进程可用内存的上限,例如32位系统中的4GB,就不会出现问题),而且有极少数方法(例如String.intern())会因这个原因导致不同虚拟机下有不同的表现. 因此,对于HotSpot虚拟机,根据官方发布的路线图信息,现在也有放弃永久代并逐步改为采用Native Memory来实现方法区的规划了,在目前已经发布的JDK1.7的HotSpot中,已经把原本放在永久代的字符串常量池移出.Java虚拟机规范对方法区的限制非常宽松,除了和Java堆一样不需要连续的内存和可以选择固定大小或者可扩展外,还可以选择不实现垃圾收集.相对而言,垃圾收集行为在这个区域是比较少出现的,但并非数据进入了方法区就如永久代的名字一样”永久”存在了.这区域的内存回收目标主要是针对常量池的回收和对类型的卸载,一般来说,这个区域的回收”成绩”比较难以令人满意,尤其是类型的卸载,条件相当苛刻,但是这部分区域的回收确实是必要的.根据Java虚拟机规范的规定,当方法区无法满足内存分配需求时,将抛出OutOfMemoryError异常. 运行时常量池运行时常量池(Runtime Constant Pool)是方法区的一部分. Class文件中除了有类的版本、字段、方法、接口等描述信息外,还有一项信息是常量池(Constant Pool Table),用于存放编译期生成的各种字面量和符号引用,这部分内容将在类加载后进入方法区的运行时常量池中存放.Java虚拟机对Class文件每一部分(自然也包括常量池)的格式都有严格规定,每一个字节用于存储哪种数据都必须符合规范上的要求才会被虚拟机认可、装载和执行,但对于运行时常量池,Java虚拟机规范没有做任何细节的要求,不同的提供商实现的虚拟机可以按照自己的需要来实现这个内存区域.不过,一般来说,除了保存Class文件中描述的符号引用外,还会把翻译出来的直接引用也存储在运行时常量池中.运行时常量池相对于Class文件常量池的另外一个重要特征是具备动态性,Java语言并不要求常量一定只有编译期才能产生,也就是并非预置入Class文件中常量池的内容才能进入方法区运行时常量池,运行期间也可能将新的常量放入池中,这种特性被开发人员利用得比较多的便是String类的intern()方法.既然运行时常量池是方法区的一部分,自然受到方法区内存的限制,当常量池无法再申请到内存时会抛出OutOfMemoryError异常. 直接内存直接内存(Direct Memory)并不是虚拟机运行时数据区的一部分,也不是Java虚拟机规范中定义的内存区域.但是这部分内存也被频繁地使用,而且也可能导致OutOfMemoryError异常出现,所以我们放到这里一起讲解.在JDK 1.4中新加入了NIO(New Input/Output)类,引入了一种基于通道(Channel)与缓冲区(Buffer)的I/O方式,它可以使用Native函数库直接分配堆外内存,然后通过一个存储在Java堆中的DirectByteBuffer对象作为这块内存的引用进行操作.这样能在一些场景中显著提高性能,因为避免了在Java堆和Native堆中来回复制数据.显然,本机直接内存的分配不会受到Java堆大小的限制,但是,既然是内存,肯定还是会受到本机总内存(包括RAM以及SWAP区或者分页文件)大小以及处理器寻址空间的限制.服务器管理员在配置虚拟机参数时,会根据实际内存设置-Xmx等参数信息,但经常忽略直接内存,使得各个内存区域总和大于物理内存限制(包括物理的和操作系统级的限制),从而导致动态扩展时出现OutOfMemoryError异常. 以上","tags":[{"name":"Java","slug":"Java","permalink":"http://www.huangyuanlove.com/tags/Java/"},{"name":"JVM","slug":"JVM","permalink":"http://www.huangyuanlove.com/tags/JVM/"}]},{"title":"Android的消息机制","date":"2017-03-23T06:00:09.000Z","path":"2017/03/23/Android的消息机制/","text":"Android消息机制主要是指Handler的运行机制，Handler的运行需要底层的MessageQueue和Looper的支撑。MessageQueue的中文翻译是消息队列，他的内部存储了一组消息，以队列的形式对外提供插入和删除的工作。虽然叫消息队列，但是它的内部存储结构并不是真正的队列，而是采用单链表的数据机构来存储消息队列，但是它的内部存储结构并不是真正的队列，而是采用单链表的数据结构来存储消息列表。Looper可以理解为消息循环。由于MessageQueue只是一个消息的存储单元，它不能去处理消息，而Looper就填补了这个功能，Looper会以无限昏眩的形式去查找是否有新消息，如果有的话就处理消息，否则就等待。Looper中海油一个特殊的概念，那就是ThreadLocal，ThreadLocal并不是现成，它的作用是可以在每个现成中存储数据。Handler创建的时候会采用当前线程的Looper来构造消息循环系统，ThreadLocal可以在不同的线程中互不干扰的存储并提供数据，Handler可以通过ThreadLocal轻松获取每个现成的Looper。需要注意的是，现成默认是没有Looper的，如果需要使用Handler就必须为现成创建Looper，我们经常提到的主线程，也叫UI线程，它就是ActivityThread，ActivityThread被创建时就会初始化Looper，这也是在主线程中默认可以使用Handler的原因。 ThreadLocal的工作原理ThreadLocal是一个县城内部的数据存储类，通过它可以在制定的线程中存储数据，数据存储以后，只能在制定的线程中才可以获取到存储的数据，对于其他线程来说则无法获取到，我们在使用的时候：1234567891011121314151617final ThreadLocal&lt;Boolean&gt; mBooleanThreadLocal = new ThreadLocal&lt;&gt;(); new Thread(\"Thread#1\")&#123; @Override public void run() &#123; mBooleanThreadLocal.set(false); Log.d(\"huangyuan\",\"Thread#1\" + mBooleanThreadLocal.get()); &#125; &#125;.start(); new Thread(\"Thread#2\")&#123; @Override public void run() &#123; mBooleanThreadLocal.set(true); Log.d(\"huangyuan\",\"Thread#2\" + mBooleanThreadLocal.get()); &#125; &#125;.start(); 这样，我们虽然在不同的线程中访问的是同一个ThreadLocal对象，但是他们的值确是不一样的。这是因为不同的线程访问同一个ThreadLocal的get方法，ThreadLocal内部会从各自的线程中取出一个数组，然后再从数组中根据当前ThreadLocal的索引去查找出对应的value值。ThreadLocal是一个泛型类，定义为public class ThreadLocal&lt;T&gt;,首先看ThreadLocal的set方法，如下：12345678public void set(T value) &#123; Thread t = Thread.currentThread(); ThreadLocalMap map = getMap(t); if (map != null) map.set(this, value); else createMap(t, value); &#125; 上面的方法中，首先会通过getMap方法获取ThreadLocalMap（存储线程的ThreadLocal数据），ThreadLocalMap是ThreadLocal类的静态内部类，其内部包含了一个静态内部类Entry，声明如下static class Entry extends WeakReference&lt;ThreadLocal&gt;,ThreadLocalMap类中有一个Entry类型的数组private Entry[] table;,下面是set方法的具体实现：1234567891011121314151617181920212223242526272829303132private void set(ThreadLocal key, Object value) &#123; // We don't use a fast path as with get() because it is at // least as common to use set() to create new entries as // it is to replace existing ones, in which case, a fast // path would fail more often than not. Entry[] tab = table; int len = tab.length; int i = key.threadLocalHashCode &amp; (len-1); for (Entry e = tab[i]; e != null; e = tab[i = nextIndex(i, len)]) &#123; ThreadLocal k = e.get(); if (k == key) &#123; e.value = value; return; &#125; if (k == null) &#123; replaceStaleEntry(key, value, i); return; &#125; &#125; tab[i] = new Entry(key, value); int sz = ++size; if (!cleanSomeSlots(i, sz) &amp;&amp; sz &gt;= threshold) rehash(); &#125; ThreadLocal的get方法如下：12345678910public T get() &#123; Thread t = Thread.currentThread(); ThreadLocalMap map = getMap(t); if (map != null) &#123; ThreadLocalMap.Entry e = map.getEntry(this); if (e != null) return (T)e.value; &#125; return setInitialValue(); &#125; 从ThreadLocal的set和get方法可以看出，他们所操作的对象都是当前线程的ThreadLocalMap对象的table数组，因此在不同线程中访问同一个ThreadLocal的set和get方法，他们对ThreadLocal所做的读写操作仅限于各自线程的内部，这就是为什么ThreadLocal可以在多个线程中互不干扰的存储和修改数据。 消息队列的工作原理消息队列在Android中指的是MessageQueue，MessageQueue主要包含两个操作，插入和读取。读取操作本身会伴随着删除操作，插入和读取对应的方法分别为enqueueMessage和next，其中enqueueMessage的作用是往消息队列中插入一跳消息，而next的作用是从消息队列中取出一条消息并将其从消息队列中移除，尽管MessageQueue叫消息队列，但是它的内部实现并不是用的队列，实际上它是通过一个单链表的数据结构来维护消息列表，单链表在插入和删除上比较有优势。下面是enqueueMessage的实现：1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253boolean enqueueMessage(Message msg, long when) &#123; if (msg.target == null) &#123; throw new IllegalArgumentException(\"Message must have a target.\"); &#125; if (msg.isInUse()) &#123; throw new IllegalStateException(msg + \" This message is already in use.\"); &#125; synchronized (this) &#123; if (mQuitting) &#123; IllegalStateException e = new IllegalStateException( msg.target + \" sending message to a Handler on a dead thread\"); Log.w(TAG, e.getMessage(), e); msg.recycle(); return false; &#125; msg.markInUse(); msg.when = when; Message p = mMessages; boolean needWake; if (p == null || when == 0 || when &lt; p.when) &#123; // New head, wake up the event queue if blocked. msg.next = p; mMessages = msg; needWake = mBlocked; &#125; else &#123; // Inserted within the middle of the queue. Usually we don't have to wake // up the event queue unless there is a barrier at the head of the queue // and the message is the earliest asynchronous message in the queue. needWake = mBlocked &amp;&amp; p.target == null &amp;&amp; msg.isAsynchronous(); Message prev; for (;;) &#123; prev = p; p = p.next; if (p == null || when &lt; p.when) &#123; break; &#125; if (needWake &amp;&amp; p.isAsynchronous()) &#123; needWake = false; &#125; &#125; msg.next = p; // invariant: p == prev.next prev.next = msg; &#125; // We can assume mPtr != 0 because mQuitting is false. if (needWake) &#123; nativeWake(mPtr); &#125; &#125; return true; &#125; 从其实现来安，主要操作其实就是单链表的插入操作。next的实现如下：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105Message next() &#123; // Return here if the message loop has already quit and been disposed. // This can happen if the application tries to restart a looper after quit // which is not supported. final long ptr = mPtr; if (ptr == 0) &#123; return null; &#125; int pendingIdleHandlerCount = -1; // -1 only during first iteration int nextPollTimeoutMillis = 0; for (;;) &#123; if (nextPollTimeoutMillis != 0) &#123; Binder.flushPendingCommands(); &#125; nativePollOnce(ptr, nextPollTimeoutMillis); synchronized (this) &#123; // Try to retrieve the next message. Return if found. final long now = SystemClock.uptimeMillis(); Message prevMsg = null; Message msg = mMessages; if (msg != null &amp;&amp; msg.target == null) &#123; // Stalled by a barrier. Find the next asynchronous message in the queue. do &#123; prevMsg = msg; msg = msg.next; &#125; while (msg != null &amp;&amp; !msg.isAsynchronous()); &#125; if (msg != null) &#123; if (now &lt; msg.when) &#123; // Next message is not ready. Set a timeout to wake up when it is ready. nextPollTimeoutMillis = (int) Math.min(msg.when - now, Integer.MAX_VALUE); &#125; else &#123; // Got a message. mBlocked = false; if (prevMsg != null) &#123; prevMsg.next = msg.next; &#125; else &#123; mMessages = msg.next; &#125; msg.next = null; if (DEBUG) Log.v(TAG, \"Returning message: \" + msg); msg.markInUse(); return msg; &#125; &#125; else &#123; // No more messages. nextPollTimeoutMillis = -1; &#125; // Process the quit message now that all pending messages have been handled. if (mQuitting) &#123; dispose(); return null; &#125; // If first time idle, then get the number of idlers to run. // Idle handles only run if the queue is empty or if the first message // in the queue (possibly a barrier) is due to be handled in the future. if (pendingIdleHandlerCount &lt; 0 &amp;&amp; (mMessages == null || now &lt; mMessages.when)) &#123; pendingIdleHandlerCount = mIdleHandlers.size(); &#125; if (pendingIdleHandlerCount &lt;= 0) &#123; // No idle handlers to run. Loop and wait some more. mBlocked = true; continue; &#125; if (mPendingIdleHandlers == null) &#123; mPendingIdleHandlers = new IdleHandler[Math.max(pendingIdleHandlerCount, 4)]; &#125; mPendingIdleHandlers = mIdleHandlers.toArray(mPendingIdleHandlers); &#125; // Run the idle handlers. // We only ever reach this code block during the first iteration. for (int i = 0; i &lt; pendingIdleHandlerCount; i++) &#123; final IdleHandler idler = mPendingIdleHandlers[i]; mPendingIdleHandlers[i] = null; // release the reference to the handler boolean keep = false; try &#123; keep = idler.queueIdle(); &#125; catch (Throwable t) &#123; Log.wtf(TAG, \"IdleHandler threw exception\", t); &#125; if (!keep) &#123; synchronized (this) &#123; mIdleHandlers.remove(idler); &#125; &#125; &#125; // Reset the idle handler count to 0 so we do not run them again. pendingIdleHandlerCount = 0; // While calling an idle handler, a new message could have been delivered // so go back and look again for a pending message without waiting. nextPollTimeoutMillis = 0; &#125; &#125; 可以返现next方法是一个无线循环的方法，如果消息队列为空，那么next方法会一直阻塞在这里，当有消息到来时，next方法会返回这条消息并将其从单链表中移除 Looper的工作原理Looper在Android的消息机制中扮演者消息循环的角色，具体来说就是它会不停地从MessageQueue中查看是否有新消息，如果有新消息就会立刻处理，否则就一直阻塞在那里。首先看一下它的构造方法，在构造中它会创建一个MessageQueue也就是消息队列，然后将当前线程的对象保存起来，如下：1234private Looper(boolean quitAllowed) &#123; mQueue = new MessageQueue(quitAllowed); mThread = Thread.currentThread(); &#125; Handler的工作需要Looper，没有Looper的线程就会报错，我们可以通过Looper.prepare()即可为当前线程创建一个Looper，接着通过Looper.loop()来开启消息循环。Looper除了prepare方法外，还提供了prepareMainLoop方法，这个方法主要是给主线程也就是ActivityThread创建Looper使用的，其本质也是通过prepare方法来实现的。由于主线程的Looper比较特殊，所有Looper提供了一个getMainLooper方法，通过它可以在任何地方获取到主线程的Looper。Looper也是可以退出的，Looper提供了quit个quitSafely来退出一个Looper，二者的区别是：quit会直接突出Looper，而quitSafely只是设定一个退出标记，然后把消息队列中的已有消息处理完毕后才安全的退出。Looper退出后，通过Handler发送的消息会失败，这个时候Handler的send方法会返回false。在子线程中，如果手动为其创建了Looper，那么在所有的事情完成以后应该调用quit方法来总之消息循环，否则这个子线程就会一直处于等待的状态，而如果退出Looper以后，这个县城就会立刻终止，因此甲乙不需要的时候终止Looper。 Looper最重要的一个方法是loop方法，只有调用了loop后，消息循环系统才会真正的起作用，实现如下： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960/** * Run the message queue in this thread. Be sure to call * &#123;@link #quit()&#125; to end the loop. */ public static void loop() &#123; final Looper me = myLooper(); if (me == null) &#123; throw new RuntimeException(\"No Looper; Looper.prepare() wasn't called on this thread.\"); &#125; final MessageQueue queue = me.mQueue; // Make sure the identity of this thread is that of the local process, // and keep track of what that identity token actually is. Binder.clearCallingIdentity(); final long ident = Binder.clearCallingIdentity(); for (;;) &#123; Message msg = queue.next(); // might block if (msg == null) &#123; // No message indicates that the message queue is quitting. return; &#125; // This must be in a local variable, in case a UI event sets the logger final Printer logging = me.mLogging; if (logging != null) &#123; logging.println(\"&gt;&gt;&gt;&gt;&gt; Dispatching to \" + msg.target + \" \" + msg.callback + \": \" + msg.what); &#125; final long traceTag = me.mTraceTag; if (traceTag != 0) &#123; Trace.traceBegin(traceTag, msg.target.getTraceName(msg)); &#125; try &#123; msg.target.dispatchMessage(msg); &#125; finally &#123; if (traceTag != 0) &#123; Trace.traceEnd(traceTag); &#125; &#125; if (logging != null) &#123; logging.println(\"&lt;&lt;&lt;&lt;&lt; Finished to \" + msg.target + \" \" + msg.callback); &#125; // Make sure that during the course of dispatching the // identity of the thread wasn't corrupted. final long newIdent = Binder.clearCallingIdentity(); if (ident != newIdent) &#123; Log.wtf(TAG, \"Thread identity changed from 0x\" + Long.toHexString(ident) + \" to 0x\" + Long.toHexString(newIdent) + \" while dispatching to \" + msg.target.getClass().getName() + \" \" + msg.callback + \" what=\" + msg.what); &#125; msg.recycleUnchecked(); &#125; &#125; loop方法是一个死循环，唯一跳出循环的方式是MessageQueue的next方法返回了null，当Looper的quit方法被调用时，Looper就会通知消息队列退出，当消息队列被标记为退出状态时，它的next方法就会返回null，也就是说，Looper必须退出，否则loop方法就会无限循环下去，loop方法会调用MessageQueue的next方法来获取新消息，而next方法是一个阻塞操作，当没有消息时，next方法会一直阻塞在那里，这也导致loop方法一直阻塞在那里，如果MessageQueue的next方法返回了新消息，Looper就会处理这条消息， msg.target.dispatchMessage(msg)，这里的 msg.target是发送这条消息的handler对象，这样Handler发送的消息最终又交个它的 dispatchMessage(msg);方法来处理了，但是这里不同的是，Handler的dispatchMessahe方法是在创建Handler时所使用的Looper中执行的，这样就成功的将代码逻辑切换到指定的线程中去执行了。 Handler的工作原理 Handler的工作主要包含消息的发送和接收过程。消息的发送可以通过post的一系列方法以及send的一系列方法来实现，post的一系列方法最终是通过send的一列方法来实现的。发送一条消息的典型过程如下： 12345678910111213141516171819202122232425262728 public final boolean sendMessage(Message msg) &#123; return sendMessageDelayed(msg, 0); &#125;public final boolean sendMessageDelayed(Message msg, long delayMillis) &#123; if (delayMillis &lt; 0) &#123; delayMillis = 0; &#125; return sendMessageAtTime(msg, SystemClock.uptimeMillis() + delayMillis); &#125;public boolean sendMessageAtTime(Message msg, long uptimeMillis) &#123; MessageQueue queue = mQueue; if (queue == null) &#123; RuntimeException e = new RuntimeException( this + \" sendMessageAtTime() called with no mQueue\"); Log.w(\"Looper\", e.getMessage(), e); return false; &#125; return enqueueMessage(queue, msg, uptimeMillis); &#125;private boolean enqueueMessage(MessageQueue queue, Message msg, long uptimeMillis) &#123; msg.target = this; if (mAsynchronous) &#123; msg.setAsynchronous(true); &#125; return queue.enqueueMessage(msg, uptimeMillis); &#125; 可以发现，Handler发送消息的过程仅仅是向消息队列中插入了一条消息，MessageQueue的next方法就会返回这条消息给Looper，Looper收到消息后就开始处理了，最终消息由Looper交由Handler处理，即Handler的dispatchMessage方法会被调用，这时Handler就是进入了处理消息的阶段。dispatchMessage的实现如下： 123456789101112public void dispatchMessage(Message msg) &#123; if (msg.callback != null) &#123; handleCallback(msg); &#125; else &#123; if (mCallback != null) &#123; if (mCallback.handleMessage(msg)) &#123; return; &#125; &#125; handleMessage(msg); &#125;&#125; Handler处理消息的过程如下： 检查Message的callback是否为null，不为null就通过handleCallback来处理消息，Message的callback是一个Runnable对象，实际上就是Handler的post方法所传递的Runnable参数。handleCallback的逻辑如下： 123private static void handleCallback(Message message) &#123; message.callback.run(); &#125; 其次，检查mCallback是否为null，不为null就调用没CallBack的HandlerMessage方法来处理消息，Callback是个接口，它的定义如下： /** * Callback interface you can use when instantiating a Handler to avoid * having to implement your own subclass of Handler. * * @param msg A {@link android.os.Message Message} object * @return True if no further handling is desired */ public interface Callback { public boolean handleMessage(Message msg); } 通过Callback可以采用如下方式来创建Handler对象：Handler handler = new Handler(callback)。 最后，调用Handler的handleMessahe方法来处理消息。 以上","tags":[{"name":"Android","slug":"Android","permalink":"http://www.huangyuanlove.com/tags/Android/"}]},{"title":"Window和WindowManager","date":"2017-03-21T12:05:01.000Z","path":"2017/03/21/Window和WindowManager/","text":"Window表示一个窗口的概念，在日常开发中直接接触WIndow的机会并不对，再试在某些特殊时候我们需要在桌面上显示一个类似悬浮窗的东西，那么这种效果就需要用到Window来实现。Window只是个抽象类，它的具体实现是PhoneWindow。创建一个Window是很简单的事，只需要通过WindowManager即可完成，WindowManager是外界访问Window的入口，Window的具体实现位于WindowMangerService中，WindowMnager和WindowManager的交互是一个IPC过程，Android中所有的视图都是通过Window来呈现的，不管是Activity、Dialog还是Toast，它们的视图实际上都是附加在Window上的，因此Window实际是View的直接管理者。 Window的内部机制Window是一个抽象的概念，每一个Window都对应着一个View和一个ViewRootImpl，Window和View通过ViewRootImpl来建立联系，因此Window并不是实际存在的，它是以View的形式存在，。这点从WindowManager的定义也可以看出，它提供的三个接口方法addView,updateViewLayout以及removeView都是针对View，这说明View才是Window存在的实体。在实际使用中无法直接访问Window，对Window的访问必须通过WindowManger。 Window的添加过程Window的添加过程需要通过WindowManager的addView来实现，WindowManager是一个接口，它的真正实现是WindowManagerImpl类，在WindowManagerImpl中Window的三大操作实现如下：123456789101112131415161718192021@Override public void addView(@NonNull View view, @NonNull ViewGroup.LayoutParams params) &#123; applyDefaultToken(params); mGlobal.addView(view, params, mContext.getDisplay(), mParentWindow); &#125; @Override public void updateViewLayout(@NonNull View view, @NonNull ViewGroup.LayoutParams params) &#123; applyDefaultToken(params); mGlobal.updateViewLayout(view, params); &#125;@Override public void removeView(View view) &#123; mGlobal.removeView(view, false); &#125; @Override public void removeViewImmediate(View view) &#123; mGlobal.removeView(view, true); &#125; WindowManagerImpl并没有直接实现Window的三大操作，而是全部交给了WindowManagerGlobal来处理，WindowManagerGlobal以工厂的形式向外提供自己的实现，WindowManagerImpl这种工作模式是典型的桥接模式，将所有的操作全部委托给WindowManagerGlobal来实现。在WindowManagerGlobal的addView方法主要分为如下几步： 检查参数是否合法，如果是子Window，那么还需要调整一些布局参数。 1234567891011121314151617181920212223242526public void addView(View view, ViewGroup.LayoutParams params, Display display, Window parentWindow) &#123; if (view == null) &#123; throw new IllegalArgumentException(\"view must not be null\"); &#125; if (display == null) &#123; throw new IllegalArgumentException(\"display must not be null\"); &#125; if (!(params instanceof WindowManager.LayoutParams)) &#123; throw new IllegalArgumentException(\"Params must be WindowManager.LayoutParams\"); &#125; final WindowManager.LayoutParams wparams = (WindowManager.LayoutParams) params; if (parentWindow != null) &#123; parentWindow.adjustLayoutParamsForSubWindow(wparams); &#125; else &#123; // If there's no parent, then hardware acceleration for this view is // set from the application's hardware acceleration setting. final Context context = view.getContext(); if (context != null &amp;&amp; (context.getApplicationInfo().flags &amp; ApplicationInfo.FLAG_HARDWARE_ACCELERATED) != 0) &#123; wparams.flags |= WindowManager.LayoutParams.FLAG_HARDWARE_ACCELERATED; &#125; &#125;&#125; 创建ViewRootImpl并将View添加到列表中。在WindowManagerGlobal内部有如下几个列表比较重要： 12345private final ArrayList&lt;View&gt; mViews = new ArrayList&lt;View&gt;(); private final ArrayList&lt;ViewRootImpl&gt; mRoots = new ArrayList&lt;ViewRootImpl&gt;(); private final ArrayList&lt;WindowManager.LayoutParams&gt; mParams = new ArrayList&lt;WindowManager.LayoutParams&gt;(); private final ArraySet&lt;View&gt; mDyingViews = new ArraySet&lt;View&gt;(); 在以上声明中，mView存储的是多有WIndow所对应的View,mRoots存储的是所有Window所对应的ViewRootImpl，mParams存储的是所有Window所对应的布局参数，而mDyingView则存储了那些正在被删除的View对象，或者说是那些已经调用removeView方法但是删除操作还未完成的Window对象，在addView中通过如下方式将Window的一系列对象添加到列表中：12345root = new ViewRootImpl(view.getContext(), display); view.setLayoutParams(wparams); mViews.add(view); mRoots.add(root); mParams.add(wparams); 通过ViewRootImpl来更新界面并完成Window的添加过程。这个过程由ViewRootImpl的setView方法来完成：12345678910111213// do this last because it fires off messages to start doing things try &#123; root.setView(view, wparams, panelParentView); &#125; catch (RuntimeException e) &#123; // BadTokenException or InvalidDisplayException, clean up. synchronized (mLock) &#123; final int index = findViewLocked(view, false); if (index &gt;= 0) &#123; removeViewLocked(index, true); &#125; &#125; throw e; &#125; 在setView内部会通过requestLayout来完成异步刷新请求。在下面的代码中，scheduleTraversals实际是View绘制的入口：12345678@Override public void requestLayout() &#123; if (!mHandlingLayoutInLayoutRequest) &#123; checkThread(); mLayoutRequested = true; scheduleTraversals(); &#125; &#125; 接着会通过WindowSession最终来完成Window的添加过程。 Window的删除过程Window的删除过程和添加过程一样，都是先通过WindowManagerImpl后，再进一步通过WindowManagerGlobal来实现的，如下：1234567891011121314151617public void removeView(View view, boolean immediate) &#123; if (view == null) &#123; throw new IllegalArgumentException(\"view must not be null\"); &#125; synchronized (mLock) &#123; int index = findViewLocked(view, true); View curView = mRoots.get(index).getView(); removeViewLocked(index, immediate); if (curView == view) &#123; return; &#125; throw new IllegalStateException(\"Calling with view \" + view + \" but the ViewAncestor is attached to \" + curView); &#125; &#125; removeView的逻辑很清晰，首先通过findViewLocked来查找待删除的View的索引，这个查找过程就是建立的数据遍历，然后再通过调用removeViewLocked来做进一步的删除，如下：123456789101112131415161718private void removeViewLocked(int index, boolean immediate) &#123; ViewRootImpl root = mRoots.get(index); View view = root.getView(); if (view != null) &#123; InputMethodManager imm = InputMethodManager.getInstance(); if (imm != null) &#123; imm.windowDismissed(mViews.get(index).getWindowToken()); &#125; &#125; boolean deferred = root.die(immediate); if (view != null) &#123; view.assignParent(null); if (deferred) &#123; mDyingViews.add(view); &#125; &#125; &#125; removeViewLocked是通过ViewRootImpl来完成删除操作的，在WindowManager中提供了两种删除接口removeView和removeViewImmediate,它们分别表示异步删除和同步删除，一般不需要使用removeViewImmediate这个方法。这里主要说异步删除的情况：具体的删除操作由ViewRootImpl的die方法来完成，在异步删除的情况下，die方法只是发送了一个请求删除的消息后就立刻返回了，这个时候View并没有完成删除操作，所以最后会将其添加到mDyingView中。ViewRootImpl的die方法如下：1234567891011121314151617boolean die(boolean immediate) &#123; // Make sure we do execute immediately if we are in the middle of a traversal or the damage // done by dispatchDetachedFromWindow will cause havoc on return. if (immediate &amp;&amp; !mIsInTraversal) &#123; doDie(); return false; &#125; if (!mIsDrawing) &#123; destroyHardwareRenderer(); &#125; else &#123; Log.e(mTag, \"Attempting to destroy the window while drawing!\\n\" + \" window=\" + this + \", title=\" + mWindowAttributes.getTitle()); &#125; mHandler.sendEmptyMessage(MSG_DIE); return true; &#125; 在die方法中只是做了简单的判断，如果是异步删除，那么就发送一个MSG_DIE的消息，ViewRootImpl中的Handler会处理此消息并调用doDie方法，如果是同步删除，那么就不发送消息直接调用doDie方法。在doDie内部会调用dispatchDetachedFromWindow方法，真正删除View的逻辑在dispatchDetachedFromWindow方法内部实现。dispatchDetachedFromWindow方法主要做四件事： 垃圾回收相关的工作，比如清除数据和消息，移除回调等。 通过Session的remove方法删除Window：mWindowSession.remove(mWindow)，这同样是一个IPC过程，最终会调用WindowManagerService的removeWindow方法。 调用View的dispatchDetachedFromWindow方法，在内部会调用View的onDetachedFromWindow以及onDetachedFromWindowInternal()。 调用WindowManagerGlobal的doRemoveView方法刷新数据，包括mRoots、mParams以及mDyingViews，需要将当前Window锁关联的这三类对象从列表中删除。Window的更新过程1234567891011121314151617181920public void updateViewLayout(View view, ViewGroup.LayoutParams params) &#123; if (view == null) &#123; throw new IllegalArgumentException(\"view must not be null\"); &#125; if (!(params instanceof WindowManager.LayoutParams)) &#123; throw new IllegalArgumentException(\"Params must be WindowManager.LayoutParams\"); &#125; final WindowManager.LayoutParams wparams = (WindowManager.LayoutParams)params; view.setLayoutParams(wparams); synchronized (mLock) &#123; int index = findViewLocked(view, true); ViewRootImpl root = mRoots.get(index); mParams.remove(index); mParams.add(index, wparams); root.setLayoutParams(wparams, false); &#125; &#125; 首先它需要更新View的LayoutParams并替换掉老的LayoutParams，接着再更新ViewRootImpl中的layoutParams，这一步是通过ViewRootImpl的setLayoutParams方法来实现的。在ViewRootImpl中会通过scheduleTraversals方法来对View重新布局，包括测量、布局、重绘这三个过程，除了View本身的重绘以外，ViewRootImpl还会通过WindowSession开更新Window的视图，这个过程最终是由WindowManagerService的relayoutWindow()来具体实现，它同样是一个IPC的过程。 以上","tags":[{"name":"Android","slug":"Android","permalink":"http://www.huangyuanlove.com/tags/Android/"}]},{"title":"简单的桌面小部件","date":"2017-03-20T03:51:11.000Z","path":"2017/03/20/简单的桌面小部件/","text":"实现一个简单的桌面小部件，响应点击事件，更新等功能。 定义小部件界面 定义小部件配置信息 定义小部件的实现类 声明小部件在AndroidStudio中只需要在main\\java下新建一个widget,就可以了，IDE会自动在res\\layout添加布局文件，在res\\xml下新建配置信息文件。然后就可以进行具体实现了。 定义小部件界面RemoteView目前并不能支持所有的View，现在支持的类型如下： Layout FrameLayout LinearLayout RelativeLayout GridLayout View AnalogClock Button Chronometer ImageButton ImageView ProgressBar TextView ViewFlipper ListView GridView StackView AdapterViewFlipper ViewStub 这个没什么好说的，按照写界面布局的方式写就好了，但是不建议写过于复杂的布局。 定义小部件配置信息下面的代码就是IDE自动成的配置信息文件，不喜欢IDE代劳的同学可以自己创建。12345678910&lt;?xml version=\"1.0\" encoding=\"utf-8\"?&gt;&lt;appwidget-provider xmlns:android=\"http://schemas.android.com/apk/res/android\" android:initialKeyguardLayout=\"@layout/test_remote_view_widget\" android:initialLayout=\"@layout/test_remote_view_widget\" android:minHeight=\"40dp\" android:minWidth=\"40dp\" android:previewImage=\"@drawable/example_appwidget_preview\" android:resizeMode=\"horizontal|vertical\" android:updatePeriodMillis=\"86400000\" android:widgetCategory=\"home_screen\"&gt;&lt;/appwidget-provider&gt; initialLayout：布局文件previewImage： 预览的图片updatePeriodMillis：刷新周期，单位毫秒 定义小部件的实现类实现的功能是当点击这个小部件的时候改变文字内容12345678910111213141516171819202122232425public class TestRemoteViewWidget extends AppWidgetProvider &#123; private static final String CLICK_ACTION = \"com.huangyuan.testwidget.TAP_CLICK_ACTION\"; @Override public void onReceive(Context context, Intent intent) &#123; super.onReceive(context, intent); Toast.makeText(context,\"onReceive:\" + intent.getAction(),Toast.LENGTH_SHORT).show(); if(intent.getAction().equals(CLICK_ACTION))&#123; AppWidgetManager appWidgetManager = AppWidgetManager.getInstance(context); RemoteViews remoteViews = new RemoteViews(context.getPackageName(),R.layout.test_remote_view_widget); remoteViews.setTextViewText(R.id.appwidget_text,\"点击\"); appWidgetManager.updateAppWidget(new ComponentName(context,TestRemoteViewWidget.class),remoteViews); &#125; &#125; @Override public void onUpdate(Context context, AppWidgetManager appWidgetManager, int[] appWidgetIds) &#123; Toast.makeText(context,\"onUpdate\" ,Toast.LENGTH_SHORT).show(); RemoteViews remoteViews = new RemoteViews(context.getPackageName(),R.layout.test_remote_view_widget); Intent clickIntent = new Intent(); clickIntent.setAction(CLICK_ACTION); PendingIntent pendingIntent = PendingIntent.getBroadcast(context,0,clickIntent,0); remoteViews.setOnClickPendingIntent(R.id.appwidget_text,pendingIntent); appWidgetManager.updateAppWidget(appWidgetIds,remoteViews); &#125;&#125; 其中还有其他方法： onEnabled:当该窗口小部件第一次添加到桌面时调用该方法，可添加多次，但只在第一次调用 onUpdate:小部件被添加时或者每次小部件更新时都会调用一次该方法，小部件的更新时机由updatePeriodMillis指定。 onDeleted:每删除一次桌面小部件就调用一次。 onDisabled:当最后一个该类型的桌面小部件被删除时调用该方法，追时最后一个。需要注意的是，更新remoteView时，不能直接访问里面的View,需要通过RemoteView所提供的一系列方法更新View。 更新文本： remoteViews.setTextViewText(); 更新图片： remoteViews.setImageViewResource();remoteViews.setImageViewBitmap(); 添加单击事件：remoteViews.setOnClickPendingIntent();","tags":[{"name":"Android","slug":"Android","permalink":"http://www.huangyuanlove.com/tags/Android/"}]},{"title":"通过简单的自定义view来看View的工作流程","date":"2017-03-18T06:54:01.000Z","path":"2017/03/18/通过简单的自定义view来看View的工作流程/","text":"通过简单的自定义View(画个圆)，来了解一下View的工作流程以及自定义View应该注意的地方。 一、自定义View的分类1.1 继承View重写onDraw方法这种方法主要用于实现一些不规则的效果，比如动态或者静态显示一些不规则的图形，采用这种方式需要自己支持wrap_content,并且padding需要自己处理. 1.2 继承ViewGroup派生特殊的Layout这种方式主要用于实现自定义布局，如流式布局。采用这种方式需要合适的处理ViewGroup的测量、布局这两个过程，并同时处理子元素的测量和布局过程。 1.3 继承特定的View(如TextView)这种方法一般用于扩展某种已有的View的功能，比如TextView，这种方法比较容易实现，不需要自己支持wrap_content和padding。 1.4 继承特定的ViewGroup采用这种方式不需要自己处理ViewGroup的测量和布局这两个过程。 二、值得注意的地方2.1 让View支持wrap_content这是因为直接继承View或者ViewGroup的控件，如果不在onMeasure中对wrap_content做特殊处理，那么当外界在适用wrap_content时就无法达到预期的效果。 2.2 如果有必要，让View支持padding这是因为如果直接继承View，如果不在draw方法中处理padding，那么padding属性是无法起作用的。另外，直接继承自ViewGroup的控件需要在onMeasure和onLayout中考虑padding和子元素的margin对其造成的影响，不然将导致padding和子元素的margin失效。 2.3 尽量不要在View中使用Handler，没必要因为View内部本身就提供了post系列的方法， 完全可以替代Handler的作用，当然除非你很明确要使用Handler来发送消息 2.4 及时停止动画和线程如果需要停止线程或者动画，可以在onDetachedFromWindow方法中处理，当包含此View的Activity退出或者当前View被remove时，View的onDetachedFromWindow方法会被调用，和此方法对应的是onAttachedToWindow，当包含此View的Activity启动时，View的onAttachedToWindow方法会被调用。 2.5 View带有滑动嵌套情形时，需要处理好滑动冲突如果有滑动冲突的话，那么要合适的处理滑动冲突，否则将会严重影响View的效果。 三、自定义View3.1 继承View重写onDraw方法首先来看一下代码1234567891011121314151617181920212223242526272829303132public class TestCustomCircleView extends View &#123; private int color = Color.RED; private Paint paint; public TestCustomCircleView(Context context) &#123; super(context); init(); &#125; public TestCustomCircleView(Context context, AttributeSet attrs) &#123; super(context, attrs); init(); &#125; public TestCustomCircleView(Context context, AttributeSet attrs, int defStyleAttr) &#123; super(context, attrs, defStyleAttr); init(); &#125; private void init()&#123; paint = new Paint(); paint.setColor(color); &#125; @Override protected void onDraw(Canvas canvas) &#123; super.onDraw(canvas); int width = getWidth(); int height = getHeight(); int radius = Math.min(width,height)/2; canvas.drawCircle(width/2,height/2,radius,paint); &#125;&#125; 上面的代码只是一种初级的实现，当我们进行使用的时候，只支持margin属性，并不支持padding属性。对onDraw方法进行修改，只要在绘制的时候考虑一下padding即可。123456789101112@Override protected void onDraw(Canvas canvas) &#123; super.onDraw(canvas); int paddingLeft = getPaddingLeft(); int paddingRight = getPaddingRight(); int paddingTop = getPaddingTop(); int paddingBottom = getPaddingBottom(); int width = getWidth() - paddingLeft - paddingRight; int height = getHeight() - paddingBottom - paddingTop; int radius = Math.min(width, height) / 2; canvas.drawCircle(paddingLeft + width / 2, paddingTop + height / 2, radius, paint); &#125; 但是现在还不能支持warp_content属性，现在使用wrap_content和使用match_parent没有任何区别：对于直接继承自View的控件，如果不对wrap_content做特殊处理，那么使用wrap_content就相当于使用match_parent.这里就需要我们重写onMeasure方法，当宽高属性为wrap_content时，取一个默认值。123456789101112131415161718192021222324252627282930@Overrideprotected void onMeasure(int widthMeasureSpec, int heightMeasureSpec) &#123; int desiredWidth = 100; int desiredHeight = 100; int widthMode = MeasureSpec.getMode(widthMeasureSpec); int widthSize = MeasureSpec.getSize(widthMeasureSpec); int heightMode = MeasureSpec.getMode(heightMeasureSpec); int heightSize = MeasureSpec.getSize(heightMeasureSpec); int width; int height; //宽度 if (widthMode == MeasureSpec.AT_MOST) &#123; width = Math.min(desiredWidth, widthSize); &#125; else if (widthMode == MeasureSpec.EXACTLY) &#123; width = widthSize; &#125; else &#123; width = desiredWidth; &#125; //高度 if (heightMode == MeasureSpec.AT_MOST) &#123; height = Math.min(desiredHeight, heightSize); &#125; else if (heightMode == MeasureSpec.EXACTLY) &#123; height = heightSize; &#125; else &#123; height = desiredHeight; &#125; setMeasuredDimension(width, height);&#125; 这样，当我们使用wrap_content时，就是使用默认的100px的值。 四、使用自定义属性4.1 创建自定义的配置文件在values目录下面创建自定义属性的XML，比如attrs.xml，也可以选择类似于attrs_circleview.xml等这种以attrs开头的文件名，当然这个文件名并没有什么限制，可以随便取名字。我们选择创建attrs.xml文件。12345&lt;resources&gt; &lt;declare-styleable name=\"TestCustomCircleView\"&gt; &lt;attr name=\"circle_color\" format=\"color\"/&gt; &lt;/declare-styleable&gt;&lt;/resources&gt; 4.2 在构造方法中解析自定义的属性值并做相应的处理1234567public TestCustomCircleView(Context context, AttributeSet attrs, int defStyleAttr) &#123; super(context, attrs, defStyleAttr); TypedArray typedArray = context.obtainStyledAttributes(attrs, R.styleable.TestCustomCircleView); color = typedArray.getColor(R.styleable.TestCustomCircleView_circle_color,Color.RED); typedArray.recycle(); init();&#125; 首先加载自定义属性集合，接着解析属性集合中TestCustomCircleView_circle_color，如果没有指定属性值，则使用Color.RED作为默认值。 4.3 在布局文件中使用自定义属性&lt;com.example.huangyuan.custom.TestCustomCircleView android:layout_width=\"wrap_content\" android:layout_height=\"wrap_content\" android:layout_gravity=\"center_horizontal\" app:circle_color=\"@color/grey\" /&gt;","tags":[{"name":"Android","slug":"Android","permalink":"http://www.huangyuanlove.com/tags/Android/"}]},{"title":"View的滑动","date":"2017-03-15T03:01:46.000Z","path":"2017/03/15/View的滑动/","text":"View的位置主要由它的四个顶点来决定，分别对应于View的四个属性：top,left,right,bottom,其中top是左上角的纵坐标，left是左上角的横坐标，right是右下角的横坐标，bottom是右下角的纵坐标。需要注意的是，这些坐标都是相当于View的父容器来说的，因此它是一种相对坐标，View的坐标和父容器的关系如下所示： width = right - leftheight = bottom - topleft = getLeft()right = getRight()top = getTop()bottom = getBottom()从Android3.0 开始，View增加了额外的几个参数：x,y,trabslationX和translationY。其中x和y是View左上角的坐标，而translationX和translationY是View左上角相对于父容器的偏移量。这几个参数也是相对于父容器的坐标，并且translationX和translationY的默认值是0，和View的四个基本的位置参数一样，View也为他们提供了get/set方法，这几个参数的换算关系如下x = left + translationX需要注意的是，View在平移过程中，top和left表示的是原始左上角的位置信息，其值并不会发生改变，此时发生改变的是x,y,translationX和translationY。 一 VelocityTracker 和 GestureDetector速度最终，用于追踪手指在滑动过程中的速度，包括水平和竖直方向的速度。使用方法在View的onTouchEvent方法中追踪当前单击事件的速度：12VelocityTracker velocityTracker = VelocityTracker.obtain();velocityTracker.addMovement(event); 接着，当我们想知道当前的滑动速度时，这个时候可以采用如下方式来获得当前速度：123velocityTracker.computeCurrentVelocity(1000);float xVelocity = velocityTracker.getXVelocity();float yVelocity = velocityTracker.getYVelocity(); 在这一步中有两点需要注意 获取速度之前必须先计算速度，即getXVelocity()和getYVelocity()之前必须调用computeCurrentVelocity(1000) 这里的速度时指一段时间内手指所划过的像素数，速度可以是负数，当手指在水平方向从左向右滑动时，速度为正，反之为负数。最后，当不在使用它的时候，需要调用clear方法来重置并回收内存:12velocityTracker.clear();velocityTracker.recycle(); 手势检测，用于辅助检测用户的单击、滑动、长按、双击等行为。首先创建GestureDetector的对象，接着接管View的onTouchEvent方法。做完下面两部，就可以有选择的实现接口中的方法了123GestureDetector gestureDetector = new GestureDetector(this,this); gestureDetector.setIsLongpressEnabled(false); return gestureDetector.onTouchEvent(event); 其中gestureDetector.setIsLongpressEnabled(false)是为了解决长按之后无法拖动的现象。 二 使用ScrollTo/ScrollBy调用方式 View.scrollTo(int x, int y),View.scrollBy(int x, int y)方法源码：12345678910111213141516171819202122232425262728293031/** * Set the scrolled position of your view. This will cause a call to * &#123;@link #onScrollChanged(int, int, int, int)&#125; and the view will be * invalidated. * @param x the x position to scroll to * @param y the y position to scroll to */ public void scrollTo(int x, int y) &#123; if (mScrollX != x || mScrollY != y) &#123; int oldX = mScrollX; int oldY = mScrollY; mScrollX = x; mScrollY = y; invalidateParentCaches(); onScrollChanged(mScrollX, mScrollY, oldX, oldY); if (!awakenScrollBars()) &#123; postInvalidateOnAnimation(); &#125; &#125; &#125; /** * Move the scrolled position of your view. This will cause a call to * &#123;@link #onScrollChanged(int, int, int, int)&#125; and the view will be * invalidated. * @param x the amount of pixels to scroll by horizontally * @param y the amount of pixels to scroll by vertically */ public void scrollBy(int x, int y) &#123; scrollTo(mScrollX + x, mScrollY + y); &#125; 从源码中可以看出，scrollBy实际上也是调用scrollBy的方法。需要注意的是在View的滑动过程中，mScrollX和mScrollY的改变规则：在滑动过程中，mScrollX的值总是等于View左边缘和View内容左边缘在水平方向的距离，而mScrollY的值总是等于View上边缘和View内容上边缘在竖直方向的距离。其中mScrollX和mScrollY的单位是像素，并且当View左边缘在View内容左边缘的右边时，mScrollX为正值，反之为负值；当View上边缘在View内容上边缘的下边时，mScrollY为正值，反之为负值。换句话说：从左向右滑动，mScrollX为负值，反之为正值；如果从上往下滑动，mScrollY为负值，反之为正值。意思就是说ScrollTo/ScrollBy只能滑动View的内容而不能滑动View本身，比如，只能滑动TextView的文字，而不能滑动TextView控件本身 三 使用动画这个没什么好介绍的，想要兼容3.0以下的属性动画，建议使用nineoldandroids来实现 四 改变布局参数改变布局参数，也就是改变·LayoutParams· 五 使用Scroller进行平滑移动自定义一个控件，添加成员变量·Scroller·，如下：123456789101112131415161718192021222324252627282930313233343536373839public class ScrollerTextView extends TextView &#123; private Scroller mScroller; public ScrollerTextView(Context context) &#123; super(context); mScroller = new Scroller(context); &#125; public ScrollerTextView(Context context, AttributeSet attrs) &#123; super(context, attrs); mScroller = new Scroller(context); &#125; public ScrollerTextView(Context context, AttributeSet attrs, int defStyleAttr) &#123; super(context, attrs, defStyleAttr); mScroller = new Scroller(context); &#125; public void smoothScrollBy(int dx,int dy)&#123; mScroller.startScroll(mScroller.getFinalX(),mScroller.getFinalY(),dx,dy,2000); invalidate(); &#125; public void smoothScrollTo(int fx, int fy)&#123; int dx = fx - mScroller.getFinalX(); int dy = fy - mScroller.getFinalY(); smoothScrollBy(dx,dy); &#125; @Override public void computeScroll() &#123; if(mScroller.computeScrollOffset())&#123; scrollTo(mScroller.getCurrX(), mScroller.getCurrY()); postInvalidate(); &#125; super.computeScroll(); &#125;&#125; 其实Scroller也是通过ScrollTO/ScrollBy实现的，同样只能滑动内容，不能滑动本身。PS：在调用startScroll时，并没有让View进行滑动。而是在调用invalidate()进行重绘的时候，会去调用computeScroll方法，但是computeScroll在View只是个空实现，因此需要我们自己去实现。在computeScroll中进行平移。也就是说当View重绘后在draw方法中调用computeScroll,而computeScroll又会去向Scroller获取当前的scrollX和scrollY,然后通过scrollTo方法实现滑动，接着又调用postInvalidate()方法来进行第二次重绘，这一次重绘过程和第一次一样，还是会去调用computeScroll()方法，如此反复，直到整个滑动过程结束。 以上","tags":[{"name":"Android","slug":"Android","permalink":"http://www.huangyuanlove.com/tags/Android/"}]},{"title":"《我的安卓爬坑之旅》-高德地图遇到的坑(2)","date":"2017-02-25T03:57:23.000Z","path":"2017/02/25/《我的安卓爬坑之旅》-高德地图遇到的坑-2/","text":"这篇博客是关于高德使用中遇到的问题，或许是因为开发文档中没有说明，或许是因为自己段位不够，反正就是遇到坑了。 关于定位点和覆盖物有这么一个业务需求：定位手机所在位置成功后，请求服务器数据，服务器返回手机所在地点指定范围内的的点，然后把这些点添加到地图上。刚开始还没有什么问题，按照官网的demo来做的，到后来数据量多的时候就出现了marker重叠的问题。当然，marker点多的话，重叠也是无法避免的，但是，把定位的标记也给覆盖掉了，这就有点不好了。也没有查到相关的api，demo上添加定位点也是用的marker，估计都是同一级别，按照添加的先后顺序覆盖叠加。后来找到了一个方法 mLocMarker.setToTop();这样可以把某个marker设置到最高的层级显示。还有一个方法是123456public void setDisplayLevel(int var1) &#123; IMarkerAction var2 = this.a.getIMarkerAction(); if(var2 != null) &#123; var2.setDisplayLevel(var1); &#125;&#125; 这个是Marker对象中的一个方法，但是从官方下载下来的文档中并没有提到这个方法，自己也没有去使用。了解过的朋友可以在评论区回复我一下，谢谢。 AndroidStudio第二次编译之后地图不显示AS2.2版本加了 Instant Run 模式，通常情况下这回节省我们很多时间，比如当我们修改了界面布局，想要在手机上看一下效果，没有必要重启整个应用，这个时候就可以使用 Instant Run 模式了，ide内部会进行判断是否需要重启整个应用，如果不需要，只会热重启当前页面。为这个功能点赞啊，有的时候页面藏的比较深，需要多步操作才能打开，这个功能可以节省很多时间。但是啊但是。。。我在Fragment中使用高德地图的时候，使用这个功能会出现地图加载不出来（一片空白），但是定位成功的问题。刚开始的是吓尿了，以为代码除了什么问题，直到我提了工单，看到回复后放心了： 您好，Instant Run 确实是不支持这种，目前他们也没有给出解决方案，这里有详细的解释http://stackoverflow.com/questions/33902467/android-studio-2-0-why-does-instant-run-not-work-when-modifying-xml-layout-reso感谢您的致信，欢迎持续关注高德开放平台！ 地图加载完成的回调函数因为业务上的原因，需要在地图加载完成后做一些操作，当时官网的开发者文档上没有啊，于是又提了工单，接到回复后又放心了 您好，AMap 提供了地图加载完成的方法， 可详见：12345aMap.setOnMapLoadedListener(new AMap.OnMapLoadedListener() &#123; @Override public void onMapLoaded() &#123; &#125; &#125;); 感谢您的致信，欢迎持续关注高德开放平台！ 步行路径规划当距离比较短时路线不在地图中间位置由于业务上的原因，自己的位置和目的地的距离较短，需要步行路径规划，但是啊但是，路径可以规划成功，但是把路径添加到地图上的时候，路径没有显示在屏幕中间位置啊，而是诡异的飘到了一边。反复检查了N边代码，没有问题啊，和官网demo一样啊，把坐标点抠出来，改一下官网demo的起始点(就是两个坐标值),然后，也出现了路径飘到一边的情况，于是又去提了万能的工单，看到工单的回复后，我又放心了 我：Demo是从官网的demo上改的，就在om.amap.map3d.demo.route包下的WalkRouteActivity这个类里面，改了一下mStartPoint，和 mEndPoint 的值，附件图片是我修改之后的值 private LatLonPoint mStartPoint = new LatLonPoint(39.990145, 116.481194);private LatLonPoint mEndPoint = new LatLonPoint(39.99026006391499, 116.4813472288069);从官网下载回来后只改了这两个地方，把key换成了自己的，其他地方的代码没有动。如果可以的话，你们可以试一下，找两个距离非常近的点。答复：您好，这个问题确实是由SDK内部处理不当引起的bug，我们会在下个版本中修复，给您带来不便深表歉意感谢您的致信，欢迎持续关注高德开放平台！ 解决方法：判断两个点的距离，小于500米的时候，取起始点位置连线的中间位置作为地图中间点，强制将地图上的此位置拉到屏幕中间。 以上","tags":[{"name":"Android","slug":"Android","permalink":"http://www.huangyuanlove.com/tags/Android/"},{"name":"Android爬坑之旅","slug":"Android爬坑之旅","permalink":"http://www.huangyuanlove.com/tags/Android爬坑之旅/"},{"name":"高德地图","slug":"高德地图","permalink":"http://www.huangyuanlove.com/tags/高德地图/"}]},{"title":"写在2016年末","date":"2016-12-31T15:29:04.000Z","path":"2016/12/31/写在2016年末/","text":"2016年的最后一天的最后半个小时了，写写这一年的收获总结和2017的计划吧。一个字总结了一下2016年：穷。当然这是开玩笑式的总结，但也是最接近事实的了。 2016总结技术方面：&nbsp;&nbsp;&nbsp;&nbsp;自从踏上IT这条不归路开始，就打算做一个全栈攻城狮，从敲下第一行hello world到自己独立用java写一个完整的大作业再到写出实际可用的程序到现在的工作，仔细想想已经五年多了吧。但是这仅仅是个开始，我对自己现在的定位是全栈攻城狮的道路刚刚慢出第一步，现在也就算是个全栈学徒吧。 编程技能自定级别python入门HTML初级J2EE初级JAVA中级Android中级Linux中级 在工作中也踩过、填过、挖过很多坑，万幸的是一直坚持了下来，没有放弃，也没有想过要转行的事，就想一直在这个行业发展，努力提高自己的技术。 15年双十二和今年的十二月四号，都参加了开源中国举办的源创汇年终盛典，接触到了很多大牛(虽然他们不曾记得我)，接触到很多以前没有见识过也没有想象过的东西，对自己的成长有很大帮助。 开通了自己的博客(gitpage),把博客从csdn迁移到github上，租用了腾讯云主机，备案了自己的域名，有了自己的简单的网站，可以写一些自己感兴趣的东西(自由的感觉真好，法无禁止皆可为)。 也感谢这一年来小伙伴的帮助，幸好有你们，帮我解决了困难。 当然，在这一年中也有很多事情不是那么顺利，从上家公司离职，从10月到12月，中间休息了两个月，回了一次家，跑去深圳和妹子玩了四五天的样子(几乎是全部时间都泡在图书馆了，沉迷学习无法自拔)，其余时间也就是看看书，打打游戏之类的，总之这两个月的时间大部分都被浪费掉了，没有任何收获。 生活上也没啥好说的，业余时间就是宅在家里，看看书，敲敲代码，打打游戏，不喜欢出去逛，貌似好像是在6、7月份的样子，二哥来北京玩，爬了一次八达岭长城，除此之外，就是去了三次漫展，其他的就没有什么了。 2017计划首先，最重要的就是提升自己的技术能力： python达到初级水平;html方面学习一下h5; J2EE方面学习一下ssm框架、nginx; JAVA和Android方面尽可能的提升自己，尽量在两年内能初步达到高级水平; Linux方面，熟悉一下vim，了解以下服务器方向的相关知识，毕竟自己只是拿linux做开发，没有把精力放在服务器假设方向。 生活方面就尽量改变一下自己宅的属性,尽量多出去走走吧(这个有点难，比提升技术实力还要难) 借用一本小说中的一段话吧： “其实所有的智慧生物都在饮鸩止渴。所有的智慧生物都在通过不断的科技进步，不断的探索未知来满足着自己的探索欲望。这些科技，以及理论还有知识，不是好东西，它们是毒药，它们会让文明形成强烈的依赖症，当所有的未知都被探索完毕的时候，这种鸩毒就会最终发作，并且让这个文明最终陷入到毒发身亡的境地之中。可是最可笑的是，虽然这个道理十分明显，可是包括我在内的所有文明，都无法逃脱这个怪圈。” “我……我怎么可以停止呢？就算它们明明是毒药，可是我也要不断的去吃啊。”萧宇喃喃自语着，“如果我的科技不能进步，如果现在就斩断我进步的道路，我现在就会发疯的。这一点是天生注定的，当我还在地球上的时候，当我拿起笔，拿起书本，学习到第一个数学公式，学习到第一个物理定理的时候，这种鸩毒就已经在我的灵魂深处深深的扎下了根，让我终其一生不得解脱。我的毒瘾会越来越大，我所需要的鸩毒分量会越来越多，我只能继续这样维持下去。以后再毒发，总比现在就毒发要好。” 这个死在旅途之中的文明，让萧宇想到了很多很多，对萧宇的灵魂造成了很深的触动。可是萧宇已经无法停下自己的脚步了。浩瀚广阔的星空，无边无际的宇宙，就像是美丽异常的罂粟花，明知道危险，可是还是有不计其数的文明，包括萧宇在内都踏了进去，并且一个个踊跃异常，生怕自己吸食毒品的速度要比其余的文明慢了一点。 以上。","tags":[{"name":"随笔","slug":"随笔","permalink":"http://www.huangyuanlove.com/tags/随笔/"}]},{"title":"《我的安卓爬坑之旅》--高德地图遇到的坑","date":"2016-12-18T15:58:39.000Z","path":"2016/12/18/《我的安卓爬坑之旅》-高德地图遇到的坑-1/","text":"这篇博客是关于高德使用中遇到的问题，或许是因为开发文档中没有说明，或许是因为自己段位不够，反正就是遇到坑了。 ####生成key 生成key的时候，同一个app下，可以填入相同的包名、key名称等。注意不要用错了key 由于高德地图升级的原因，需要将原来没有整理过的key先整理，使其属于某个应用，才可以继续创建其他的key。 ####文档 仅在入门指南中提到了需要加入 &lt;service android:name=&quot;com.amap.api.location.APSService&quot;&gt;&lt;/service&gt;开发注意事项里面居然没有提到。最关键的是，没有加入这个service时，定位有时还能成功，只是不能连续定位。我看的时候时从开发注意事项开始看的，完全没有注意到这一点，后来在demo中看到了需要加入这个配置，才能生效。 文档里面只给出了部分关键代码和部分关键类，完全不知道这个类怎么实例化，怎么去调用方法，调用方法的时候需要传入哪种类型的参数。就我个人看来，看官方api文档还不如去看他们的demo，文档写的真心不算好。官方部分demo地址官方demo地址官方sdk以及开发文档、demo等相关下载官方sdk、开发文档以及demo以后遇到坑再补充吧，估计遇到的都是文档中没有标明但在demo中有示例的那种。","tags":[{"name":"Android","slug":"Android","permalink":"http://www.huangyuanlove.com/tags/Android/"},{"name":"Android爬坑之旅","slug":"Android爬坑之旅","permalink":"http://www.huangyuanlove.com/tags/Android爬坑之旅/"},{"name":"高德地图","slug":"高德地图","permalink":"http://www.huangyuanlove.com/tags/高德地图/"}]},{"title":"自己写个APP","date":"2016-12-01T08:00:22.000Z","path":"2016/12/01/自己写个APP/","text":"自己动手写个App吧，包括前端(Android,Web)和后台(J2EE)继上次自己写了个应用后，现在又想再写一个好点的，因为上次写的太矬了： 后端用jsp+servlet+MongoDB，简单粗暴。 前端使用Volley网络请求，以及从github上找的布局菜单框架，智能回复接入的图灵机器人 还有一堆bug 勉强在应用宝上线了，但是没啥意思。现在又想再写一个APP了，写的规范点吧，主要想法如下：Android向 主体框架使用 ‘dataBinding’ 和 ‘mvvm’ 模式 网络请求使用’okHttp’框架 列表使用主要使用’RecyclerView’ 客户端数据库框架使用’greendao’ 加密使用’md5’ 图片下载缓存使用’universal image loader’ android 三大图片缓存原理、特性对比 json解析使用’Gson’ 广播使用’BusEvent’ 使用’腾讯BugLy’统计崩溃信息 打算加入’热修复’功能360热修复demo,原理自行搜索吧,这个功能只是但算加入的. 界面风格使用 Material Design 后端向–J2EE 主题框架使用 ssm 数据库使用MySql 其他主要功能和QQ空间差不多吧，记录自己的心情以及聊天之类的。打算把自己的开发过程记录下来，主要是总结之类的吧，不定期更新。","tags":[{"name":"Android","slug":"Android","permalink":"http://www.huangyuanlove.com/tags/Android/"},{"name":"自己写个APP","slug":"自己写个APP","permalink":"http://www.huangyuanlove.com/tags/自己写个APP/"},{"name":"J2EE","slug":"J2EE","permalink":"http://www.huangyuanlove.com/tags/J2EE/"}]},{"title":"《我的安卓爬坑之旅》--融云IM遇到的坑","date":"2016-12-01T07:20:47.000Z","path":"2016/12/01/《我的安卓爬坑之旅》-融云IM遇到的坑/","text":"这篇博客是关于融云IM使用中遇到的问题，不算是坑，只能说是注意事项吧 后端向 在自己的应用”OurStories”中打算接入IM即时通讯功能，就使用了融云提供的sdk，需要自己写后台获取Token，这个比较简单，官方给出了Demo，按照自己的习惯，把demo里面的方法封装一下就可以使用了。 Token向 获取Token时可以在融云后台（登录自己帐号，控制台）可以设置Token有效期。 在初始情况下开发环境下最多只能有100个测试用户，当达到上限后可以点击添加用户的按钮，每次添加20人上限，生产环境没有上限。 开发环境和生产环境在融云后台是两套独立的环境，拥有不同的App Key和App Secret，当产品上线时不要忘记切换自己服务器和app的配置，另外，app的App Key和服务器端的App Key要一致。####前端 Android向 由于集成融云的聊天界面个会话列表界面都是Fragment形式，在集成的过程中，包含该Fragment的Activity要继承自FragmentActivity，否则在开启聊天界面的时候会报如下异常： 1234Caused by: android.view.InflateException: Binary XML file line #6: Binary XML file line #6: Error inflating class fragment Caused by: android.view.InflateException: Binary XML file line #6: Error inflating class fragment Caused by: android.app.Fragment$InstantiationException: Trying to instantiate a class io.rong.imkit.fragment.ConversationFragment that is not a Fragment Caused by: java.lang.ClassCastException 融云在初始化的时候建议放在Applicatuon中进行，但是融云会开启3个进程，每个进程都会执行Application的OnCreate方法，建议在初始化自己的配置时检测以下进程，在自己的主进程中初始化自己的配置. 千万不要忘记配置包含融云Fragment的Activity的&lt;intent-filter&gt; 融云不同步也不会保存应用下的好友关系，需要自己的服务器保存 注意阅读融云的开发文档，注意每一个细节 有问题先去搜知识库，然后提工单。提工单的时候尽可能详细的描述自己的开发环境，遇到的问题以及异常日志。 非必要情况下，不要自己去反编译出融云的sdk，然后自己使用用其中的代码。","tags":[{"name":"Android","slug":"Android","permalink":"http://www.huangyuanlove.com/tags/Android/"},{"name":"Android爬坑之旅","slug":"Android爬坑之旅","permalink":"http://www.huangyuanlove.com/tags/Android爬坑之旅/"},{"name":"融云IM","slug":"融云IM","permalink":"http://www.huangyuanlove.com/tags/融云IM/"}]},{"title":"《我的安卓爬坑之旅》","date":"2016-11-21T08:07:25.000Z","path":"2016/11/21/《我的安卓爬坑之旅》/","text":"准备记录一下自己在工作学习中遇到的bug以及解决方案。不定期更新。内容包括但不限于android，J2EE，HTML，以及各种各样的需求。形式如下：bug：①出现bug的场景②尽可能放上代码③分析原因：源码及原理④解决方案：思路及尽可能的放上代码需求：①产品需求：尽可能详细描述产品需求，尽量能放上UI②分析可能的解决方案：思路③解决过程：自己的思路及解决方案和踩到的坑④解决方法：尽可能放上关键代码或者伪代码⑤其他：一些意想不到的事。 大家也可以发邮件到我的邮箱，把自己遇到的问题和大家分享一下email: huangyuan@huangyuanlove.com","tags":[{"name":"Android爬坑之旅","slug":"Android爬坑之旅","permalink":"http://www.huangyuanlove.com/tags/Android爬坑之旅/"},{"name":"android","slug":"android","permalink":"http://www.huangyuanlove.com/tags/android/"},{"name":"bug","slug":"bug","permalink":"http://www.huangyuanlove.com/tags/bug/"}]},{"title":"hexo+gitpage搭建自己的博客(三)","date":"2016-10-30T13:05:54.000Z","path":"2016/10/30/hexo-gitpage搭建自己的博客-三/","text":"前两篇介绍了怎么用gitpage+github搭建自己的博客，这次主要介绍怎么更换主题和加入评论、统计等。 更换主题首先将 yilia主题从github克隆到本地thems文件夹里面1git clone https://github.com/litten/hexo-theme-yilia.git themes/yilia 看一下当前博客目录的结构 其中_config.yml文件就是整个hexo系统的主配置文件另外刚才克隆的yilia主题就在thems文件夹下面首先修改根目录下的_config.yml文件，切换到yilia主题大概在文件的63-65行左右的位置1234# Extensions## Plugins: https://hexo.io/plugins/## Themes: https://hexo.io/themes/theme: yilia 将原来的theme后面的 landscape主题改成yilia重启服务后主题就切换到yilia了，下面是thems/yilia文件夹下的_config.yml文件的配置. 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566# Headermenu: 主页: / 简历: \"\"# SubNavsubnav: github: \"https://github.com/huangyuanlove\" #weibo: \"#\" #rss: \"#\" zhihu: \"https://www.zhihu.com/people/huangyuan_xuan\" #douban: \"#\" #mail: \"#\" #facebook: \"#\" #google: \"#\" #twitter: \"#\" #linkedin: \"#\"rss: /atom.xml# 是否需要修改 root 路径# 如果您的网站存放在子目录中，例如 http://yoursite.com/blog，# 请将您的 url 设为 http://yoursite.com/blog 并把 root 设为 /blog/。root:# Contentexcerpt_link: morefancybox: truemathjax: false# 是否开启动画效果animate: true# 是否在新窗口打开链接open_in_new: false# 自己添加的百度统计baidu_tongji: true# 网站iconfavicon: favicon.ico#你的头像urlavatar: \"\"#是否开启分享share_jia: falseshare_addthis: false#多说评论duoshuo:# 如不需要，将该项置为false# 比如#smart_menu:# friends: falsesmart_menu: innerArchive: '所有文章' tagcloud: '标签' #friends: '友链' aboutme: '关于我'friends:aboutme: &lt;a href=\"http://www.huangyuanlove.com\"&gt;什么懂都点的Android攻城狮&lt;/a&gt; 以上是yilia主题的配置说明接入百度统计首先到百度统计平台 申请一个帐号，按照提示填写完自己网站的信息，在网站中心左边栏点击代码获取，得到统计访问量的代码。新建themes/yilia/layout/_partial/baidu_tongji.ejs文件，内容如下：12345&lt;% if (theme.baidu_tongji) &#123; %&gt;&lt;script&gt; 统计访问量的代码&lt;/script&gt;&lt;% &#125; %&gt; 然后编辑themes/yilia/_config.yml文件，添加一行baidu_tongji: true，注意冒号后面有空格。编辑themes/yilia/layout/_partial/head.ejs 在 &lt;/head&gt; 前添加&lt;%- partial(&quot;baidu_tongji&quot;) %&gt;重启部署代码即可。安装完成20分钟后就可以在后台看到统计的信息了，如果看不到统计信息，请检查是否配置正确，检测方式点这里 http://tieba.baidu.com/p/3775626020以上是添加百度统计的方式添加多说评论到多说 申请帐号使用三方登录完成后，点击我要安装，根据提示填写完信息记住站点名称，将站点名称填入 thems/yilia/_config.yml文件里面多说评论之后，注意冒号后面有空格。保存重新部署就可以看到评论框了。至于评论样式，可以在后台管理页面中的设置选项中设置。后台管理中还可以管理评论内容，添加敏感词汇过滤等。以上是添加多说评论的过程。 以上","tags":[{"name":"blog","slug":"blog","permalink":"http://www.huangyuanlove.com/tags/blog/"},{"name":"gitpage","slug":"gitpage","permalink":"http://www.huangyuanlove.com/tags/gitpage/"},{"name":"hexo","slug":"hexo","permalink":"http://www.huangyuanlove.com/tags/hexo/"}]},{"title":"hexo+gitpage搭建自己的博客(二)","date":"2016-10-25T13:11:53.000Z","path":"2016/10/25/hexo-gitpage搭建自己的博客-二/","text":"之前我们已经安装好了hexo，接下来就是初始化了。123hexo init &lt;dir&gt;cd &lt;dir&gt;npm install 现在hexo就安装完成了，在存放hexo的文件夹目录下执行 hexo s，就可以启动hexo的服务，启动之后有提示，在浏览器中输入127.0.0.1:4000就可以看到最初的效果了，如下 对了，还要发布到github。前提准备是在上一篇中已经创建好了github的仓库。接下来在存放hexo资源的文件夹下(以下用 heox_blog这个文件夹代替)执行npm install hexo-deployer-git --save修改hexo_blog文件夹下的_config.yml文件在末尾添加1234deploy: type: git repository: git@github.com:your name/your name.github.io.git branch: master 注意，type，repository，branch冒号后面都有一个空格。保存后执行123hexo cleanhexo ghexo d 就可以将写好的博客部署到github上了。（部署到github时建议按照顺序执行以上命令） 12345hexo generate == hexo g --&gt;将md文件解析成静态的html文件hexo deploy == hexo d --&gt; 将文件部署到githubhexo server == hexo s --&gt; 启动本地hexo服务hexo clean --&gt; 清除缓存hexo new &quot;title&quot; --&gt; 创建新的文章，文件在`hexo_blog/source/_posts`文件夹下 以上","tags":[{"name":"blog","slug":"blog","permalink":"http://www.huangyuanlove.com/tags/blog/"},{"name":"gitpage","slug":"gitpage","permalink":"http://www.huangyuanlove.com/tags/gitpage/"},{"name":"hexo","slug":"hexo","permalink":"http://www.huangyuanlove.com/tags/hexo/"}]},{"title":"hexo+gitpage搭建自己的博客(一)","date":"2016-10-20T16:04:26.000Z","path":"2016/10/21/hexo-gitpage搭建自己的博客-一/","text":"不说环境直接写配置的行为都是耍流氓按照惯例,先说自己的环境:ubunu,然后就没有然后了.hexo类似wordpress的博客框架,gitpage是github的一个服务,请原谅我这个不大准确的表达,事实上真的差不多.安装hexo需要安装nodejs,使用gitpage需要git,至于如何安装git,在原来的csdn博客上有,点击这里 http://blog.csdn.net/huangyuan_xuan/article/details/49125597.之后需要在自己的github上创建一个仓库,名称结构如下:username.github.io,例如我的github主页是https://github.com/huangyuanlove,那么我的gitpage就是huangyuanlove.github.io.到这里,默认大家的gitpage和git已经配置好了,包括sshkey之类的东西. 我安装node是用nvm(node version manager)安装的,然后使用node中的npm(node package manager)安装hexo.windows下安装请转这里 https://github.com/coreybutler/nvm-windows首先安装nvm: wget -qO- https://raw.github.com/creationix/nvm/master/install.sh | sh 安装时间长短视网速而定,我安装了大概十多分钟,然后重启一下终端.然后使用 nvm ls-remote查看一下有哪些本版可以安装,我当时安装的最新版是6.6.0,现在不知道是哪一版,如下找一个合适的版本使用如下命令安装nvm install version,例如 nvm install 6.6.0,安装时间还是视网速而定,我也忘了装了多长时间了.安装完成之后是这样的之后npm install -g hexo安装hexo,-g参数是全局安装安装完成之后使用hexo -v查看hexo的版本号到此hexo安装完成,接下来就是初始化,进行配置了.下一篇再说吧,睡觉了. 以上.","tags":[{"name":"blog","slug":"blog","permalink":"http://www.huangyuanlove.com/tags/blog/"},{"name":"gitpage","slug":"gitpage","permalink":"http://www.huangyuanlove.com/tags/gitpage/"},{"name":"hexo","slug":"hexo","permalink":"http://www.huangyuanlove.com/tags/hexo/"}]},{"title":"如何获取csdn中个人所有文章标题及链接","date":"2016-10-19T14:32:42.000Z","path":"2016/10/19/如何获取csdn中个人所有文章标题及链接/","text":"小伙伴问如何把自己csdn上的文章标题和超链接都扒下来,问我是不是一个个点开之后抄过去的…当然不是,做为一个爱(sha)好(dou)广(dong)泛(dian)的程序员,怎么会用这么麻烦的方法.本来打算写java模拟登录之后获取网页源码,然后再用jsoup去解析,得到自己需要的数据.原来就这么干过,好像是写学校的绩点计算器来着吧,就是输入帐号密码就能查到自己的成绩和绩点的那种.翻出来代码看了看太麻烦了,想到自己最近在看python,就想着用python来解决,但是问题又来了,python不熟啊,就算写出来了也得看网页源码,找到规律才行,讲道理的说挺烦这东西的.最后,还是用js来解决,毕竟这种事也干过,也不是多麻烦.登录自己的帐号,找到文章列表,打开控制台窗口,忘了说一下自己的环境了ubuntu,chrom,找到文章标题和超链接的部分,如下图:发现所有的文章标题和超链接结构如下:12345 &lt;span class=\"link_title\"&gt; &lt;a href=\"/huangyuan_xuan/article/details/51935666\"&gt; 初步编写IDEA\\AndroidStudio翻译插件 &lt;/a&gt;&lt;/span&gt; 另外,界面中还引入了jQuery这个三方库,这就更简单了:找到开发者工具的控制台(console),写入下面两行代码12345var aTags = $(\".link_title &gt; a\")for(var i = 0;i&lt;50;i++)&#123; console.log(\"[\" + aTags[i].text.trim() + \"](\" + aTags[i].href +\") \"+ aTags[i].href) +\"&lt;br/&gt;\" &#125; ok,执行结果如下在控制台写的代码第一行是使用jQuery库找到所有文章的超链接集合,第二行是按照markdown超链接的语法打印出来文章标题和超链接,至于循环中的50这个数字,一页最多只有50篇文章,我偷懒了,建议使用aTags.length 以上","tags":[{"name":"csdn","slug":"csdn","permalink":"http://www.huangyuanlove.com/tags/csdn/"}]},{"title":"原CSDN博客","date":"2016-10-16T14:39:41.000Z","path":"2016/10/16/原CSDN博客/","text":"不打算在csdn上面写博客了,转到gitpage上面,自己用hexo搭建了博客系统.现在把原csdn的博客链接抄在下面 使用openfire搭建IM聊天系统(一) http://blog.csdn.net/huangyuan_xuan/article/details/52549416 浅谈使用单元素的枚举类型实现单例模式 http://blog.csdn.net/huangyuan_xuan/article/details/52193006 初步编写IDEA\\AndroidStudio翻译插件 http://blog.csdn.net/huangyuan_xuan/article/details/51935666 多线程 的理解（一） http://blog.csdn.net/huangyuan_xuan/article/details/50881452 运行时数据区域 http://blog.csdn.net/huangyuan_xuan/article/details/50570461 虚拟机字节码执行引擎 http://blog.csdn.net/huangyuan_xuan/article/details/50569443 虚拟机类加载机制 http://blog.csdn.net/huangyuan_xuan/article/details/50550725 垃圾收集器与内存分配策略 http://blog.csdn.net/huangyuan_xuan/article/details/50513881 JDK的一些命令行工具 http://blog.csdn.net/huangyuan_xuan/article/details/50513861 MongoDB基础 http://blog.csdn.net/huangyuan_xuan/article/details/50155345 tomcat图形化界面管理及数据源配置 http://blog.csdn.net/huangyuan_xuan/article/details/49859151 android 四大图片缓存原理、特性对比 http://blog.csdn.net/huangyuan_xuan/article/details/49362701 github分支管理 http://blog.csdn.net/huangyuan_xuan/article/details/49356523 github 远程仓库 http://blog.csdn.net/huangyuan_xuan/article/details/49356505 github建立本地与远程仓库的连接 http://blog.csdn.net/huangyuan_xuan/article/details/49336403 Git 本地版本控制 http://blog.csdn.net/huangyuan_xuan/article/details/49162309 安装github http://blog.csdn.net/huangyuan_xuan/article/details/49125597 ubuntu 14.04 apt-get install 不能自动补全解决办法 http://blog.csdn.net/huangyuan_xuan/article/details/48915299 String的一点小东西 http://blog.csdn.net/huangyuan_xuan/article/details/48116365 wireshark error: There are no interfaces on which a capture can be done. http://blog.csdn.net/huangyuan_xuan/article/details/46632395 windows下使用cmd（命令行）发送邮件 http://blog.csdn.net/huangyuan_xuan/article/details/46564319 Notepad++ 搭建java编译环境 http://blog.csdn.net/huangyuan_xuan/article/details/45936413 JVM虚拟机 http://blog.csdn.net/huangyuan_xuan/article/details/44537233 servlet向浏览器输出验证码图片 http://blog.csdn.net/huangyuan_xuan/article/details/43817631 ubuntu14.04开热点共享网络 http://blog.csdn.net/huangyuan_xuan/article/details/43759585 UNIX/linux的find命令细节 http://blog.csdn.net/huangyuan_xuan/article/details/43739353 编写shell时，提示let：not found http://blog.csdn.net/huangyuan_xuan/article/details/43490373 cmd命令大全 http://blog.csdn.net/huangyuan_xuan/article/details/42804537 华为 ap ac设备配置命令 http://blog.csdn.net/huangyuan_xuan/article/details/41647447 更改SQLserver的登录方式 http://blog.csdn.net/huangyuan_xuan/article/details/41085629 汇编FLAG寄存器简介 http://blog.csdn.net/huangyuan_xuan/article/details/40949147 汇编指令——转移指令 http://blog.csdn.net/huangyuan_xuan/article/details/40949119 汇编指令 http://blog.csdn.net/huangyuan_xuan/article/details/40949109 汇编寻址方式 http://blog.csdn.net/huangyuan_xuan/article/details/40949087 一段汇编小程序及说明——将数据，代码，栈放入不同的段 http://blog.csdn.net/huangyuan_xuan/article/details/40949075 一段简单汇编语言程序及说明 http://blog.csdn.net/huangyuan_xuan/article/details/40949069 8086寄存器 http://blog.csdn.net/huangyuan_xuan/article/details/40949063 oracle创建实例化数据库或者连接别的远程主机数据库提示“无监听程序”的解决办法 http://blog.csdn.net/huangyuan_xuan/article/details/40857207 安装tomcat提示Faild to install Tomcat7 service 解决办法 http://blog.csdn.net/huangyuan_xuan/article/details/40821859 mysql事物处理和管理配置 http://blog.csdn.net/huangyuan_xuan/article/details/40821521 mysql 连接查询 http://blog.csdn.net/huangyuan_xuan/article/details/40783341 MySQL常用命令 http://blog.csdn.net/huangyuan_xuan/article/details/40783331 ubuntu下MySQL键值不支持中文解决办法 http://blog.csdn.net/huangyuan_xuan/article/details/40783317 Myeclipse新建webservice客户端 http://blog.csdn.net/huangyuan_xuan/article/details/39992799 MyEclips新建webservice http://blog.csdn.net/huangyuan_xuan/article/details/39992723 intellij IDEA更换主题为Darcula后中文项目名称变口（方框）的解决办法 http://blog.csdn.net/huangyuan_xuan/article/details/39896009 java模拟登录校内成绩查询网站，将获得的HTML代码用jsoup解析 http://blog.csdn.net/huangyuan_xuan/article/details/39723251 Ubuntu14.04 LTS更新源 http://blog.csdn.net/huangyuan_xuan/article/details/39119797 ubuntu14.04开机自动挂载windows磁盘的配置方法 http://blog.csdn.net/huangyuan_xuan/article/details/39118723 java实现MD5和sha1加密 http://blog.csdn.net/huangyuan_xuan/article/details/39081435 22 PPP协议 http://blog.csdn.net/huangyuan_xuan/article/details/38427607 21 串行接口封装 http://blog.csdn.net/huangyuan_xuan/article/details/38427547 20 internet connection http://blog.csdn.net/huangyuan_xuan/article/details/38427527 19 广域网 WAN http://blog.csdn.net/huangyuan_xuan/article/details/38423675 java的JDK的安装配置图文详解 http://blog.csdn.net/huangyuan_xuan/article/details/38405103 18 ACL访问控制列表（access control list） http://blog.csdn.net/huangyuan_xuan/article/details/38387045 17 NAT转换 http://blog.csdn.net/huangyuan_xuan/article/details/38342675 16 DHCP http://blog.csdn.net/huangyuan_xuan/article/details/38278825 Java常见错误列表 http://blog.csdn.net/huangyuan_xuan/article/details/37957229 LXLE Linux取代Windows XP的11个大招 http://blog.csdn.net/huangyuan_xuan/article/details/37937957 jQuery语法简介 http://blog.csdn.net/huangyuan_xuan/article/details/37738127 cookie简介 http://blog.csdn.net/huangyuan_xuan/article/details/37728211 DOM 简介 http://blog.csdn.net/huangyuan_xuan/article/details/37699891 vim 命令 http://blog.csdn.net/huangyuan_xuan/article/details/28880287 我们大神都这样——提问的智慧 http://blog.csdn.net/huangyuan_xuan/article/details/28276437 初学C语言的人看不懂的关机代码 http://blog.csdn.net/huangyuan_xuan/article/details/27972015 ubuntu连接路由器无线网络，却不能上网 http://blog.csdn.net/huangyuan_xuan/article/details/27792089 sublime-text2的中英文对照表（附带个人的配置习惯） http://blog.csdn.net/huangyuan_xuan/article/details/26969041 电脑蓝屏代码大全 http://blog.csdn.net/huangyuan_xuan/article/details/26246709 VC6.0 快捷键整理 http://blog.csdn.net/huangyuan_xuan/article/details/26245513 玩游戏无法全屏 http://blog.csdn.net/huangyuan_xuan/article/details/26245135 15 Ospf http://blog.csdn.net/huangyuan_xuan/article/details/26244991 14 EIGRP 配置 http://blog.csdn.net/huangyuan_xuan/article/details/26244541 13 ERGIP http://blog.csdn.net/huangyuan_xuan/article/details/26244439 12 rip-2 配置命令 http://blog.csdn.net/huangyuan_xuan/article/details/26244201 11 rip -1 http://blog.csdn.net/huangyuan_xuan/article/details/26244031 10动态路由 http://blog.csdn.net/huangyuan_xuan/article/details/26243735 9静态路由 http://blog.csdn.net/huangyuan_xuan/article/details/26243487 8网络拓扑结构 http://blog.csdn.net/huangyuan_xuan/article/details/26243293 7VLSM子网划分 http://blog.csdn.net/huangyuan_xuan/article/details/26243041 6常用网络相关命令 http://blog.csdn.net/huangyuan_xuan/article/details/26242799 5数据包发送流程 http://blog.csdn.net/huangyuan_xuan/article/details/26242589 网线 http://blog.csdn.net/huangyuan_xuan/article/details/26242183 osi七层网络模型4 http://blog.csdn.net/huangyuan_xuan/article/details/26242101 osi七层网络模型3 http://blog.csdn.net/huangyuan_xuan/article/details/26242015 osi七层网络模型2 http://blog.csdn.net/huangyuan_xuan/article/details/26241831 OSI七层网络模型1 http://blog.csdn.net/huangyuan_xuan/article/details/26241631 sublime-text2 编译java出错 Decode error - output not utf-8的解决办法 http://blog.csdn.net/huangyuan_xuan/article/details/26164349 安装虚拟机报错解决办法 TheVMware Authorization Service is not running http://blog.csdn.net/huangyuan_xuan/article/details/26162201 我的vim配置 http://blog.csdn.net/huangyuan_xuan/article/details/26162083 sublime text 2 搭建java运行环境 http://blog.csdn.net/huangyuan_xuan/article/details/26161983 ubuntu的一点命令 http://blog.csdn.net/huangyuan_xuan/article/details/26160973 以后主要就在gitpage上写博客了. 以上","tags":[{"name":"csdn","slug":"csdn","permalink":"http://www.huangyuanlove.com/tags/csdn/"}]},{"title":"2016年国庆-在深圳","date":"2016-10-08T04:42:33.000Z","path":"2016/10/08/2016国庆/","text":"国庆之前,辞了工作,跑到深圳找妹子玩了几天.妹子在哈工大深圳校区读研究生,去了之后也没有出去逛,吃饭,图书馆,写作业,折腾hexo写博客.也就在校园里逛了一下,拍了几张照片.在深圳市南山区的大学城里面,好像是有清华北大哈工大三所研究生院校组成的,据说哈工大深研院开始招本科生了.南门 ,没去其他的门,就从这边进去的,别问为啥,近. 哈工大深研院的标志?不知道是不是标志性建筑 图书馆,吐槽一下,图书馆的书好少.电梯的海报上面说是有电影放映,但是我们沉迷于学习无法自拔,理所当然的错过了. 图书馆门口的植物标本,我也不知道是啥,装作看懂的样子 食堂,食堂的饭菜还是不错的,听说非学校人员也能在里面办卡,只是比学生买饭要贵40%.表示理解. 北大汇丰商学院,就在图书馆旁边小树林里面有蛇,晚上去吃饭的时候路过的小树林,里面真的有蛇,亲眼所见,大概有食指粗细,一尺来长,黑灰色.可惜没拍到.清华大学深研院,不知道是不是这么叫的,吃完晚饭去瞻仰了一下 本打算去蹭课来着,但是看着妹子的作业就不想去了,我觉得我应该听不大懂. 就这些,待了貌似有四五天的样子,然后就滚回北京找工作了. 以上.","tags":[{"name":"随笔","slug":"随笔","permalink":"http://www.huangyuanlove.com/tags/随笔/"}]}]