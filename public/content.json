[{"title":"LaTeX笔记(一)","date":"2018-01-18T13:21:41.000Z","path":"2018/01/18/LaTeX笔记-一/","text":"如果学习不是为了装逼，那一切都将毫无意义。没错，我又想学LaTeX了，作为世界上最好的排版系统(没有之一)，我也只是在写简历的时候用过(装上编译器，改模板而已)，没有怎么了解过。最近妹子有提到过说些毕业论文的时候可能要用，这就需要系统的学习一下了。 准备阶段本着实用至上的原则，LaTeX的历史以及光辉事迹就不在提了，想看的自己去搜 TexLive2017套装：下载地址http://mirrors.tuna.tsinghua.edu.cn/CTAN/systems/texlive/Images/texlive2017-20170524.iso 这个是清华镜像站点。http://mirror.ctan.org/systems/texlive/Images/texlive2017.iso 这个是官方的镜像下载地址。不推荐使用CTex TexWorks：Tex文件编辑器，你也可以使用其他编辑器+插件：比如 VisualStudioCode，Sublime，Notepad++等。 JabRef：下载地址 https://www.fosshub.com/JabRef.html 大部分用在写论文的引用文献上，只有使用LaTeX撰写科技论文的研究人员才能完全领略到JabRef的妙不可言。 学习资料：LaTeX实在太庞大了，加上各种package，网上各种博客资料不是很全面，只照顾到一部分，推荐刘海洋的LaTeX入门。 建议：多练习，就像学编程一样，把书上的例子都自己敲一遍。 安装软件将TexLive2017套装加载到光驱， Windows 用户双击 install-tl-advanced.bat； *nix 用户执行 install-tl。然后按照提示来安装就好了，最后将texlive\\2017\\bin\\win32加入环境变量，*nix用户自己找执行文件所在的路径加到环境变量里面。其他的东西可以参考这个网站 http://www.latexstudio.net/archives/10208 Hello World老规矩，先跑个Hello World。 打开TexWork,在编辑区输入以下代码：123456789\\documentclass&#123;article&#125;\\begin&#123;document&#125;Hello World!\\LaTeX\\end&#123;document&#125; 然后保存一下文件，注意一定要使用UTF-8编码(默认)，Tex文件的后缀名为.tex，编译过程会多出好多临时文件。 在下图红框处(界面左上角)选择pafLaTeX,然后点击绿色按钮进行编译，编译过程中绿色按钮会变成红叉，编译成功后又变成绿色按钮。你会在弹出的窗口看到”Hello World LaTeX”，并且在tex文件同级的文件夹下看到生成的pdf文件。如果没有编译成功，可以尝试选择不同的编译类型，也可以搜索控制台报错信息来解决。 如果你觉得编辑窗口的字体看着不舒服，可以在编辑–&gt;首选项–&gt;编辑器或者格式–&gt;字体里面调整。 多说一句，TexWorks支持代码补全 说明\\documentclass[UTF-8]{article} 声明文档类型是一篇文章。\\begin{document} 和 \\end{document} 标识出正文的范围\\LaTeX 看结果就知道是表示结果中高低不平的LaTeX但是，当你把内容替换为汉字的时候，发现汉字并不能在pdf文件中展示，这是因为LaTeX原本是面向西文写作的，默认没有加载中文字体。我们可以通过替换文档类型来显示中文，将 \\documentclass{article} 替换为 \\documentclass[UTF-8]{ctexart} 就可以显示中文了。 下一个目标如下图，接下来我们来慢慢写出来图片所示的样式。 以上。","tags":[{"name":"LaTex","slug":"LaTex","permalink":"http://www.huangyuanlove.com/tags/LaTex/"}]},{"title":"Android布局文件中的xmlns:tools","date":"2018-01-04T06:12:34.000Z","path":"2018/01/04/Android布局文件中的xmlns-tools/","text":"在使用AndroidStudio创建布局文件的时候，跟布局下总是有如下代码：123&lt;RootTag xmlns:android=\"http://schemas.android.com/apk/res/android\" xmlns:tools=\"http://schemas.android.com/tools\" tools:context=\"***.***Activity\" &gt; 于是在官网查了一下这俩货是干嘛用的，下面是自己的翻译+实践xmlns的全称是xmlnamespace,和c++中namespace差不多，都是为了解决命名上的冲突问题。在Android布局文件中，常见的xmlns大概有三个（你可以随意命名，把tools改成bug也可以，只要对应使用tools的地方都改成bug，说白了，它只是个变量而已）。123xmlns:android=\"http://schemas.android.com/apk/res/android\"xmlns:tools=\"http://schemas.android.com/tools\"xmlns:app=\"http://schemas.android.com/apk/res-auto\" android用于Android系统定义的一些属性 app用于我们自定义的一些属性 tools给IDE或者预览界面用的，当打包编译时并不会包含在apk中。 tools可以干什么先看官网介绍 https://developer.android.com/studio/write/tool-attributes.html Android Studio supports a variety of XML attributes in the tools namespace that enable design-time features (such as which layout to show in a fragment) or compile-time behaviors (such as which shrinking mode to apply to your XML resources). When you build your app, the build tools remove these attributes so there is no effect on your APK size or runtime behavior. 大致意思就是说使用tools后面的属性不会再编译时存在，只存在于设计时的预览，不会影响apk的体积， Error handling attributes影响Lint提示的属性主要有下面三种： tools:ignoreIntended for: Any elementUsed by: Lint tools:targetApiIntended for: Any elementUsed by: Lint tools:localeIntended for: resourcesUsed by: Lint, Android Studio editor ignore属性是告诉Lint忽略xml中的某些警告，比如我们在ImageView或者ImageButton中没有写contentDescription属性，Lint会有警告：Missing contentDescription attribute on image,原因是这个属性是提供无障碍阅读的，没有这个属性的话Screen Reader无法正常工作，但是有些特定分类的软件是不考虑这些东西的。虽然这种警告无所谓，但是对于要求代码中不能有warning的公司来说，这是不可取的，我们可以用ignore属性来忽略这个警告(如果你说你改了Lint的警告级别，当我没说)：12345678&lt;ImageViewandroid:layout_width=\"wrap_content\"android:layout_height=\"wrap_content\"android:layout_marginStart=\"@dimen/margin_main\"android:layout_marginTop=\"@dimen/margin_main\"android:scaleType=\"center\"android:src=\"@drawable/divider\"tools:ignore=\"contentDescription\" /&gt; targetApi和代码中的注解@RequiresApi(api = Build.VERSION_CODES.JELLY_BEAN_MR2)差不多。假设配置文件中的最小sdkLevel为11，而布局文件中使用了21的控件比如GridLayout,Lint会有警告，为了消除这个警告，可以这么写：123&lt;GridLayout xmlns:android=\"http://schemas.android.com/apk/res/android\" xmlns:tools=\"http://schemas.android.com/tools\" tools:targetApi=\"14\" &gt; locale是告诉Lint和AndroidStudio editor默认的是什么语言，如果不指定的话，默认是英语。可以把这个属性添加到values/strings.xml中：12&lt;resources xmlns:tools=\"http://schemas.android.com/tools\" tools:locale=\"es\"/&gt; Design-time view attributes(设计时试图属性)tools: instead of androidIntended for: ViewUsed by: Android Studio layout editor 我们有一个TextView，需要显示从网络获取到的文件，控件大小是wrap_content,但是TextView中没有文字的话在预览界面中是看不到的，大部分同学可能会使用android:text=XXXX这个属性，调整好布局之后再把文字删除。一两个控件还好说，控件多了指不定哪个控件就忘记删除文本了，我们可以使用tools这个东西：12345678&lt;TextView android:id=\"@+id/unlock_bike\" android:layout_width=\"wrap_content\" android:layout_height=\"wrap_content\" android:background=\"#12345678\" android:paddingBottom=\"10dp\" android:paddingTop=\"10dp\" tools:text=\"测试用例\" /&gt; 这时我们在IDE预览界面是可以看到文字的，打包成apk运行在手机上时是看不到的。总之，tools可以告诉Android Studio哪些属性在运行的时候是被忽略的，只在设计布局的时候有效。基本上原生控件的属性都可以这么使用。 tools:contextIntended for: Any root ViewUsed by: Lint, Android Studio layout editor这个属性告诉IDE当前布局和哪个activity相关联，在预览界面使用关联Activity的主题展示。1234&lt;android.support.constraint.ConstraintLayout xmlns:android=\"http://schemas.android.com/apk/res/android\" xmlns:tools=\"http://schemas.android.com/tools\" tools:context=\".MainActivity\" &gt; tools:itemCountIntended for: RecyclerViewUsed by: Android Studio layout editor这个属性告诉编辑器在预览窗口展示多少个列表项12345&lt;android.support.v7.widget.RecyclerView android:id=\"@+id/recyclerView\" android:layout_width=\"match_parent\" android:layout_height=\"match_parent\" tools:itemCount=\"3\"/&gt; tools:layoutIntended for: fragmentUsed by: Android Studio layout editor这个属性告诉编辑器fragment中显示哪个布局文件12&lt;fragment android:name=\"com.example.master.ItemListFragment\" tools:layout=\"@layout/list_content\" /&gt; tools:listitem / tools:listheader / tools:listfooterIntended for: AdapterView (and subclasses like ListView)Used by: Android Studio layout editor看属性名字就能猜出来了，预览界面显示列表的头部，底部和列表项布局12345678&lt;ListView xmlns:android=\"http://schemas.android.com/apk/res/android\" xmlns:tools=\"http://schemas.android.com/tools\" android:id=\"@android:id/list\" android:layout_width=\"match_parent\" android:layout_height=\"match_parent\" tools:listitem=\"@layout/sample_list_item\" tools:listheader=\"@layout/sample_list_header\" tools:listfooter=\"@layout/sample_list_footer\" /&gt; tools:showInIntended for: Any root View in a layout that’s referred to by an includeUsed by: Android Studio layout editor此属性可以通过指向使用此布局包含的布局，因此您可以预览(和编辑)这个文件，因为它嵌入在其父布局时出现123456&lt;TextView xmlns:android=\"http://schemas.android.com/apk/res/android\" xmlns:tools=\"http://schemas.android.com/tools\" android:text=\"@string/hello_world\" android:layout_width=\"wrap_content\" android:layout_height=\"wrap_content\" tools:showIn=\"@layout/activity_main\" /&gt; tools:menuIntended for: Any root ViewUsed by: Android Studio layout editor此属性指定菜单应该显示在应用程序栏的布局预览。该值可以是一个或多个菜单id，由逗号分隔123456&lt;LinearLayout xmlns:android=\"http://schemas.android.com/apk/res/android\" xmlns:tools=\"http://schemas.android.com/tools\" android:orientation=\"vertical\" android:layout_width=\"match_parent\" android:layout_height=\"match_parent\" tools:menu=\"menu1,menu2\" /&gt; tools:minValue / tools:maxValueIntended for: NumberPickerUsed by: Android Studio layout editor设置NumberPicker的最大值和最小值1234567&lt;NumberPicker xmlns:android=\"http://schemas.android.com/apk/res/android\" xmlns:tools=\"http://schemas.android.com/tools\" android:id=\"@+id/numberPicker\" android:layout_width=\"match_parent\" android:layout_height=\"wrap_content\" tools:minValue=\"0\" tools:maxValue=\"10\" /&gt; tools:openDrawerIntended for: DrawerLayoutUsed by: Android Studio layout editor设置DrawerLayout在预览窗口的打开位置|Constant|Value|Description||:————-:|:————-:|:—–:||end|800005|Push object to the end of its container, not changing its size. ||left|3|Push object to the left of its container, not changing its size.||right|5|Push object to the right of its container, not changing its size.||start|800003|Push object to the beginning of its container, not changing its size.|1234567&lt;android.support.v4.widget.DrawerLayout xmlns:android=\"http://schemas.android.com/apk/res/android\" xmlns:tools=\"http://schemas.android.com/tools\" android:id=\"@+id/drawer_layout\" android:layout_width=\"match_parent\" android:layout_height=\"match_parent\" tools:openDrawer=\"start\" /&gt; 下面的不想翻译了，链接在下面https://developer.android.com/studio/write/tool-attributes.html#resource_shrinking_attributes自己撸吧 以上","tags":[{"name":"android","slug":"android","permalink":"http://www.huangyuanlove.com/tags/android/"}]},{"title":"写在2018元旦之前:2017的总结","date":"2017-12-30T13:13:55.000Z","path":"2017/12/30/写在2018元旦之前-2017的总结/","text":"2017年已经过去了，现在已经是2018年1月1号了，写写这一年的收获总结和2018的计划吧。一个字总结了一下2018年：穷。我也不知道钱花到哪里去了【无奈、摊手】。当然这是开玩笑式的总结，但也是最接近事实的了。刚刚翻了翻2016年年末写了总结个2017的计划，我先捂会脸。 先看看完成了哪些吧： python达到初级水平:这个勉勉强强算是达到了吧。 J2EE学习ssm和nginx:这个就很惭愧了，一直没看，不是没时间，就是平时大概了解了一下，根本就没有系统的学习过。 Java和Android：这个一直没停下过，毕竟是饭碗，在别人看来差不多已经是高级工程师了，可我觉得我刚刚到中级水平吧(标准不一样嘛)。 Linux：这个也没怎么深入，能在linux平台下做开发、了解常见配置，除了问题能找到解决方案就好。公司开发坏境是windows,就算我想用linux，这个也不大好，只能平时自己玩玩。 想想自己2017年都学到了啥，其实我也不知道自己又学到了啥，有些东西都是基础性、底层的东西，表面上看起来没什么提高，实际上现在我也没觉得有啥用户，或许是因为自己还没有到那个层次吧。 表面上学到的东西如下： 记录了一下在使用高德地图踩的坑(写到博客上了)。 大致看了一下tcp协议，就当是复习了，当时学ccna的时候也没怎么在意。 大致看了一遍《Android开发艺术探索》，可惜IPC还是没学会。 大致看了一下python编程，了解了一下flask和Django。 又大致看了一遍《深入理解JVM虚拟机》，感觉不出来有什么提高，只是聊天吹水的时候又多了点东西。 大致看了一下C++，没深入学习，坚持不下去了。 动手搭建了一下elk，并没有什么卵用，毕竟公司有专门的运维。 动手搭建了一下Jenkins，并没有什么卵用，毕竟公司有专门的运维。 动手搭建了一下git服务，并没有什么卵用，毕竟公司有专门的运维。 写了两个IDEA的插件，写完之后才发现有人写过了，而且还是已经发布了的。 用不同的方式方法、框架、语言把《煎蛋》写了好几遍。 大致学习了一下kotlin。 其他的就是读了几本书、认识了几个朋友。 遗憾的事 和妹子异地，没有多陪陪妹子。 没有锻炼，身体素质差的不要不要的，手无缚鸡之力。 自己一直念念不忘的热修复没有动手实践过。 自己一直念念不忘的微信小程序也没有去试试。 自己一直念念不忘的日语也放弃了。 脾气似乎暴躁了许多，竟然喜欢《死亡笔记》中所描述的世界。 我可能是公司里在技术上最能作(zuo,一声)的人了，没有之一： 一开始做运营端app，嫌写findViewById麻烦，说服同事用ButterKnife注解。 后来需要做内部服务端app，觉得用ButterKnife也挺麻烦的，还得写变量(给变量去名字太蛋疼了，界面复杂的话一个界面好几十个控件变量)，上databinding吧，花一周时间把原来的注解全部干掉，换成databinding 后来想改网络框架来着，但是一直没时间，开发需求一版接一版，VersionCode一年内已经到40了，只能作罢。 现在一直想上热修复来着，但是还没弄，后端还没弄好，机制还不完善，不过我觉得迟早得上，毕竟有啥技术改动都是内部服务端app先上、先用、趟雷(毕竟内部人员使用，好说话),然后运营端app再上. 2018计划 有时间多陪陪妹子。 坚持锻炼。 至少读3本书，要有总结和读后感的那种。 有时间的话，至少参与一次开源翻译计划(Apche-CN)\\ 人工智能和机器学习挺火的，妹子研究生也是这个方向，学学这一块的东西，至少不要拖妹子后腿吧。 Java和Android方向继续努力，撸源码，多学习。 坚持写博客，不能偷懒了。 修身养性，别这么大脾气了，一点就爆(抱个被子，泡点枸杞挺不错的)。 以上","tags":[{"name":"乱七八糟","slug":"乱七八糟","permalink":"http://www.huangyuanlove.com/tags/乱七八糟/"}]},{"title":"Android中使用WebSocket-2","date":"2017-12-26T08:37:37.000Z","path":"2017/12/26/Android中使用WebSocket-2/","text":"上一篇提到在Android中使用WebSocket和服务端进行通信。是直接在Activity里面进行操作的这样会保持一个长连接，一个应用里面没必要也不应该保持多个长连接，所以我们可以把WebSocket客户端挪到Service里面，使用广播和Activity进行通信。 APP端：继承BroadcastReceiver，重写public void onReceive(Context context, Intent intent)方法，在该方法中进行业务处理。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566public class MainActivity extends AppCompatActivity implements View.OnClickListener &#123; private TextView showMessage; private EditText editText; private StringBuilder sb = new StringBuilder(); private WebSocketBroadcastReceiver webSocketBroadcastReceiver; @Override protected void onCreate(Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); setContentView(R.layout.activity_main); Intent intent = new Intent(this, WebSocketService.class); startService(intent); showMessage = findViewById(R.id.show_message); editText = findViewById(R.id.edit_text); findViewById(R.id.send).setOnClickListener(this); webSocketBroadcastReceiver = new WebSocketBroadcastReceiver(); IntentFilter intentFilter = new IntentFilter(\"web_socket\"); registerReceiver(webSocketBroadcastReceiver, intentFilter); &#125; @Override public void onClick(View v) &#123; switch (v.getId()) &#123; case R.id.send: sb.append(\"客户端发送消息：\"); sb.append(new Date().toLocaleString()); sb.append(\"\\n\"); sb.append(editText.getText().toString().trim()); sb.append(\"\\n\"); showMessage.setText(sb.toString()); Intent intent = new Intent(this, WebSocketService.class); intent.putExtra(\"message\", editText.getText().toString().trim()); startService(intent); editText.setText(\"\"); break; default: break; &#125; &#125; class WebSocketBroadcastReceiver extends BroadcastReceiver &#123; @Override public void onReceive(Context context, Intent intent) &#123; String message = intent.getStringExtra(\"message\"); sb.append(\"服务端返回消息：\"); sb.append(new Date().toLocaleString()); sb.append(\"\\n\"); sb.append(message); sb.append(\"\\n\"); showMessage.setText(sb.toString()); &#125;&#125; @Override protected void onDestroy() &#123; Intent intent = new Intent(this, WebSocketService.class); stopService(intent); unregisterReceiver(webSocketBroadcastReceiver); super.onDestroy(); &#125;&#125; Service继承Service,在onCreate()方法里面创建WebSocketClient并和服务端进行连接。在AndroidManifest.xml中注册服务。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667public class WebSocketService extends Service &#123; private IoTWebSocketClient ioTWebSocketClient; private Intent broadcastIntent; @Override public IBinder onBind(Intent intent) &#123; return null; &#125; @Override public void onCreate() &#123; super.onCreate(); broadcastIntent = new Intent(); broadcastIntent.setAction(\"web_socket\"); ioTWebSocketClient = new IoTWebSocketClient(URI.create(\"ws://192.168.1.64:8887\")); ioTWebSocketClient.connect(); &#125; @Override public int onStartCommand(Intent intent, int flags, int startId) &#123; String message = intent.getStringExtra(\"message\"); if(ioTWebSocketClient.isClosing() || ioTWebSocketClient.isClosed())&#123; stopSelf(); return super.onStartCommand(intent, flags, startId); &#125; try &#123; ioTWebSocketClient.send(message); &#125;catch (Exception e)&#123; e.printStackTrace(); &#125; return super.onStartCommand(intent, flags, startId); &#125; @Override public void onDestroy() &#123; ioTWebSocketClient.close(); ioTWebSocketClient = null; super.onDestroy(); &#125; class IoTWebSocketClient extends WebSocketClient &#123; IoTWebSocketClient(URI serverUri) &#123; super(serverUri); &#125; @Override public void onOpen(ServerHandshake handshakedata) &#123; &#125; @Override public void onMessage(String message) &#123; broadcastIntent.putExtra(\"message\", message); WebSocketService.this.sendBroadcast(broadcastIntent); &#125; @Override public void onClose(int code, String reason, boolean remote) &#123; &#125; @Override public void onError(Exception ex) &#123; stopSelf(); &#125; &#125;&#125; 在onStartCommand()方法里面，对发送消息方法的调用进行异常捕获，是因为这时候可能服务端重启或者服务端还没有准备好，这是发送消息会抛出异常，可以根据自己的业务需求进行改进。 以上","tags":[{"name":"Andorid","slug":"Andorid","permalink":"http://www.huangyuanlove.com/tags/Andorid/"},{"name":"WebSocket","slug":"WebSocket","permalink":"http://www.huangyuanlove.com/tags/WebSocket/"}]},{"title":"Android中使用WebSocket","date":"2017-12-25T08:23:46.000Z","path":"2017/12/25/Android中使用WebSocket/","text":"背景：后端逻辑框架调整，将原来的推送和轮询方式改成了使用WebSocket通信。原来的请求方式是由app发起请求，appServer对请求进行分发，中转中继服务器将具体请求下发到对应的物联网服务器，物联网服务器将指令下发到指定的设备。整个流程涉及到很多层http请求，并且每个服务的回调接口还不一致，只能在app发情请求之后，接着去轮询服务器，服务器端去查询设备状态、是否对指令有响应。改版后涉及到对物联网的请求全部改成WebSocket,不在轮询，而是被动等待。后端使用的是Spring实现的WebSocket,app端使用的是https://github.com/TooTallNate/Java-WebSocket这个开源项目。 APP端实现 添加依赖compile &quot;org.java-websocket:Java-WebSocket:1.3.7&quot; 我们只需要关心三方库中WebSocketClient类就可以了，其他细节底层已经封装好了。 类中有四个方法需要重写： 12345678/**打开连接*/ public void onOpen(ServerHandshake handshakedata) /**服务端返回消息*/ public void onMessage(String message) /**关闭连接*/ public void onClose(int code, String reason, boolean remote) /**出现异常*/ public void onError(Exception ex) 一个简单的小测试，app端定义了一个发送按钮，和一个展示消息的文本 1234567891011121314151617181920212223242526272829303132333435363738394041&lt;?xml version=\"1.0\" encoding=\"utf-8\"?&gt;&lt;LinearLayout xmlns:android=\"http://schemas.android.com/apk/res/android\" xmlns:tools=\"http://schemas.android.com/tools\" android:layout_width=\"match_parent\" android:layout_height=\"match_parent\" android:orientation=\"vertical\" tools:context=\"com.huangyuanlove.testwebsocket.MainActivity\"&gt; &lt;ScrollView android:layout_width=\"match_parent\" android:layout_height=\"0dp\" android:layout_weight=\"1\"&gt; &lt;TextView android:id=\"@+id/show_message\" android:layout_width=\"wrap_content\" android:layout_height=\"wrap_content\" /&gt; &lt;/ScrollView&gt; &lt;LinearLayout android:layout_width=\"match_parent\" android:layout_height=\"wrap_content\" android:orientation=\"horizontal\"&gt; &lt;EditText android:id=\"@+id/edit_text\" android:layout_width=\"0dp\" android:layout_height=\"wrap_content\" android:layout_weight=\"1\" /&gt; &lt;TextView android:id=\"@+id/send\" android:layout_width=\"wrap_content\" android:layout_height=\"wrap_content\" android:background=\"@color/colorAccent\" android:padding=\"10dp\" android:text=\"发送\" android:textColor=\"@android:color/black\" /&gt; &lt;/LinearLayout&gt;&lt;/LinearLayout&gt; 在代码里面处理具体逻辑： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109import android.os.Bundle;import android.os.Handler;import android.os.Message;import android.support.design.widget.Snackbar;import android.support.v7.app.AppCompatActivity;import android.view.View;import android.widget.EditText;import android.widget.TextView;import org.java_websocket.client.WebSocketClient;import org.java_websocket.handshake.ServerHandshake;import java.net.URI;import java.util.Date;public class MainActivity extends AppCompatActivity implements View.OnClickListener &#123; private TextView showMessage; private EditText editText; private WebSocketClient webSocketClient; private StringBuilder sb = new StringBuilder(); private Handler handler = new Handler(new Handler.Callback() &#123; @Override public boolean handleMessage(Message msg) &#123; sb.append(\"服务器返回数据：\"); sb.append(msg.obj.toString()); sb.append(\"\\n\"); showMessage.setText(sb.toString()); return true; &#125; &#125;); @Override protected void onCreate(Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); setContentView(R.layout.activity_main); showMessage = findViewById(R.id.show_message); editText = findViewById(R.id.edit_text); findViewById(R.id.send).setOnClickListener(this); URI serverURI = URI.create(\"ws://192.168.1.199:8887\"); webSocketClient = new WebSocketClient(serverURI) &#123; @Override public void onOpen(ServerHandshake handshakedata) &#123; sb.append(\"onOpen at time：\"); sb.append(new Date()); sb.append(\"服务器状态：\"); sb.append(handshakedata.getHttpStatusMessage()); sb.append(\"\\n\"); showMessage.setText(sb.toString()); &#125; @Override public void onMessage(String message) &#123; Message handlerMessage = Message.obtain(); handlerMessage.obj = message; handler.sendMessage(handlerMessage); &#125; @Override public void onClose(int code, String reason, boolean remote) &#123; sb.append(\"onClose at time：\"); sb.append(new Date()); sb.append(\"\\n\"); sb.append(\"onClose info:\"); sb.append(code); sb.append(reason); sb.append(remote); sb.append(\"\\n\"); showMessage.setText(sb.toString()); &#125; @Override public void onError(Exception ex) &#123; sb.append(\"onError at time：\"); sb.append(new Date()); sb.append(\"\\n\"); sb.append(ex); sb.append(\"\\n\"); showMessage.setText(sb.toString()); &#125; &#125;; webSocketClient.connect(); &#125; @Override public void onClick(View v) &#123; switch (v.getId()) &#123; case R.id.send: if(webSocketClient.isClosed() || webSocketClient.isClosing())&#123; Snackbar.make(v,\"Client正在关闭\",Snackbar.LENGTH_SHORT).show(); webSocketClient.connect(); break; &#125; webSocketClient.send(editText.getText().toString().trim()); sb.append(\"客户端发送消息：\"); sb.append(new Date()); sb.append(\"\\n\"); sb.append(editText.getText().toString().trim()); sb.append(\"\\n\"); showMessage.setText(sb.toString()); editText.setText(\"\"); break; default: break; &#125; &#125;&#125; 服务端实现上面提到我们后端使用的Spring中的WebSocket实现，其实用什么实现服务端无所谓，只要遵循协议就可以。个人在本地做测试的时候用的还是这个开源项目。 服务端只需要关心WebSocketServer这个类就好，这个类里面有五个方法需要重写： 12345678910/**服务开启*/public void onStart() /**有客户端连接*/public void onOpen(WebSocket webSocket, ClientHandshake clientHandshake)/**服务端关闭*/public void onClose(WebSocket webSocket, int i, String s, boolean b)/**收到客户端的消息*/public void onMessage(WebSocket webSocket, String s)/**出现异常*/ public void onError(WebSocket webSocket, Exception e) 具体代码如下： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576package com.huangyuanlove;import org.java_websocket.WebSocket;import org.java_websocket.WebSocketImpl;import org.java_websocket.handshake.ClientHandshake;import org.java_websocket.server.WebSocketServer;import java.io.BufferedReader;import java.io.InputStreamReader;import java.net.InetSocketAddress;import java.net.UnknownHostException;public class TestWebSocket extends WebSocketServer &#123; public TestWebSocket(int port) throws UnknownHostException &#123; super(new InetSocketAddress(port)); &#125; public TestWebSocket(InetSocketAddress address) &#123; super(address); &#125; public static void main(String[] args) &#123; WebSocketImpl.DEBUG = true; try &#123; int port = 8887; // 843 flash policy port TestWebSocket s = new TestWebSocket(port); s.start(); System.out.println(\"ChatServer started on port: \" + s.getPort()); BufferedReader sysin = new BufferedReader(new InputStreamReader(System.in)); while (true) &#123; String in = sysin.readLine(); s.broadcast(in); if (in.equals(\"exit\")) &#123; s.stop(1000); break; &#125; &#125; &#125; catch (Exception ex) &#123; ex.printStackTrace(); &#125; &#125; @Override public void onOpen(WebSocket webSocket, ClientHandshake clientHandshake) &#123; broadcast(\"new connection: \" + clientHandshake.getResourceDescriptor()); System.out.println(webSocket.getRemoteSocketAddress().getAddress().getHostAddress() + \" entered the room!\"); &#125; @Override public void onClose(WebSocket webSocket, int i, String s, boolean b) &#123; broadcast(webSocket + \" onClose\"); System.out.println(webSocket + \" onClose\"); &#125; @Override public void onMessage(WebSocket webSocket, String s) &#123; broadcast(s); System.out.println(webSocket + \": \" + s); &#125; @Override public void onError(WebSocket webSocket, Exception e) &#123; e.printStackTrace(); if (webSocket != null) &#123; // some errors like port binding failed may not be assignable to a specific websocket &#125; &#125; @Override public void onStart() &#123; System.out.println(\"Server started!\"); &#125;&#125; 上面代码中onMessage方法中的broadcast方法是向所有连接到服务器的客户端发送消息(广播发送，其实就是一个小型的局域网聊天室)，如果只是谁发来的消息就回复给谁，可以调用webSocket.send()方法。是用的时候先开启服务端，然后开启客户端(app)，需要注意是的，在客户端中重写的方法都不是在主线程中，如果需要更新UI，请切换到UI线程。或者在客户端中使用Service,在Service中收到消息之后，广播给UI界面。 以上","tags":[{"name":"Andorid","slug":"Andorid","permalink":"http://www.huangyuanlove.com/tags/Andorid/"},{"name":"WebSocket","slug":"WebSocket","permalink":"http://www.huangyuanlove.com/tags/WebSocket/"}]},{"title":"《我的安卓爬坑之旅》-高德地图遇到的坑-3","date":"2017-12-19T06:49:49.000Z","path":"2017/12/19/《我的安卓爬坑之旅》-高德地图遇到的坑-3/","text":"这次是逆地理位置编码出现的坑，在提交工单后，官方回复是badcase，已经收录，后续着手优化。SDK版本号：com.amap.api:location:3.6.1、com.amap.api:map3d:4.1.3、com.amap.api:map3d-native:4.1.3、com.amap.api:search:5.5.0。过程如下：2017年12月5号接到用户反馈，定位位置准确，但是显示的中文具体位置不准确，误差大概在千米级别。当时就麻爪了，这可不是误差，这是错误。 首先排除网络以及信号问题：根据用户反馈，得知用户所在位置信号良好，周围不存在遮盖物，也不在地下室之类的信号差的地方，不存在定位偏差问题(app上显示的定位和手机位置一致)。网络状况良好，浏览器可以打开网页、app可以进行其他操作。先排除用户使用情况的原因是：接到过多次反馈，是因为用户没有看app提示，或者直接忽略掉提示导致的误报。 排除代码问题 在测试服上进行同样操作，得到的坐标值正确(手机拿到坐标值在app上显示，然后把坐标拿到高德坐标拾取系统进行定位，显示位置一致)，定位以及展示代码没问题。 拿到坐标值在客户端进行逆地理位置编码(RegeocodeQuery query = new RegeocodeQuery(new LatLonPoint(lat, lon), 200,GeocodeSearch.AMAP); geocoderSearch.getFromLocationAsyn(query);)，得到的地理位置正确，误差在所传参数以内，改变逆地理位置编码的经确定，改变定位位置(北京市内随机取点)，多次操作，定位及展示以及逆地理位置编码均正确。到这，就有点抓狂了，这TM什么问题，到底哪里出问题了。。 全国范围内取点，代码参数和生产环境保持一致，祈祷着或许是因为在新疆这种空旷、建筑物少的地方，误差可能会大些(好几公里没有建筑物，没有明显地标，总不能展示第几课白杨树下吧，23333)。抓到了偏远地区的坐标以及十分空旷地区的坐标，展示以及你地理位置编码均正确。 这时候也冷静下来了，出了问题不一定是自己代码问题吗，有可能是二方、三方代码的锅，只是习惯上养成了出了问题先找自己的原因，找不到再找其他的。找高德，提工单，详细描述问题： 具体情况这样：我把(119.564298,31.995402)这个坐标用客户端调用逆地理位置编码接口:RegeocodeQuery query = new RegeocodeQuery(new LatLonPoint(lat, lon), 200,GeocodeSearch.AMAP);geocoderSearch.getFromLocationAsyn(query);在回调函数public void onRegeocodeSearched(RegeocodeResult result, int rCode)中取得结果：result.getRegeocodeAddress().getFormatAddress() 是江苏省镇江市丹阳市云阳镇北环路6号。但实际上江苏省镇江市丹阳市云阳镇北环路6号这个地址与上述坐标点距离很远(这个是在高德坐标拾取器 http://lbs.amap.com/console/show/picker 上看到的)。 高德回复第二天高德给了回复： 您好，感谢反馈，目前这块的算法确实有一些问题，您的badcase我们已经收录，后续会针对这块做优化。给您造成不便敬请谅解。感谢您的致信，欢迎持续关注高德开放平台！ 以上","tags":[{"name":"Android爬坑之旅","slug":"Android爬坑之旅","permalink":"http://www.huangyuanlove.com/tags/Android爬坑之旅/"},{"name":"Android","slug":"Android","permalink":"http://www.huangyuanlove.com/tags/Android/"},{"name":"高德地图","slug":"高德地图","permalink":"http://www.huangyuanlove.com/tags/高德地图/"}]},{"title":"flask笔记一 快速入门","date":"2017-07-15T01:55:52.000Z","path":"2017/07/15/flask笔记一(快速入门)/","text":"学习python和flask中看过的资料和自己的实践总结Flask英文以下内容来自flask中文 环境安装Flask依赖两个外部库：Werkzeug和Jinja2。Werkzeug是一个WSGI工具集、Jinja2负责渲染模板。首先需要python2.6或者更高的版本，python3.X安装方式可能有所不一致。 virtualenvvirtualenv 为每个不同项目提供一份 Python 安装。它并没有真正安装多个 Python 副本，但是它确实提供了一种巧妙的方式来让各项目环境保持独立。sudo apt-get install python-virtualenvvirtualenv安装完成后，用IDE比如pycharm创建一个Flask的项目工程，并在其下创建一个venv文件夹12345$ mkdir myproject$ cd myproject$ virtualenv venvNew python executable in venv/bin/pythonInstalling distribute............done. 然后激活相应的环境$ . venv/bin/activate然后激活virtualenv中的Flask$ pip install Flask 项目配置在pycharm中，打开setting在Project Interpreter中选择当前工程文件下的virtualenv打开工程的Configuration在python interpreter中选择当前工程文件下的virtualenv 项目说明总述刚刚新建的工程看起来会是这样的123456789from flask import Flaskapp = Flask(__name__)@app.route('/')def hello_world(): return 'Hello World!'if __name__ == '__main__': app.run() 运行这段程序(文件名不要是 flask.py，这会和已有的文件冲突)，浏览器访问127.0.0.1:5000，然后就会看到熟悉的hello world.那么，这段代码做了什么？ 首先，我们导入了 Flask 类。这个类的实例将会是我们的 WSGI 应用程序。接下来，我们创建一个该类的实例，第一个参数是应用模块或者包的名称。 如果你使用单一的模块（如本例），你应该使用 name ，因为模块的名称将会因其作为单独应用启动还是作为模块导入而有不同（ 也即是 ‘main‘ 或实际的导入名）。这是必须的，这样 Flask 才知道到哪去找模板、静态文件等等。详情见 Flask 的文档。 然后，我们使用 route() 装饰器告诉 Flask 什么样的URL 能触发我们的函数。这个函数的名字也在生成 URL 时被特定的函数采用，这个函数返回我们想要显示在用户浏览器中的信息。 最后我们用 run() 函数来让应用运行在本地服务器上。 其中 if name == ‘main‘: 确保服务器只会在该脚本被 Python 解释器直接执行的时候才会运行，而不是作为模块导入的时候。欲关闭服务器，按 Ctrl+C。你会发现它只能从自己的计算机上访问，网络中其他任何地方都不能访问，我们可以修改run()方法使该服务公开可用app.run(host=&#39;0.0.0.0&#39;)这样会让操作系统监听所有的公网IP同样可以开启debug模式app.debug = True;app.run()或者app.run(debug=True) 路由如上面的代码所示，route()装饰其吧一个函数绑定到对应的URL上1234567@app.route('/')def index(): return 'Index Page'@app.route('/hello')def hello(): return 'Hello World' 不仅如此，还可以构造含有动态部分的URL，也可以在一个函数上附着多个规则 变量规则要给 URL 添加变量部分，你可以把这些特殊的字段标记为 ， 这个部分将会作为命名参数传递到你的函数。规则可以用 指定一个可选的转换器。如下所示 123456789@app.route('/user/&lt;username&gt;')def show_user_profile(username): # show the user profile for that user return 'User %s' % username@app.route('/post/&lt;int:post_id&gt;')def show_post(post_id): # show the post with the given id, the id is an integer return 'Post %d' % post_id HTTP方法HTTP有许多不同的访问URL方法。默认情况下，路由只回应GET请求，但是通过route()装饰器传递methods参数可以改变这个行为。 123456@app.route('/login', methods=['GET', 'POST'])def login(): if request.method == 'POST': do_the_login() else: show_the_login_form() 模板渲染像javaweb一样，不会直接用servlet直接输出html代码，Flask可以使用render_template()方法来渲染模板，Flask配备Jinja2模板引擎Jinja2中文，Jinja2英文123456from flask import render_template@app.route('/hello/')@app.route('/hello/&lt;name&gt;')def hello(name=None): return render_template('hello.html', name=name) Flask 会在 templates 文件夹里寻找模板。所以，如果你的应用是个模块，这个文件夹应该与模块同级；如果它是一个包，那么这个文件夹作为包的子目录:情况 1: 模块:123/application.py/templates /hello.html 情况 2: 包:1234/application /__init__.py /templates /hello.html 下面是hello.html文件内容1234567&lt;!doctype html&gt;&lt;title&gt;Hello from Flask&lt;/title&gt;&#123;% if name %&#125; &lt;h1&gt;Hello &#123;&#123; name &#125;&#125;!&lt;/h1&gt;&#123;% else %&#125; &lt;h1&gt;Hello World!&lt;/h1&gt;&#123;% endif %&#125; 访问请求数据可以通过request.form属性来访问表单数据。12345@app.route(\"/signin\", methods=[\"POST\"])def signin(): print request.args.get(\"username\") username = request.form[\"username\"] return render_template('hello.html', name=username) 如果form表单中不存在所要获取的键，会抛出特殊的KeyError异常。 文件上传首先确保HTML表单中设置 enctype=&quot;multipart/form-data&quot;属性，否则浏览器根本不会发送文件。已上传的文件存储在内存或是文件系统中一个临时的位置。可以通过请求对象的file属性访问它。每个上传的文件都会存储在这个字典里。同时它还有一个save()方法，这个方法允许把文件保额哦村到服务器的文件系统上。如果像知道上传的文件在客户端是什么名字，可以访问filename属性1234567from flask import request@app.route('/upload', methods=['GET', 'POST'])def upload_file(): if request.method == 'POST': f = request.files['the_file'] f.save('/var/www/uploads/uploaded_file.txt') Cookies可以通过cookies属性来访问Cookies，用响应对象的set_cookie方法来设置Cookies。请求对象的cookies属性是一个内容为客户端提交的所有Cookies的字典.读取cookies：1234567from flask import request@app.route('/')def index(): username = request.cookies.get('username') # use cookies.get(key) instead of cookies[key] to not get a # KeyError if the cookie is missing. 存储cookie：1234567from flask import make_response@app.route('/')def index(): resp = make_response(render_template(...)) resp.set_cookie('username', 'the username') return resp 需要注意的是，Cookies是设置在响应对象上的。由于通常视图函数只是返回字符串，之后Flask将字符串转换为响应对象。 重定向和错误可以使用redirect()函数把用户重定向到其他地方。用abort()函数放弃请求并返回错误代码，如下：12345678910from flask import abort, redirect, url_for@app.route('/')def index(): return redirect(url_for('login'))@app.route('/login')def login(): abort(401) this_is_never_executed() 这是一个完全没有任何意义的代码，因为用户会从主页重定向到一个不能访问的页面。默认情况下，错误代码会显示一个黑白的错误页面，如果要定制错误页面，可以使用errorhandler()装饰器12345from flask import render_template@app.errorhandler(404)def page_not_found(error): return render_template('page_not_found.html'), 404 注意`render_template()调用之后的404，这告诉Flask，该页的错误代码是404。默认是200,也就是一切正常 关于响应视图函数的返回值会被自动转换为一个响应对象。如果返回值是一个字符串， 它被转换为该字符串为主体的、状态码为 200 OK的 、 MIME 类型是text/html 的响应对象。Flask 把返回值转换为响应对象的逻辑是这样： 如果返回的是一个合法的响应对象，它会从视图直接返回。 如果返回的是一个字符串，响应对象会用字符串数据和默认参数创建。 如果返回的是一个元组，且元组中的元素可以提供额外的信息。这样的元组必须是 (response, status, headers) 的形式，且至少包含一个元素。 status 值会覆盖状态代码， headers 可以是一个列表或字典，作为额外的消息标头值。 如果上述条件均不满足， Flask 会假设返回值是一个合法的 WSGI 应用程序，并转换为一个请求对象。如果你想在视图里操纵上述步骤结果的响应对象，可以使用 make_response() 函数。 譬如你有这样一个视图:123@app.errorhandler(404)def not_found(error): return render_template('error.html'), 404 只需要把返回值表达式传递给make_response()，获取结果对象并修改，然后再返回它:12345@app.errorhandler(404)def not_found(error): resp = make_response(render_template('error.html'), 404) resp.headers['X-Something'] = 'A value' return resp 会话除请求对象之后，还有一个session对象，它允许你在不同请求间存储特定用户的信息。他是在Cookies的基础上实现，并且对Cookies进行密钥签名。这意味着用户可以查看你Cookie的内容，但却不能修改它，除非用户知道签名的密钥。要使用会话，需要设置一个密钥123456789101112131415161718192021222324252627282930from flask import Flask, session, redirect, url_for, escape, requestapp = Flask(__name__)@app.route('/')def index(): if 'username' in session: return 'Logged in as %s' % escape(session['username']) return 'You are not logged in'@app.route('/login', methods=['GET', 'POST'])def login(): if request.method == 'POST': session['username'] = request.form['username'] return redirect(url_for('index')) return ''' &lt;form action=\"\" method=\"post\"&gt; &lt;p&gt;&lt;input type=text name=username&gt; &lt;p&gt;&lt;input type=submit value=Login&gt; &lt;/form&gt; '''@app.route('/logout')def logout(): # remove the username from the session if it's there session.pop('username', None) return redirect(url_for('index'))# set the secret key. keep this really secret:app.secret_key = 'A0Zr98j/3yX R~XHH!jmN]LWX/,?RT' 这里提到的escape()可以在模板引擎外做转义 以上","tags":[{"name":"python","slug":"python","permalink":"http://www.huangyuanlove.com/tags/python/"},{"name":"flask","slug":"flask","permalink":"http://www.huangyuanlove.com/tags/flask/"}]},{"title":"TCP协议的简单理解","date":"2017-07-03T08:28:36.000Z","path":"2017/07/03/TCP协议的简单理解/","text":"尽管TCP和UDP都使用相同的网络层(IP)，TCP却向应用层提供与UDP完全不同的服务。TCP提供一种面向连接的、可靠的字节流服务。这里的面向连接是指：两个使用TCP的应用（通常是一个客户一个服务器）在彼此交换数据之前必须先建立一个TCP连接。 TCP的主要特点 TCP是面向连接的运输层协议 每一条TCP连接只能两个短点，每一条TCP都是点对点的 提供可靠交付服务 提供全双工服务 面向字节流TCP通过下列方式来提供可靠性 应用数据被分割成TCP认为最合适发送的数据块。这个UDP完全不同，应用程序产生的数据报长度将保持不变。由TCP传递给IP的信息单位称为报文段或段(segment) 当TCP发出一个段之后，它将启动一个定时器，等待目的端确认收到这个报文段，如果目的端不能及时确认接收，将重发这个报文段 当TCP收到发至TCP连接的另一端的数据，它将发送一个确认。 TCP保持它首部和数据的检验和。这是一个端到端的检验和，目的是检测数据在传输过程中的任何变化。如果检验和有差错，TCP将丢弃这个报文段和不确认接收此报文段，并希望另一端重传此报文段。 既然TCP报文段作为IP数据报来传输，而IP数据报的到达可能会失序，因此TCP报文段的到达也可能会失序。如果必要，TCP将对收到的数据进行重新排序，将收到的数据以正确的顺序交给应用层。 既然IP数据报会发生重复，TCP的接收端必须丢弃重复的数据。 TCP还能提供流量控制。TCP连接的每一方都有固定大小的缓冲空间，TCP的接收端只允许另一端发送接收端缓冲区所能接纳的数据。这将防止较快主机致使较慢主机缓冲区溢出。停止等待协议停止等待协议用下面的图来说明：图片来源于《计算机网络第六版》谢希仁编著在全双工通信的情况下，每一端既是接收方也是发送方，为方便，简化为A向B发送数据. 在无差错的情况下，A向B发送数据分组M1，发送完了就等待B的确认。B确认接收M1之后向A发送确认收到M1的数据。A收到B发送的”确认收到M1”的消息后，再向B发送下一组数据分组。 在有差错的情况下，B收到的数据分组可能是内容不对，B就把数据直接丢弃；也可能是数据分组在 传输过程中丢失了，B什么也没有接收到。这两种情况下，B什么也不操作（不通知A数据有错或者没收到数据。等到过一段时间，A没有收到B的确认消息，就认为刚刚发送的数据丢失了，然后重新传输刚才发送的分组。这要求A在每次发送一个数据分组时，都要设计一个超时计数器。 但是要注意 1) A在发送完一个分组后，必须暂时保留已发送的分组的副本（超时重传）。只有等到分组确认后才能清除暂时保留的副本 2) 分组和确认分组必须都进行编号 3) 超时及时器设置的重传时间应当比数据在分组传输的平均往返时间更长一些。 确认丢失和确认迟到下图左边的情况是B向A发送的确认收到M1的消息丢失了。A在设定的超时重传时间内没有收到确认，但并无法知道是自己发送的分组出错、丢失，或者是B发送的确认丢失了，因此A在超时计时器到期后就要重传M1。假定B又收到了重传的分组M1.这时应采取两个行动： 1) 丢弃这个重复的分组M1，不向上层交付。 2) 向A发送确认，不能认为已经发送过确认就不再发送，因为A之所以重传M1就表示A没有收到M1的确认。下图右边的情况是传输过程中没有出现差错，但是B对分组M1的确认迟到了，A会收到重复确认，然后丢弃掉，但是这时A已经重发数据分组M1了，B收到重复的分组M1胡同样丢弃重复的分组M1，并重传确认分组。连续ARQ协议 滑动窗口协议比较复杂。图片来源于《计算机网络第六版》谢希仁编著下图a表示发送发维持的发送窗口，它的意义是：位于发送窗口内的5个分组都可以连续发送出去，而不需要等待对方确认。连续ARQ协议规定，发送方每收到一个确认，就把窗口向前滑动一个分组的位置，b表示发送发收到了对第一个分组的确认，于是把发送的分组向前移动一个分组的位置。接收方一般都是采用累计确认的方式。这就是说，接收方不必对收到的分组逐个发送确认，而是在收到几个分组后，对按序到达的的最后一个分组发送确认，这就表示：到这个分组为止的所有分组都已经正确收到了。滑动窗口 TCP的滑动窗口是以字节为单位的。现在假定A收到了B发来的确认报文段，其中窗口是20，而确认号是31(这表明B期望收到的下一个序号是31,到序号30为止的数据已经收到了)。根据这两个数据，A就构造出自己的发送窗口，如下图所示 发送窗口表示：在没有收到B的确认情况下，A可以把窗口内的数据都发送出去。凡是已经发送过的数据，在未收到确认之前都必须暂时保留，以便在超时重传时使用。发送窗口里面的序号表示允许发送的序号。显然，窗口越大，发送方就可以在收到对方确认之前连续发送更多的数据，因而可能获得更高的传输效率。但是接收方必须来得及处理这些收到的数据。发送窗口后延的后面部分表示已发送且已收到了确认。这些数据显然不需要再保留。而发送窗口前沿的前面部分表示不允许发送的，因为接收方都没有为这部分数据保留临时存放的缓存空间。 发送窗口的位置由窗口前沿和后延的位置共同确定。发送窗口后沿的变换情况有两种可能，即不懂(没有收到新的确认)和前移(收到了新的确认)。发送窗口后沿不可能向后移动，因为不能撤销掉已收到的确认。发送窗口前沿通常是不断向前移动，但也有可能不动。这对应于两种情况：一时没有收到信的确认，对方通知的窗口大小也不变；二是收到了新的确认但对方通知的窗口缩小了，使得发送窗口前沿正好不动。发送窗口前沿也可能向后收缩，但是TCP的标准强烈不赞成这么做。TCP连接的建立假定主机A运行的是TCP客户程序，而B运行TCP服务器程序。最初两端的TCP进程都处于CLOSED(关闭)状态。如下图所示。现在A主动打开连接，而B是被动打开连接。 B的TCP服务器先创建传输控制块TCB，准备接受客户程序的连接请求，然后服务器进场就处于LISTEN(监听)状态，等待客户端的连接请求。如果有，即作出响应。 A的TCP客户进程也是首先创建传输控制模块TCB，然后向B发出连接请求报文段，这时首部中的同部位SYN=1，同时选择一个初始序号 seq=x 。TCP规定，SYN报文段(即SYN=1的报文段)不能携带数据，但要消耗掉一个序号。这时，TCP客户进程进入SYN-SENT(同步已发送)状态。 B收到连接请求报文段后，如果同意建立连接，则向A发送确认。在确认报文段中应把SYN位和ACK位都置1，确认号是ack=x+1 ,同时也为自己选择一个初始序号seq=y。这个报文段也不能携带数据，但同样要消耗掉一个序号。这时TCP服务器进程进入SYN-RCVD(同步收到)状态。 TCP客户进程收到B的确认后，还要向B给出确认。确认报文段的ACK置1，确认号ack=y+1，而自己的序号seq=x+1。TCP的标准规定，ACK报文段可以携带数据。但如果不携带数据则不消耗序号，在这种情况下，下一个数据报文段的序号仍然是seq=x+1。这时TCP连接已经建立，A进入ESTABLISHED(已建立连接)状态。 当B收到A的确认后，也进入ESTABLISHED状态 A最后发送一次确认主要是为了防止已失效的连接请求报文段突然又传送到了B，因而产生错误。TCP连接的释放数据传输结束后，通信的双方都可释放连接。 现在A和B都处于ESTABLISHED状态，A的应用进程先向其TCP发出连接释放报文段，并停止再发送数据，主动关闭TCP连接，A把连接释放报文段首部的宗旨控制位FIN置1，其序号seq=u，它等于前面已传送过的数据的最后一个直接的序号加1.这时A进入FIN-WAIT-1(终止等待1)状态，等待B的确认。TCP规定，FIN报文段即使不携带数据，它也消耗掉一个序号。 B收到连接释放报文段后即发出确认，确认号是ack=u+1，而这个报文段自己的序号是v，等于B前面已传送过的数据的最后一个字节的序号加1。然后B就进入CLOSE-WAIT(关闭等待)状态。TCP服务器进程这时应通知高层应用进程，因而从A到B这个方向的连接就释放了，这时的TCP连接处于半关闭(half-close)状态，即A已经没有数据要发送了，但B若发送数据，A仍要接收，就是说，从B到A这个方向的连接并未关闭，这个状态可能会持续一些时间。 A收到来自B的确认后，就进图FIN-WAIT-2(终止等待2)状态，等待B发出的连接释放报文段。 若B已经没有要向A发送的数据，其应用进程就通知TCP释放连接。这时B发出的连接释放报文段必须使用FIN=1.现在假定B的序号为w(在半关闭状态B可能又发送了一些数据)，B还必须重复上次已发送过的确认号ack=u+1。这时B就进入LAST-ACK(最后确认)状态，等待A的确认。 A在收到B的连接释放报文段后，必须对此发出确认。在确认报文段中把ACK置1，确认号ack=w+1，而自己的序号是seq=u+1，TCP规定，前面发送的FIN报文段要消耗一个序号。然后进入到TIME-WAIT(时间等待)状态。现在TCP连接还没有释放掉。必须经过时间等待计时器(TIME-WAIT timer)设置的时间2MSL后，A才进入到CLOSED状态，时间MSL叫做最长报文段寿命。 B只要收到了A发出的确认，就进入CLOSED状态。同样，B在撤销相应的出书控制块TCB后，就结束了这次的TCP连接。B结束TCP连接的时间要比A早一些。TCP有限状态机粗实线箭头表示对客户进程的正常变迁、粗虚线箭头表示对服务器进程的正常变迁、另一种细线箭头表示异常变迁。 以上文字和图片均来自于《计算机网络第6版》谢希仁著 以上","tags":[{"name":"tcp协议","slug":"tcp协议","permalink":"http://www.huangyuanlove.com/tags/tcp协议/"},{"name":"tcp/ip协议族","slug":"tcp-ip协议族","permalink":"http://www.huangyuanlove.com/tags/tcp-ip协议族/"}]},{"title":"Jenkins安装与使用","date":"2017-06-28T09:30:42.000Z","path":"2017/06/28/Jenkins安装与使用/","text":"公司需求，业务越来越多，服务器越来越多，后台部署项目麻烦的要死，于是上了jenkins这货。关于这货是干嘛的，请移步这里https://jenkins.io/,下载请移步这里https://jenkins.io/download/安装环境：ubuntu 16.04、tomcat7(这个是因为Jenkins是个war包)、maven(这个是因为后台的项目是maven工程)、jdk8(这个是因为需要tomcat)、gradle(构建Android工程)、SDK(构建Android工程) Jenkins 环境安装JDK、Tomcat、MAVEN(如有需要)、gradle(构建Android工程)、SDK(构建Android工程) 安装Jenkins在上面的下载地址下载war，丢到tomcat的webapps文件夹下，然后启动tomcat，浏览器访问jenkin工程127.0.0.1:8080/jenkins如下图所示：打开红字提示的文件，里面是首次进入时需要的密码,点击右下角continue。 jenkins安装插件可以自定义也可以安装推荐的插件，我这里安装的是建议的插件.稍等一会，插件安装完成后会自动跳转到创建jenkins用户的界面 创建jenkins用户按照提示创建即可，点击右下角Save and finish 配置Jenkins以后再次访问jenkins的时候就不用再去使用初始密码，只需要使用上一步创建的账号即可，登录后首界面如下，点击左侧的系统管理，在中间列出的工具里面点击Global Tool Configuration，指定JDK和MAVEN的路径，如下然后Save保存 创建一个新的Maven工程点击左侧菜单栏新建,输入工程名字，然后选择构建一个只有风格的软件项目,然后ok 配置工程在新的界面可以配置项目的构建、源码管理等我的工程是存放在git上面的，所以就选择git构建触发器可以配置在什么时间配置，我们暂时没有，需要手动点击构建才行构建环境没有配置构建一项选择 Invoke top-level Maven target,当然根据需求可以选择其他构建方式Maven Version是上面配置maven时选择的别名，Goals是需要执行的maven命令(前面不需要加maven)点击左下角保存 开始构建点击左侧的立即构建，可以在构建历史中查看原来构建的个过程点击构建历史列表里面对应构建历史的小圆点，可以查看控制台输出ps：如果是普通用户启动的tomcat，使用git管理源码，则下载下来的工程源码在/home/username/.jenkins/workspace，如果是root用户，则在 /root/.jenkins/workspace下pps:据说jenkins的包不需要tomcat也可以，执行java -jar ***.war即可","tags":[{"name":"jenkins","slug":"jenkins","permalink":"http://www.huangyuanlove.com/tags/jenkins/"},{"name":"运维","slug":"运维","permalink":"http://www.huangyuanlove.com/tags/运维/"},{"name":"服务器","slug":"服务器","permalink":"http://www.huangyuanlove.com/tags/服务器/"}]},{"title":"elk简单环境搭建 for linux","date":"2017-06-13T11:39:30.000Z","path":"2017/06/13/elk简单环境搭建-for-linux/","text":"环境：ubuntu 16.06虚拟机：4核8G内存在官网下载的tag.gz包，官网地址https://www.elastic.co/webinars/introduction-elk-stack安装版本是5.4.1，本文只安装了Elasticsearch、Logstash、Kibana Elasticsearch 下载压缩包并解压 在es的根目录下config/elasticsearch.yml文件，内容如下1234567891011121314151617181920# Use a descriptive name for the node:node.name: xuannode ##不要有'-'、'_'、'+'# Path to directory where to store the data (separate multiple locations by comma):#path.data: /home/huangyuan/elk/elasticsearch/data## Path to log files:#path.logs: /home/huangyuan/elk/elasticsearch/logs/*## Set the bind address to a specific IP (IPv4 or IPv6):#network.host: 0.0.0.0## Set a custom port for HTTP:#http.port: 9200discovery.zen.ping.unicast.hosts: [\"0.0.0.0\"]http.cors.enabled: truehttp.cors.allow-origin: \"*\" logstash 下载压缩包并解压 创建一个logstash.conf文件，输入以下内容并保存: 123456789101112input&#123; file &#123; path =&gt; &quot;/home/huangyuan/elkdata/*.log&quot; &#125;&#125;output &#123; elasticsearch &#123; hosts =&gt; &quot;http://192.168.1.179:9200&quot; index =&gt; &quot;logstash-%&#123;+YYYY.MM.dd&#125;&quot; &#125; stdout &#123;&#125;&#125; 启动时执行 bin/logstash -f logstash.conf kibana 下载压缩包并解压缩 编辑config/kibana.yml12345678910# Kibana is served by a back end server. This setting specifies the port to use.server.port: 5601# Specifies the address to which the Kibana server will bind. IP addresses and host names are both valid values.# The default is 'localhost', which usually means remote machines will not be able to connect.# To allow connections from remote users, set this parameter to a non-loopback address.server.host: \"192.168.1.179\"# The Kibana server's name. This is used for display purposes.server.name: \"xuankibina\"# The URL of the Elasticsearch instance to use for all your queries.elasticsearch.url: \"http://192.168.1.179:9200\" 启动的时候依次启动 es、logstash、kibana就可以了PS:1.在LogStash的配置文件logstash.conf中,input配置的就是logstash要监听的文件路径，启动之后，先在监听的文件夹中创建一个log文件并输入随意内容。 elasticsearch不能用root用户启动 启动es报错max virtual memory areas vm.max_map_count [65530]is too low, increase to at least [262144]:解决方法是修改/etc/sysctl.conf配置文件，添加vm.max_map_count=262144，重启机器才起作用.以上","tags":[{"name":"运维","slug":"运维","permalink":"http://www.huangyuanlove.com/tags/运维/"},{"name":"服务器","slug":"服务器","permalink":"http://www.huangyuanlove.com/tags/服务器/"},{"name":"elk","slug":"elk","permalink":"http://www.huangyuanlove.com/tags/elk/"}]},{"title":"git工具","date":"2017-05-10T08:51:11.000Z","path":"2017/05/10/git工具/","text":"公司代码版本管理系统由svn迁到了git，对于AndroidStudio来讲，内置的GUI工具足以应付日常开发，但在请求失败的情况下，对失败原因的提示不够清晰。个人习惯上用命令行，但是对于命令行中比较两个文件差异以及合并来说，个人还是不大习惯，于是就配置成了使用其他软件进行合并。可以使用$ git difftool --tool-help查看对比文件差异支持的软件，用$ git mergetool --tool-help查看合并代码支持的软件，个人只试过两种:codecompare和beyond compare。不习惯bc的界面，最后决定使用codecompare。 配置codecompare为diff和merge工具 安装codecompare软件 配置codecompare为diff工具 git config --global diff.tool codecompare 配置codecompare的路径path 后面是软件的安装路径 git config --global difftool.codecompare.path D://CodeCompare//CodeCompare.exe 配置codecompare为merge工具 git config --global merge.tool codecompare 配置codecompare的路径path 后面是软件的安装路径 git config --global mergetool.codecompare.path D://CodeCompare//CodeMerge.exe 在比较本地修改后的文件与本地仓库中的文件差异时，执行 git difftool &lt;filename&gt;即可。当更新代码自动合并失败的时候，执行 git mergetool即可。 配置beyond compare为diff和merge工具配置方式和codecompare一样，需要注意的是： 如果beyond compare软件是4.X1) 如果git的版本低于2.2.0,配置的时候用bc32) 如果git的版本大于等于2.2.0,配置的时候用bc这个如何配置官网有说明，就不再赘述在比较本地修改后的文件与本地仓库中的文件差异时，执行 git difftool &lt;filename&gt;即可。当更新代码自动合并失败的时候，执行 git mergetool即可。有人不习惯git自动merge成功后填写merge信息的编辑器，说明一下，默认的编辑器是vim,不习惯用的话可以使用 git config --global core.edit &lt;软件路径&gt;来修改。需要注意的是，git命令行似乎读不到windows系统的path，需要写软件的绝对路径。 以上","tags":[{"name":"git","slug":"git","permalink":"http://www.huangyuanlove.com/tags/git/"},{"name":"git工具","slug":"git工具","permalink":"http://www.huangyuanlove.com/tags/git工具/"}]},{"title":"搭建git服务","date":"2017-04-15T02:25:31.000Z","path":"2017/04/15/搭建git服务/","text":"公司的版本控制要从SVN迁移到git，正式的开发环境还没有搭建好，于是自己做了一个简单git服务。环境：本机: win10，服务器：ubuntu 16.04 LTS,ip:192.168.1.103本地安装git环境，配置用户名和邮箱之类的信息，然后生成秘钥，生成方式见 http://blog.csdn.net/huangyuan_xuan/article/details/49125597。服务器： 安装git,ssh服务sudo apt install git ssh 新增用户，用户名为gitadduser git 初始化git仓库，我放在/home/git/repositorycd /home/git/repositorygit init --bare test.git--base参数是初始化裸仓库。执行tree命令可以查看目录结构如下： 添加秘钥将本地生成的id_rsa.pub文件里面的内容追加到/home/git/.ssh/authorized_keys文件中。可以先将秘钥文件上传到服务器，然后在服务器上操作文件，添加内容。 修改权限将 /home/git 所有者更改为git用户chown -R git:git /home/git用户home目录755权限chmod 755 /home/git.ssh目录700权限chmod 700 .sshauthorized_keys 600权限chmod 600 .ssh/authorized_keys 修改ssh配置文件配置文件是/etc/ssh/sshd_config，取消这行 AuthorizedKeysFile %h/.ssh/authorized_keys 前面的注释 重启ssh服务sudo service ssh restart 可选项：为了安全 禁止git用户shell登录，需要修改/etc/passwd将 git:x:1001:1001:,,,:/home/git:/bin/bash改为 git:x:1001:1001:,,,:/home/git:/usr/bin/git-shell 回到本地，进行克隆git clone git@192.168.1.103:/home/git/code/test.git或者git clone git@192.168.1.103:code/test.git如果ssh不是默认的22端口，则在ip后添加端口。","tags":[{"name":"运维","slug":"运维","permalink":"http://www.huangyuanlove.com/tags/运维/"},{"name":"服务器","slug":"服务器","permalink":"http://www.huangyuanlove.com/tags/服务器/"},{"name":"git","slug":"git","permalink":"http://www.huangyuanlove.com/tags/git/"}]},{"title":"JVM-内存分配与回收策略","date":"2017-04-07T07:27:46.000Z","path":"2017/04/07/JVM-内存分配与回收策略/","text":"Java技术体系中所提倡的自动内存管理最终可以归结为自动化的解决了两个问题：给对象分配内存以及回收分配给对象的内存。对象的内存分配，往大方向讲，就是在堆上分配(但也可能经过JIT编译后被拆散为标量类型并间接地栈上分配)，对象主要分配在新生代的Eden区上，如果启动了本地线程分配缓冲，将按线程优先在TLAB上分配。少数情况下也可能会直接分配在老年代中，分配的规则并不是百分百固定的，其细节取决于当前使用的是哪一种垃圾回收器组合，还有虚拟机中与内存相关的参数设置。 对象优先在Eden分配 大多数情况下，对象在新生代Eden区中分配，当Eden区没有足够空间进行分配时，虚拟机将发起一次Minor GC。虚拟机提供了-XX：+PrintGCDetails这个收集器日志参数，告诉虚拟机在发生垃圾收集行为时打印内存回收日志，并且在进程退出的时候输出当前的内存各区域分配情况。 新生代GC(Minor GC):指发生在新生代的垃圾收集动作，因为Java对象大多都具备朝生夕灭的特性，所以Minor GC非常频繁，一般回收速度也比较快。 老年代GC(Major GC/Full GC):指发生在老年代的GC，出现了Major GC，经常会伴随至少一次的Minor GC，(但非绝对的，在Parallel Scavenge收集器的手机策略里就有直接进行Major GC的策略选择过程)。Major GC的速度一般会比Minor GC慢10倍以上。 大对象直接进入老年代 所谓的大对象是指，需要大量连续内存空间的Java对象，最典型的大对象就是那种很长的字符串以及数组，大对象对虚拟机的内存分配来说就是一个坏消息，经常出现大对象容易导致内存还有不少空间时就提前出发垃圾收集以获取足够的连续空间来”安置”它们。 长期存活的对象将进入老年代 既然虚拟机采用了分代收集的思想来管理内存，那么内存回收时就必须能识别哪些对象应放在新生代，哪些对象应放在老年代中。为了做到这点，虚拟机给每个对象定义了一个对象年龄(Age)计数器。如果对象在Eden出生并经过第一个Minor GC后仍然存活，并且能被Survivor容纳的话，将被移动到Survivor空间中，并且对象年龄设为1。对象在Survivor区中每经过一个Minor GC，年龄就增加1岁，当它的年龄增加到一定程度(默认是15岁)，就会被晋升到老年代中。对象晋升老年代的年龄阈值，可以通过参数-XX：MaxTenuringThreshold设置。 动态对象年龄判定 为了能更好的适应不同程序的内存状况，虚拟机并不是永远的要求对象的年龄必须达到了MaxTenuringThreshold才能晋升到老年代，如果Survivor空间中相同的年龄所有对象大小的总和大于Survivor空间的一般，年龄大于或等于改年龄的对象就可以直接进入老年代，无序等到MaxTenuringThreshold中要求的年龄。 空间分配担保 在发生Minor GC之前，虚拟机会先检查老年代最大可用的连续空间是否大于新生代所有对象总空间，如果这个条件成立，那么Minor GC可以确保是安全的。如果不成立，则虚拟机会查看HandlePromotionFailure设置值是否允许担保失败。如果允许，那么会继续检查老年代最大可用的连续空间是否大于历次晋升到老年代对象的平均大小，如果大于，将尝试着进行一次Minor GC，尽管这次Minor GC是有风险的；如果小于，或者HandlePromotionFailure设置不允许冒险，那这时也要改为进行一次Full GC。新生代使用复制收集算法，但为了内存利用率，只使用其中一个Survivor空间来作为轮换备份，因此当出现大量对象在Minor GC后仍然存活的情况(最极端的情况就是内存回收后新生代中所有对象都存活)，就需要老年代进行分配担保，把Survivor无法容纳的对象直接进入老年代。 与生活中的贷款担保类似，老年代要进行这样的担保，前提是老年代本身还有容纳这些对象的剩余空间，一共有多少对象会活下来在实际完成内存回收之前是无法明确知道的，所以只好取之前每一次回收晋升到老年代对象容量的平均大小值作为经验值，与老年代的剩余空间进行比较，决定是否进行Full GC来让老年代腾出更多空间。取平均值进行比较其实仍然是一种动态概率的手段，也就是说，如果某次Minor GC存活后的对象突增，远远高于平均值的话，依然会导致担保失败(Handle Promotion Failure)。如果出现了HandlePromotionFailure失败，那就只好在失败后重新发起一次Full GC。 虽然担保失败时绕的圈子是最大的，但大部分情况下都还是会将HandlePromotionFailure开关打开，避免Full GC过于频繁。 以上","tags":[{"name":"java","slug":"java","permalink":"http://www.huangyuanlove.com/tags/java/"},{"name":"JVM","slug":"JVM","permalink":"http://www.huangyuanlove.com/tags/JVM/"}]},{"title":"JVM-垃圾收集算法与实现","date":"2017-03-30T02:27:05.000Z","path":"2017/03/30/JVM-垃圾收集算法/","text":"由于垃圾收集算法的实现涉及大量的程序细节，而且各个平台的虚拟机操作内存的方法又各不相同，这里只是介绍几种算法的思想及其发展过程。 垃圾收集算法标记-清除算法 最基础的算法是”标记-清除”(Mark-Sweep)算法，算法分为’标记’和’清除’两个阶段：首先标记处所有需要回收的对象，在标记后统一回收所有被标记的对象。它的主要不足有两个：一个事效率问题，标记和清除两个过程的效率都不高；另外一个事空间问题，标记清除之后会产生大量不连续的内存碎片，空间碎片太多可能会导致以后再程序运行过程中需要分配较大对象时，无法找到足够的连续内存而不得不提前触发另一次垃圾收集动作。 1. 复制算法 它将可用内存按容量划分为大小相等的两块，每次只使用其中的一块，当这一块的内存用完了，就将还存活着的对象复制到另外一块上面，然后把已经使用过的内存空间一次清理掉。这样使得每次都是对整个半区进行内存回收，内存分配时也就不用考虑内存碎片等复杂情况。只要移动堆顶指针，按顺序分配内存即可，实现简单，运行高效，只是这种算法的代价是将内存缩小为了原来的一般，代价太高。现在的商业虚拟机都采用这种手机算法回收新生代，IBM公司的专门研究表明，新生代中的对象98%是朝生夕死的，所以并不需要按照1:1的比例来划分内存空间，而是将内存分为一块较大的Eden空间和两块较小的Survivor空间，每次使用Eden和其中一块Survivor空间上，最后清理掉Eden和刚才用过的Survivor中还存活着的对象一次性复制到另外一块Survivor空间上，最后清理掉Eden和刚才用过的Survivor空间。 2. 标记-整理算法 复制收集短发在对象存活率较高时就要进行较多的复制操作，效率将会变低。更关键的是，如果不想浪费一半的空间，就需要额外的控件进行分配担保，以应对被使用的的内存中所有对象都100%存活的极端情况，所以在老年代一半不能直接选用这种算法。根据老年代的特点，有人提出了另外一种”标记-整理”(Mark-Compact)算法，标记过程任然与”标记-清除”算法一样，但后续步骤不是直接对可回收对象进行清理，而是让所有存活的对象都向一端移动，然后直接清理掉端便捷以外的内存。 3. 分代收集算法 当前商业虚拟机的垃圾收集都采用”分代收集”(Generational Collection)算法，这种算法并没有什么新的思想，只是根据对象的存货周期的不同将内存划分为几块，一般是把Java堆分为新生代和老年代，这样就可以根据各个年代的特点采用最适当的收集算法。在新生代中，每次垃圾收集时都发现有大批对象死去，只有少量存活，那就选用复制算法，只需要付出少量存活对象的复制成本就可以完成收集。而老年代中因为对象存活率高、没有额外空间对它进行分配担保，就必须使用”标记-清理”或者”标记-整理”算法来进行回收。 HotSpot算法实现枚举根节点 从可达性分析中从GC Roots节点引用链这个操作为例，可作为GC Roots的节点主要在全局性的引用(例如常量或类静态属性)与执行上下文(例如栈帧中的本地变量表)中，现在很多应用仅仅方法区就有数百兆，如果要逐个检查这里面的引用，那么必然会消耗很多时间。另外，可达性分析对执行时间的敏感还体现在GC停顿上，因为这项分析工作必须在一个能确保一致性的快照中进行—-这里一致性的意思是指在这个分析期间整个执行系统看起来就像被冻结在某个时间点上，不可以出现分析过程中对象引用关系还在不断变化的情况，该点不满足的话分析结果准确性就无法得到抱枕。这点是导致GC进行时必须停顿所有Java执行线程(Sun将这件事情称为”Stop The World”)的其中一个重要原因，即使是在号称几乎不会发生停顿的CMS收集器中，枚举根节点时也是必须要停顿的。由于目前的主流java虚拟机使用的都是准确式GC，所以当执行系统停顿下来后，并不需要一个不漏的检查完所有执行上下文和全局引用位置，虚拟机应当是有办法直接得知哪些地方存放着对象引用。在HotSpot的实现中，是使用一组称为OopMap的数据结构来达到这个目的的，在类加载完成的时候，HotSpot就把对象内什么偏移量上是什么类型的数据计算出来，在JIT编译过程中，也会在特定的位置记录下栈和寄存器中哪些位置是引用，这样，GC在扫描时就可以直接得知这些信息了。 安全点 在OopMap的协助下，HotSpot可以快速且准确地完成GC Roots枚举，但一个很现实的问题随之而来：可能导致引用关系变化，或者说OopMap内容变化的指令非常多，如果为每一条指令都生成对应的OopMap，那将会需要大量的额外空间，这样GC的空间成本将会变得很高。实际上，HotSpot也的确没有为每条指令都生成OopMap，前面已经提到，只是在“特定的位置”记录了这些信息，这些位置称为安全点（Safepoint），即程序执行时并非在所有地方都能停顿下来开始GC，只有在到达安全点时才能暂停。 Safepoint的选定既不能太少以致于让GC等待时间太长，也不能过于频繁以致于过分增大运行时的负荷。 所以，安全点的选定基本上是以程序“是否具有让程序长时间执行的特征”为标准进行选定的——因为每条指令执行的时间都非常短暂，程序不太可能因为指令流长度太长这个原因而过长时间运行，“长时间执行”的最明显特征就是指令序列复用，例如方法调用、循环跳转、 异常跳转等，所以具有这些功能的指令才会产生Safepoint。对于Sefepoint，另一个需要考虑的问题是如何在GC发生时让所有线程（这里不包括执行JNI调用的线程）都“跑”到最近的安全点上再停顿下来。 这里有两种方案可供选择：抢先式中断（Preemptive Suspension）和主动式中断（Voluntary Suspension），其中抢先式中断不需要线程的执行代码主动去配合，在GC发生时，首先把所有线程全部中断，如果发现有线程中断的地方不在安全点上，就恢复线程，让它“跑”到安全点上。 现在几乎没有虚拟机实现采用抢先式中断来暂停线程从而响应GC事件。而主动式中断的思想是当GC需要中断线程的时候，不直接对线程操作，仅仅简单地设置一个标志，各个线程执行时主动去轮询这个标志，发现中断标志为真时就自己中断挂起。轮询标志的地方和安全点是重合的，另外再加上创建对象需要分配内存的地方。 安全区域 使用Safepoint似乎已经完美地解决了如何进入GC的问题，但实际情况却并不一定。Safepoint机制保证了程序执行时，在不太长的时间内就会遇到可进入GC的Safepoint。但是，程序“不执行”的时候呢？所谓的程序不执行就是没有分配CPU时间，典型的例子就是线程处于Sleep状态或者Blocked状态，这时候线程无法响应JVM的中断请求，“走”到安全的地方去中断挂起，JVM也显然不太可能等待线程重新被分配CPU时间。 对于这种情况，就需要安全区域（Safe Region）来解决。安全区域是指在一段代码片段之中，引用关系不会发生变化。 在这个区域中的任意地方开始GC都是安全的。 我们也可以把Safe Region看做是被扩展了的Safepoint。 在线程执行到Safe Region中的代码时，首先标识自己已经进入了Safe Region，那样，当在这段时间里JVM要发起GC时，就不用管标识自己为Safe Region状态的线程了。在线程要离开Safe Region时，它要检查系统是否已经完成了根节点枚举（或者是整个GC过程），如果完成了，那线程就继续执行，否则它就必须等待直到收到可以安全离开Safe Region的信号为止。以上","tags":[{"name":"JVM","slug":"JVM","permalink":"http://www.huangyuanlove.com/tags/JVM/"},{"name":"Java","slug":"Java","permalink":"http://www.huangyuanlove.com/tags/Java/"}]},{"title":"JVM垃圾回收-对象已死？","date":"2017-03-29T09:23:36.000Z","path":"2017/03/29/JVM垃圾回收-对象已死？/","text":"在堆里面存放着Java世界中几乎所有的对象实例，垃圾收集器在对堆进行回收前，第一件事情就是要确定这些对象之中哪些还存活着，哪些已经死去(即不能再被任何途径使用的对象)。 引用计数算法 很多教科书判断对象是否存活的算法是这样的：给对象中添加一个引用计数器，每当有一个地方引用它时，计数器值就加1;当引用失效时，计数器就减1；任何时刻计数器为0的对象就是不可能再被使用的。客观来讲，引用计数法(Reference Counting)的实现简单，判定效率也很高，在大部分情况下它都是一个不错的算法，但是，至少主流的Java虚拟机里面没有选用引用计数器算法来管理内存，其中主要的原因是它很难解决对象之间相互循环引用的问题。 可达性分析算法 在主流的商用程序语言的主流实现中，都是通过可达性分析(Reachability Analysis)来判定对象是否存活的。这个算吗的基本思路就是通过一系列的称为GC Roots的对象作为起始点，从这些节点开始向下搜索，搜索所走过的路径称为引用链(Reference Chain),当一个对象到GC Roots没有任何引用链相连时(在图论中，就是从GC Roots到这个对象不可达)，则证明此对象是不可用的。在Java语言中，可作为GC Roots的对象包括一下几种： 虚拟机栈(栈帧中的本地变量表)中引用的对象。 方法区中静态属性引用的对象。 方法区中常量引用的对象。 本地方法栈中JNI(一般说的Native方法)引用的对象 生存还是死亡 即使在可达性分析算法中不可达的对象，也并非是非死不可的，这时候他们暂时处于缓刑阶段，要真正宣告一个对象死亡，至少要经历两次标记过程：如果对象在进行可达性分析后发现没有与GC Roots相连接的引用链，那它将会被第一次标记并且进行一次筛选，筛选的条件是此对象是否有必要执行finalize()方法。当对象没有覆盖finalize()方法，或者finalize()方法已经被虚拟机调用过，虚拟机将这两种情况都视为”没有必要执行”。如果这个对象呗判定为有必要执行finalize()方法，那么这个对象将会放置在一个叫做F-Queue的队列之中，并在稍后由一个虚拟机自动建立的、优先级低的Finalizer线程去执行它。这里所谓的执行是指虚拟机会触发这个方法，但并不承诺会等待它运行结束，这样做的原因是：如果一个对象在finalize()方法中执行缓慢，或者发生了死循环，将很可能会导致F-Queue队列中其他对象永久处于等待，甚至导致整个内存回收系统崩溃。finalize()方法是对象 逃脱死亡命运的最后一次机会，稍后GC将对F-Queue中的对象进行第二次小规模的标记。 回收方法区 很多人认为方法区是没有垃圾收集的，Java虚拟机规范中确实说过可以不要求虚拟机方法区实现垃圾收集，而且在方法区中进行垃圾收集的性价比一般比较低：在堆中，尤其是在新生代中，常规应用进行一次垃圾收集一般可以回收70%-95%的空间，而永久代的垃圾收集效率远低于此。永久代的垃圾收集主要回收两部分内容：废弃常量和无用的类。回收废弃常量与回收Java堆中的对象非常类似。以常量池中字面量的回收为例：假如一个字符串”ABC”已经进入了常量池中，但是当前系统没有任何一个String对象是叫做”ABC”的，换句话说，就是没有任何String对象引用常量池中的”ABC”常量，也没有其他地方引用了这个字面量，如果这时繁盛内存回收，而且必要的话，这个”ABC”常量就会被系统清理出常量池，常量池中的其他类、方法、字段的符号引用也与此类似。判定一个常量是否是”废弃常量”比较简单，而要判定一个类是否是”无用的类”的条件则相对苛刻许多。类需要同时满足下面三个调教才能算是”无用的类”： 该类所有的实例都已经被回收，也就是Java堆中不存在该类的任何实例。 加载该类的ClassLoader已经被回收。 该类对用的java.lang.Class对象没有在任何对方被引用，无法在任何地方通过反射访问该类的方法。 虚拟机可以对满足上述3个条件的无用类进行回收，这里说的仅仅是“可以”，而并不是和对象一样，不使用了就必然会回收。 是否对类进行回收，HotSpot虚拟机提供了-Xnoclassgc参数进行控制，还可以使用-verbose：class以及-XX：+TraceClassLoading、 -XX：+TraceClassUnLoading查看类加载和卸载信息，其中-verbose：class和-XX：+TraceClassLoading可以在Product版的虚拟机中使用，-XX：+TraceClassUnLoading参数需要FastDebug版的虚拟机支持。在大量使用反射、 动态代理、 CGLib等ByteCode框架、 动态生成JSP以及OSGi这类频繁自定义ClassLoader的场景都需要虚拟机具备类卸载的功能，以保证永久代不会溢出。 以上","tags":[{"name":"JVM","slug":"JVM","permalink":"http://www.huangyuanlove.com/tags/JVM/"},{"name":"Java","slug":"Java","permalink":"http://www.huangyuanlove.com/tags/Java/"}]},{"title":"Android N 应用内更新","date":"2017-03-28T02:30:31.000Z","path":"2017/03/28/Android-N-应用内更新/","text":"继之前跪在Android M的动态权限之后，最近又跪在了Android N的StrictMode上了。所以啊，要对技术持有敬畏的态度。场景如下：我司内部员工使用的APP需要有应用内更新的功能，意思就是在应用内下载最新版本的应用并且调起安装界面。方案：由于每次从新打开app都需要重新登录，那就在登录界面加上检查更新的接口请求，后台对比当前版本App的VersionCode 和 数据库存储的VersionCode对比，如果需要更新，则返回最新版本软件的下载地址，前端进行下载安装。当前端解析出下载地址后，弹出提示框，下载或者取消。点击下载则开启线程下载，同时在界面上显示下载进度，下载完成后，调起安装界面进行安装。代码很简单，这里放出不涉及我司业务的代码：1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950private void downLoadAPK() &#123; downLoadThread = new Thread(new Runnable() &#123; @Override public void run() &#123; try &#123; URL url = new URL(downLoadUrl); HttpURLConnection conn = (HttpURLConnection) url .openConnection(); conn.connect(); int length = conn.getContentLength(); InputStream is = conn.getInputStream(); File file = new File(\"\"); if (!file.exists()) &#123; file.mkdir(); &#125; File apkFile = new File(saveFilePath); if (apkFile.exists()) &#123; apkFile.delete(); &#125; FileOutputStream fos = new FileOutputStream(apkFile); int count = 0; byte buf[] = new byte[1024]; // 点击取消就停止下载. while (!interceptFlag) &#123; int numread = is.read(buf); count += numread; progress = (int) (((float) count / length) * 100); // 更新进度 getHandler().sendEmptyMessage(DOWN_UPDATE); if (numread &lt;= 0) &#123; // 下载完成通知安装 getHandler().sendEmptyMessage(DOWN_OVER); interceptFlag = false; &#125; fos.write(buf, 0, numread); &#125; fos.close(); is.close(); &#125; catch (Exception e) &#123; e.printStackTrace(); &#125; &#125; &#125;); downLoadThread.start(); &#125; 以上为下载文件的代码，逻辑很简单，起一个新线程，使用HttpURLConnection进行文件下载。123456789private void installAPK(String filePath) &#123; File apkFile = new File(filePath); Intent intent = new Intent(Intent.ACTION_VIEW); if (!apkFile.exists()) &#123; return; &#125; intent.setDataAndType(Uri.fromFile(apkFile), \"application/vnd.android.package-archive\"); context.startActivity(intent);&#125; 以上代码是刚开始写的安装软件的代码，在Android N 以下运行正常，但是在Android N上却爆出了如下错误，12345678910111213141516171819android.os.FileUriExposedException: file: exposed beyond app through Intent.getData() at android.os.StrictMode.onFileUriExposed(StrictMode.java:1799) at android.net.Uri.checkFileUriExposed(Uri.java:2346) at android.content.Intent.prepareToLeaveProcess(Intent.java:8949) at android.content.Intent.prepareToLeaveProcess(Intent.java:8908) at android.app.Instrumentation.execStartActivity(Instrumentation.java:1519) at android.app.ContextImpl.startActivity(ContextImpl.java:829) at android.app.ContextImpl.startActivity(ContextImpl.java:806) at android.content.ContextWrapper.startActivity(ContextWrapper.java:366) at com.mmuu.travel.service.ui.LoginFrg.installAPK(LoginFrg.java:349) at com.mmuu.travel.service.ui.LoginFrg.access$200(LoginFrg.java:66) at com.mmuu.travel.service.ui.LoginFrg$1.onFinish(LoginFrg.java:134) at android.os.CountDownTimer$1.handleMessage(CountDownTimer.java:127) at android.os.Handler.dispatchMessage(Handler.java:102) at android.os.Looper.loop(Looper.java:154) at android.app.ActivityThread.main(ActivityThread.java:6114) at java.lang.reflect.Method.invoke(Native Method) at com.android.internal.os.ZygoteInit$MethodAndArgsCaller.run(ZygoteInit.java:874) at com.android.internal.os.ZygoteInit.main(ZygoteInit.java:764) 网上搜了一下，是Android N在权限上做了一些修改：参考链接 https://developer.android.google.cn/about/versions/nougat/android-7.0-changes.html 系统权限更改为了提高私有文件的安全性，面向 Android 7.0 或更高版本的应用私有目录被限制访问 (0700)。此设置可防止私有文件的元数据泄漏，如它们的大小或存在性。此权限更改有多重副作用：私有文件的文件权限不应再由所有者放宽，为使用 MODE_WORLD_READABLE 和/或 MODE_WORLD_WRITEABLE 而进行的此类尝试将触发 SecurityException。 注：迄今为止，这种限制尚不能完全执行。应用仍可能使用原生 API 或 File API 来修改它们的私有目录权限。但是，我们强烈反对放宽私有目录的权限。 传递软件包网域外的 file:// URI 可能给接收器留下无法访问的路径。因此，尝试传递 file:// URI 会触发 FileUriExposedException。分享私有文件内容的推荐方法是使用 FileProvider。DownloadManager 不再按文件名分享私人存储的文件。旧版应用在访问 COLUMN_LOCAL_FILENAME 时可能出现无法访问的路径。面向 Android 7.0 或更高版本的应用在尝试访问 COLUMN_LOCAL_FILENAME 时会触发 SecurityException。通过使用 DownloadManager.Request.setDestinationInExternalFilesDir() 或 DownloadManager.Request.setDestinationInExternalPublicDir() 将下载位置设置为公共位置的旧版应用仍可以访问 COLUMN_LOCAL_FILENAME 中的路径，但是我们强烈反对使用这种方法。对于由 DownloadManager 公开的文件，首选的访问方式是使用ContentResolver.openFileDescriptor()。 解决方案： FileProvider1.1 在mainfest中加入FileProvider注册123456789101112&lt;application&gt; &lt;provider android:authorities=\"你的应用名.fileprovider\" android:name=\"android.support.v4.content.FileProvider\" android:grantUriPermissions=\"true\" android:exported=\"false\"&gt; &lt;meta-data android:name=\"android.support.FILE_PROVIDER_PATHS\" android:resource=\"@xml/filepaths\"/&gt; &lt;/provider&gt;&lt;/application&gt; 1.2 在res文件夹下新建xml文件夹，在xml文件夹中新建filepaths文件，这个文件名字和上面的 Android:resource后面的名字要一致编辑该文件：123456&lt;?xml version=\"1.0\" encoding=\"utf-8\"?&gt;&lt;paths&gt; &lt;external-path name=\"external_storage_root\" path=\"\" /&gt;&lt;/paths&gt; 1.3 修改安装代码1234567891011121314151617private void installAPK(String filePath) &#123; File apkFile = new File(filePath); Intent intent = new Intent(Intent.ACTION_VIEW); if (!apkFile.exists()) &#123; return; &#125; if (Build.VERSION.SDK_INT &gt;= Build.VERSION_CODES.N) &#123; intent.setFlags(Intent.FLAG_GRANT_READ_URI_PERMISSION); Uri contentUri = FileProvider.getUriForFile(context, BuildConfig.APPLICATION_ID + \".fileProvider\", apkFile); intent.setDataAndType(contentUri, \"application/vnd.android.package-archive\"); &#125; else &#123; intent.setDataAndType(Uri.fromFile(apkFile), \"application/vnd.android.package-archive\"); &#125; getActivity().getApplicationContext().startActivity(intent); context.finish(); &#125; 首先判断设备的Android版本，N或者N以上使用FileProvider进行安装，N一下还是原来的方式。注意调用startActivity要使用ApplicationContext，使用Activity.this会报错。 使用DownloadManager123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154public class ApkDownLoad &#123; public static final String DOWNLOAD_FOLDER_NAME = getLocalForderPath(); public static final String DOWNLOAD_FILE_NAME = \"XXX.apk\"; public static final String APK_DOWNLOAD_ID = \"apkDownloadId\"; private Context context; private String url; private String notificationTitle; private String notificationDescription; private DownloadManager downloadManager; private CompleteReceiver completeReceiver; /** * @param context * @param url 下载apk的url * @param notificationTitle 通知栏标题 * @param notificationDescription 通知栏描述 */ public ApkDownLoad(Context context, String url, String notificationTitle, String notificationDescription) &#123; super(); this.context = context; this.url = url; this.notificationTitle = notificationTitle; this.notificationDescription = notificationDescription; downloadManager = (DownloadManager) context .getSystemService(Context.DOWNLOAD_SERVICE); completeReceiver = new CompleteReceiver(); /** register download success broadcast **/ context.registerReceiver(completeReceiver, new IntentFilter( DownloadManager.ACTION_DOWNLOAD_COMPLETE)); &#125; public void execute() &#123; // 清除已下载的内容重新下载 long downloadId = UpdateUtils.getLong(context, APK_DOWNLOAD_ID); if (downloadId != -1) &#123; downloadManager.remove(downloadId); UpdateUtils.removeSharedPreferenceByKey(context, APK_DOWNLOAD_ID); &#125; Request request = new Request(Uri.parse(url)); // 设置Notification中显示的文字 request.setTitle(notificationTitle); request.setDescription(notificationDescription); // 设置可用的网络类型 request.setAllowedNetworkTypes(Request.NETWORK_MOBILE | Request.NETWORK_WIFI); // 设置状态栏中显示Notification request.setNotificationVisibility(DownloadManager.Request.VISIBILITY_VISIBLE_NOTIFY_COMPLETED); // 不显示下载界面 request.setVisibleInDownloadsUi(false); // 设置下载后文件存放的位置 File folder = Environment .getExternalStoragePublicDirectory(DOWNLOAD_FOLDER_NAME); if (!folder.exists() || !folder.isDirectory()) &#123; folder.mkdirs(); &#125; // 设置下载文件的保存路径 request.setDestinationInExternalPublicDir(DOWNLOAD_FOLDER_NAME, DOWNLOAD_FILE_NAME); // 设置文件类型 MimeTypeMap mimeTypeMap = MimeTypeMap.getSingleton(); String mimeString = mimeTypeMap.getMimeTypeFromExtension(MimeTypeMap .getFileExtensionFromUrl(url)); request.setMimeType(mimeString); // 保存返回唯一的downloadId UpdateUtils.putLong(context, APK_DOWNLOAD_ID, downloadManager.enqueue(request)); &#125; class CompleteReceiver extends BroadcastReceiver &#123; @Override public void onReceive(Context context, Intent intent) &#123; /** * get the id of download which have download success, if the id is * my id and it's status is successful, then install it **/ long completeDownloadId = intent.getLongExtra( DownloadManager.EXTRA_DOWNLOAD_ID, 0); long downloadId = UpdateUtils.getLong(context, APK_DOWNLOAD_ID); if (completeDownloadId == downloadId) &#123; // if download successful if (queryDownloadStatus(downloadManager, downloadId) == DownloadManager.STATUS_SUCCESSFUL) &#123; // clear downloadId UpdateUtils.removeSharedPreferenceByKey(context, APK_DOWNLOAD_ID); // unregisterReceiver context.unregisterReceiver(completeReceiver); // install apk String apkFilePath = new StringBuilder(Environment .getExternalStorageDirectory().getAbsolutePath()) .append(File.separator) .append(DOWNLOAD_FOLDER_NAME) .append(File.separator).append(DOWNLOAD_FILE_NAME) .toString(); install(context, apkFilePath); &#125; &#125; &#125; &#125; /** * 查询下载状态 */ public static int queryDownloadStatus(DownloadManager downloadManager, long downloadId) &#123; int result = -1; DownloadManager.Query query = new DownloadManager.Query() .setFilterById(downloadId); Cursor c = null; try &#123; c = downloadManager.query(query); if (c != null &amp;&amp; c.moveToFirst()) &#123; result = c.getInt(c .getColumnIndex(DownloadManager.COLUMN_STATUS)); &#125; &#125; finally &#123; if (c != null) &#123; c.close(); &#125; &#125; return result; &#125; /** * install app * * @param context * @param filePath * @return whether apk exist */ public static boolean install(Context context, String filePath) &#123; Intent i = new Intent(Intent.ACTION_VIEW); File file = new File(filePath); if (file != null &amp;&amp; file.length() &gt; 0 &amp;&amp; file.exists() &amp;&amp; file.isFile()) &#123; i.setDataAndType(Uri.parse(\"file://\" + filePath), \"application/vnd.android.package-archive\"); i.addFlags(Intent.FLAG_ACTIVITY_NEW_TASK); context.startActivity(i); return true; &#125; return false; &#125;&#125; 检测到需要升级时 new ApkDownLoad().execute()就可以了，其中UpdateUtils.getLong()是一个SharedPreferences封装。以上两种方式在小米5Android N 上实测有效以上","tags":[{"name":"Android爬坑之旅","slug":"Android爬坑之旅","permalink":"http://www.huangyuanlove.com/tags/Android爬坑之旅/"},{"name":"Android N","slug":"Android-N","permalink":"http://www.huangyuanlove.com/tags/Android-N/"}]},{"title":"JVM内存区域","date":"2017-03-27T10:00:21.000Z","path":"2017/03/27/JVM内存区域/","text":"Java虚拟机在执行Java程序的过程中会把它所管理的内存划分为若干个不同的数据区域.这些区域都有各自的用途,以及创建和销毁的时间.有的区域随着虚拟机进程的启动而存在,有些区域则依赖用户线程的启动和结束而建立和销毁.根据《Java虚拟机规范(JavaSE 7版)》的规定,Java虚拟机所管理的内存将会包括以下几个运行时数据区域.如下所示: 程序计数器 程序计数器(Program Counter Register)是一块较小的内存空间,它可以看作是当前线程所执行的字节码的行号指示器.在虚拟机的概念模型里(仅是概念模型,各种虚拟机可能会通过一些更高效的方式去实现),字节码解释器工作时就是通过改变这个计数器的值来选取下一条需要执行的字节码指令,分支、循环、跳转、异常处理、线程恢复等基础功能都需要依赖这个计数器来完成.由于Java虚拟机的多线程是通过线程轮流切换并分配处理器执行时间的方式来实现的,在任何一个确定的时刻,一个处理器(对于多核处理器来说是一个内核)都只会执行一条线程中的指令.因此,为了线程切换后能恢复到正确的执行位置,每条线程都需要有一个独立的程序计数器,各条线程之间计数器互不影响,独立存储,我们称这类内存区域为”线程私有”的内存.如果线程正在执行的是一个Java方法,这个计数器记录的是正在执行的虚拟机字节码指令的地址;如果正在执行的是Native方法,这个计数器值则为空(Undefined).此内存区域是唯一一个在Java虚拟机规范中没有规定任何OutOfMemoryError情况的区域. Java虚拟机栈 与程序计数器一样,Java虚拟机栈(Java Virtual Machine Stacks)也是线程私有的,它的生命周期与线程相同.虚拟机栈描述的是Java方法执行的内存模型:每个方法在执行的同时都会创建一个栈帧(Stack Frame)用于存储局部变量表、操作数栈、动态链接、方法出口等信息.每一个方法从调用直至执行完成的过程,就对应着一个栈帧在虚拟机栈中入栈到出栈的过程.经常有人把Java内存区分为堆内存(Heap)和栈内存(Stack),这种分法比较粗糙,Java内存区域的划分实际上远比这复杂. 这种划分方式的流行只能说明大多数程序员最关注的、与对象内存分配关系最密切的内存区域是这两块.所指的”栈”就是现在讲的虚拟机栈,或者说是虚拟机栈中局部变量表部分.局部变量表存放了编译期可知的各种基本数据类型(boolean、byte、char、short、int、float、long、double)、对象引用(reference类型,它不等同于对象本身,可能是一个指向对象起始地址的引用指针,也可能是指向一个代表对象的句柄或其他与此对象相关的位置)和returnAddress类型(指向了一条字节码指令的地址).其中64位长度的long和double类型的数据会占用2个局部变量空间(Slot),其余的数据类型只占用1个. 局部变量表所需的内存空间在编译期间完成分配,当进入一个方法时,这个方法需要在帧中分配多大的局部变量空间是完全确定的,在方法运行期间不会改变局部变量表的大小.在Java虚拟机规范中,对这个区域规定了两种异常状况:如果线程请求的栈深度大于虚拟机所允许的深度,将抛出StackOverflowError异常;如果虚拟机栈可以动态扩展(当前大部分的Java虚拟机都可动态扩展,只不过Java虚拟机规范中也允许固定长度的虚拟机栈),如果扩展时无法申请到足够的内存,就会抛出OutOfMemoryError异常. 本地方法栈 本地方法栈(Native Method Stack)与虚拟机栈所发挥的作用是非常相似的,它们之间的区别不过是虚拟机栈为虚拟机执行Java方法(也就是字节码)服务,而本地方法栈则为虚拟机使用到的Native方法服务. 在虚拟机规范中对本地方法栈中方法使用的语言、 使用方式与数据结构并没有强制规定,因此具体的虚拟机可以自由实现它. 甚至有的虚拟机(譬如Sun HotSpot虚拟机)直接就把本地方法栈和虚拟机栈合二为一. 与虚拟机栈一样,本地方法栈区域也会抛出StackOverflowError和OutOfMemoryError异常. Java堆 对于大多数应用来说,Java堆(Java Heap)是Java虚拟机所管理的内存中最大的一块.Java堆是被所有线程共享的一块内存区域,在虚拟机启动时创建.此内存区域的唯一目的就是存放对象实例,几乎所有的对象实例都在这里分配内存.这一点在Java虚拟机规范中的描述是:所有的对象实例以及数组都要在堆上分配,但是随着JIT编译器的发展与逃逸分析技术逐渐成熟,栈上分配、标量替换优化技术将会导致一些微妙的变化发生,所有的对象都分配在堆上也渐渐变得不是那么”绝对”了.Java堆是垃圾收集器管理的主要区域,因此很多时候也被称做”GC堆”(Garbage Collected Heap).从内存回收的角度来看,由于现在收集器基本都采用分代收集算法,所以Java堆中还可以细分为:新生代和老年代;再细致一点的有Eden空间、From Survivor空间、To Survivor空间等.从内存分配的角度来看,线程共享的Java堆中可能划分出多个线程私有的分配缓冲区(Thread Local Allocation Buffer,TLAB).不过无论如何划分,都与存放内容无关,无论哪个区域,存储的都仍然是对象实例,进一步划分的目的是为了更好地回收内存,或者更快地分配内存.根据Java虚拟机规范的规定,Java堆可以处于物理上不连续的内存空间中,只要逻辑上是连续的即可,就像我们的磁盘空间一样.在实现时,既可以实现成固定大小的,也可以是可扩展的,不过当前主流的虚拟机都是按照可扩展来实现的(通过-Xmx和-Xms控制). 如果在堆中没有内存完成实例分配,并且堆也无法再扩展时,将会抛出OutOfMemoryError异常. 方法区 方法区(Method Area)与Java堆一样,是各个线程共享的内存区域,它用于存储已被虚拟机加载的类信息、常量、静态变量、即时编译器编译后的代码等数据.虽然Java虚拟机规范把方法区描述为堆的一个逻辑部分,但是它却有一个别名叫做Non-Heap(非堆),目的应该是与Java堆区分开来.对于习惯在HotSpot虚拟机上开发、 部署程序的开发者来说,很多人都更愿意把方法区称为”永久代”(Permanent Generation),本质上两者并不等价,仅仅是因为HotSpot虚拟机的设计团队选择把GC分代收集扩展至方法区,或者说使用永久代来实现方法区而已,这样HotSpot的垃圾收集器可以像管理Java堆一样管理这部分内存,能够省去专门为方法区编写内存管理代码的工作.对于其他虚拟机(如BEA JRockit、 IBM J9等)来说是不存在永久代的概念的.原则上,如何实现方法区属于虚拟机实现细节,不受虚拟机规范约束,但使用永久代来实现方法区,现在看来并不是一个好主意,因为这样更容易遇到内存溢出问题(永久代有-XX:MaxPermSize的上限,J9和JRockit只要没有触碰到进程可用内存的上限,例如32位系统中的4GB,就不会出现问题),而且有极少数方法(例如String.intern())会因这个原因导致不同虚拟机下有不同的表现. 因此,对于HotSpot虚拟机,根据官方发布的路线图信息,现在也有放弃永久代并逐步改为采用Native Memory来实现方法区的规划了,在目前已经发布的JDK1.7的HotSpot中,已经把原本放在永久代的字符串常量池移出.Java虚拟机规范对方法区的限制非常宽松,除了和Java堆一样不需要连续的内存和可以选择固定大小或者可扩展外,还可以选择不实现垃圾收集.相对而言,垃圾收集行为在这个区域是比较少出现的,但并非数据进入了方法区就如永久代的名字一样”永久”存在了.这区域的内存回收目标主要是针对常量池的回收和对类型的卸载,一般来说,这个区域的回收”成绩”比较难以令人满意,尤其是类型的卸载,条件相当苛刻,但是这部分区域的回收确实是必要的.根据Java虚拟机规范的规定,当方法区无法满足内存分配需求时,将抛出OutOfMemoryError异常. 运行时常量池 运行时常量池(Runtime Constant Pool)是方法区的一部分. Class文件中除了有类的版本、字段、方法、接口等描述信息外,还有一项信息是常量池(Constant Pool Table),用于存放编译期生成的各种字面量和符号引用,这部分内容将在类加载后进入方法区的运行时常量池中存放.Java虚拟机对Class文件每一部分(自然也包括常量池)的格式都有严格规定,每一个字节用于存储哪种数据都必须符合规范上的要求才会被虚拟机认可、装载和执行,但对于运行时常量池,Java虚拟机规范没有做任何细节的要求,不同的提供商实现的虚拟机可以按照自己的需要来实现这个内存区域.不过,一般来说,除了保存Class文件中描述的符号引用外,还会把翻译出来的直接引用也存储在运行时常量池中.运行时常量池相对于Class文件常量池的另外一个重要特征是具备动态性,Java语言并不要求常量一定只有编译期才能产生,也就是并非预置入Class文件中常量池的内容才能进入方法区运行时常量池,运行期间也可能将新的常量放入池中,这种特性被开发人员利用得比较多的便是String类的intern()方法.既然运行时常量池是方法区的一部分,自然受到方法区内存的限制,当常量池无法再申请到内存时会抛出OutOfMemoryError异常. 直接内存 直接内存(Direct Memory)并不是虚拟机运行时数据区的一部分,也不是Java虚拟机规范中定义的内存区域.但是这部分内存也被频繁地使用,而且也可能导致OutOfMemoryError异常出现,所以我们放到这里一起讲解.在JDK 1.4中新加入了NIO(New Input/Output)类,引入了一种基于通道(Channel)与缓冲区(Buffer)的I/O方式,它可以使用Native函数库直接分配堆外内存,然后通过一个存储在Java堆中的DirectByteBuffer对象作为这块内存的引用进行操作.这样能在一些场景中显著提高性能,因为避免了在Java堆和Native堆中来回复制数据.显然,本机直接内存的分配不会受到Java堆大小的限制,但是,既然是内存,肯定还是会受到本机总内存(包括RAM以及SWAP区或者分页文件)大小以及处理器寻址空间的限制.服务器管理员在配置虚拟机参数时,会根据实际内存设置-Xmx等参数信息,但经常忽略直接内存,使得各个内存区域总和大于物理内存限制(包括物理的和操作系统级的限制),从而导致动态扩展时出现OutOfMemoryError异常. 以上","tags":[{"name":"JVM","slug":"JVM","permalink":"http://www.huangyuanlove.com/tags/JVM/"},{"name":"Java","slug":"Java","permalink":"http://www.huangyuanlove.com/tags/Java/"}]},{"title":"Android的消息机制","date":"2017-03-23T06:00:09.000Z","path":"2017/03/23/Android的消息机制/","text":"Android消息机制主要是指Handler的运行机制，Handler的运行需要底层的MessageQueue和Looper的支撑。MessageQueue的中文翻译是消息队列，他的内部存储了一组消息，以队列的形式对外提供插入和删除的工作。虽然叫消息队列，但是它的内部存储结构并不是真正的队列，而是采用单链表的数据机构来存储消息队列，但是它的内部存储结构并不是真正的队列，而是采用单链表的数据结构来存储消息列表。Looper可以理解为消息循环。由于MessageQueue只是一个消息的存储单元，它不能去处理消息，而Looper就填补了这个功能，Looper会以无限昏眩的形式去查找是否有新消息，如果有的话就处理消息，否则就等待。Looper中海油一个特殊的概念，那就是ThreadLocal，ThreadLocal并不是现成，它的作用是可以在每个现成中存储数据。Handler创建的时候会采用当前线程的Looper来构造消息循环系统，ThreadLocal可以在不同的线程中互不干扰的存储并提供数据，Handler可以通过ThreadLocal轻松获取每个现成的Looper。需要注意的是，现成默认是没有Looper的，如果需要使用Handler就必须为现成创建Looper，我们经常提到的主线程，也叫UI线程，它就是ActivityThread，ActivityThread被创建时就会初始化Looper，这也是在主线程中默认可以使用Handler的原因。 ThreadLocal的工作原理ThreadLocal是一个县城内部的数据存储类，通过它可以在制定的线程中存储数据，数据存储以后，只能在制定的线程中才可以获取到存储的数据，对于其他线程来说则无法获取到，我们在使用的时候：1234567891011121314151617final ThreadLocal&lt;Boolean&gt; mBooleanThreadLocal = new ThreadLocal&lt;&gt;(); new Thread(\"Thread#1\")&#123; @Override public void run() &#123; mBooleanThreadLocal.set(false); Log.d(\"huangyuan\",\"Thread#1\" + mBooleanThreadLocal.get()); &#125; &#125;.start(); new Thread(\"Thread#2\")&#123; @Override public void run() &#123; mBooleanThreadLocal.set(true); Log.d(\"huangyuan\",\"Thread#2\" + mBooleanThreadLocal.get()); &#125; &#125;.start(); 这样，我们虽然在不同的线程中访问的是同一个ThreadLocal对象，但是他们的值确是不一样的。这是因为不同的线程访问同一个ThreadLocal的get方法，ThreadLocal内部会从各自的线程中取出一个数组，然后再从数组中根据当前ThreadLocal的索引去查找出对应的value值。ThreadLocal是一个泛型类，定义为public class ThreadLocal&lt;T&gt;,首先看ThreadLocal的set方法，如下：12345678public void set(T value) &#123; Thread t = Thread.currentThread(); ThreadLocalMap map = getMap(t); if (map != null) map.set(this, value); else createMap(t, value); &#125; 上面的方法中，首先会通过getMap方法获取ThreadLocalMap（存储线程的ThreadLocal数据），ThreadLocalMap是ThreadLocal类的静态内部类，其内部包含了一个静态内部类Entry，声明如下static class Entry extends WeakReference&lt;ThreadLocal&gt;,ThreadLocalMap类中有一个Entry类型的数组private Entry[] table;,下面是set方法的具体实现：1234567891011121314151617181920212223242526272829303132private void set(ThreadLocal key, Object value) &#123; // We don't use a fast path as with get() because it is at // least as common to use set() to create new entries as // it is to replace existing ones, in which case, a fast // path would fail more often than not. Entry[] tab = table; int len = tab.length; int i = key.threadLocalHashCode &amp; (len-1); for (Entry e = tab[i]; e != null; e = tab[i = nextIndex(i, len)]) &#123; ThreadLocal k = e.get(); if (k == key) &#123; e.value = value; return; &#125; if (k == null) &#123; replaceStaleEntry(key, value, i); return; &#125; &#125; tab[i] = new Entry(key, value); int sz = ++size; if (!cleanSomeSlots(i, sz) &amp;&amp; sz &gt;= threshold) rehash(); &#125; ThreadLocal的get方法如下：12345678910public T get() &#123; Thread t = Thread.currentThread(); ThreadLocalMap map = getMap(t); if (map != null) &#123; ThreadLocalMap.Entry e = map.getEntry(this); if (e != null) return (T)e.value; &#125; return setInitialValue(); &#125; 从ThreadLocal的set和get方法可以看出，他们所操作的对象都是当前线程的ThreadLocalMap对象的table数组，因此在不同线程中访问同一个ThreadLocal的set和get方法，他们对ThreadLocal所做的读写操作仅限于各自线程的内部，这就是为什么ThreadLocal可以在多个线程中互不干扰的存储和修改数据。 消息队列的工作原理 消息队列在Android中指的是MessageQueue，MessageQueue主要包含两个操作，插入和读取。读取操作本身会伴随着删除操作，插入和读取对应的方法分别为enqueueMessage和next，其中enqueueMessage的作用是往消息队列中插入一跳消息，而next的作用是从消息队列中取出一条消息并将其从消息队列中移除，尽管MessageQueue叫消息队列，但是它的内部实现并不是用的队列，实际上它是通过一个单链表的数据结构来维护消息列表，单链表在插入和删除上比较有优势。下面是enqueueMessage的实现：1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253boolean enqueueMessage(Message msg, long when) &#123; if (msg.target == null) &#123; throw new IllegalArgumentException(\"Message must have a target.\"); &#125; if (msg.isInUse()) &#123; throw new IllegalStateException(msg + \" This message is already in use.\"); &#125; synchronized (this) &#123; if (mQuitting) &#123; IllegalStateException e = new IllegalStateException( msg.target + \" sending message to a Handler on a dead thread\"); Log.w(TAG, e.getMessage(), e); msg.recycle(); return false; &#125; msg.markInUse(); msg.when = when; Message p = mMessages; boolean needWake; if (p == null || when == 0 || when &lt; p.when) &#123; // New head, wake up the event queue if blocked. msg.next = p; mMessages = msg; needWake = mBlocked; &#125; else &#123; // Inserted within the middle of the queue. Usually we don't have to wake // up the event queue unless there is a barrier at the head of the queue // and the message is the earliest asynchronous message in the queue. needWake = mBlocked &amp;&amp; p.target == null &amp;&amp; msg.isAsynchronous(); Message prev; for (;;) &#123; prev = p; p = p.next; if (p == null || when &lt; p.when) &#123; break; &#125; if (needWake &amp;&amp; p.isAsynchronous()) &#123; needWake = false; &#125; &#125; msg.next = p; // invariant: p == prev.next prev.next = msg; &#125; // We can assume mPtr != 0 because mQuitting is false. if (needWake) &#123; nativeWake(mPtr); &#125; &#125; return true; &#125; 从其实现来安，主要操作其实就是单链表的插入操作。next的实现如下：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105Message next() &#123; // Return here if the message loop has already quit and been disposed. // This can happen if the application tries to restart a looper after quit // which is not supported. final long ptr = mPtr; if (ptr == 0) &#123; return null; &#125; int pendingIdleHandlerCount = -1; // -1 only during first iteration int nextPollTimeoutMillis = 0; for (;;) &#123; if (nextPollTimeoutMillis != 0) &#123; Binder.flushPendingCommands(); &#125; nativePollOnce(ptr, nextPollTimeoutMillis); synchronized (this) &#123; // Try to retrieve the next message. Return if found. final long now = SystemClock.uptimeMillis(); Message prevMsg = null; Message msg = mMessages; if (msg != null &amp;&amp; msg.target == null) &#123; // Stalled by a barrier. Find the next asynchronous message in the queue. do &#123; prevMsg = msg; msg = msg.next; &#125; while (msg != null &amp;&amp; !msg.isAsynchronous()); &#125; if (msg != null) &#123; if (now &lt; msg.when) &#123; // Next message is not ready. Set a timeout to wake up when it is ready. nextPollTimeoutMillis = (int) Math.min(msg.when - now, Integer.MAX_VALUE); &#125; else &#123; // Got a message. mBlocked = false; if (prevMsg != null) &#123; prevMsg.next = msg.next; &#125; else &#123; mMessages = msg.next; &#125; msg.next = null; if (DEBUG) Log.v(TAG, \"Returning message: \" + msg); msg.markInUse(); return msg; &#125; &#125; else &#123; // No more messages. nextPollTimeoutMillis = -1; &#125; // Process the quit message now that all pending messages have been handled. if (mQuitting) &#123; dispose(); return null; &#125; // If first time idle, then get the number of idlers to run. // Idle handles only run if the queue is empty or if the first message // in the queue (possibly a barrier) is due to be handled in the future. if (pendingIdleHandlerCount &lt; 0 &amp;&amp; (mMessages == null || now &lt; mMessages.when)) &#123; pendingIdleHandlerCount = mIdleHandlers.size(); &#125; if (pendingIdleHandlerCount &lt;= 0) &#123; // No idle handlers to run. Loop and wait some more. mBlocked = true; continue; &#125; if (mPendingIdleHandlers == null) &#123; mPendingIdleHandlers = new IdleHandler[Math.max(pendingIdleHandlerCount, 4)]; &#125; mPendingIdleHandlers = mIdleHandlers.toArray(mPendingIdleHandlers); &#125; // Run the idle handlers. // We only ever reach this code block during the first iteration. for (int i = 0; i &lt; pendingIdleHandlerCount; i++) &#123; final IdleHandler idler = mPendingIdleHandlers[i]; mPendingIdleHandlers[i] = null; // release the reference to the handler boolean keep = false; try &#123; keep = idler.queueIdle(); &#125; catch (Throwable t) &#123; Log.wtf(TAG, \"IdleHandler threw exception\", t); &#125; if (!keep) &#123; synchronized (this) &#123; mIdleHandlers.remove(idler); &#125; &#125; &#125; // Reset the idle handler count to 0 so we do not run them again. pendingIdleHandlerCount = 0; // While calling an idle handler, a new message could have been delivered // so go back and look again for a pending message without waiting. nextPollTimeoutMillis = 0; &#125; &#125; 可以返现next方法是一个无线循环的方法，如果消息队列为空，那么next方法会一直阻塞在这里，当有消息到来时，next方法会返回这条消息并将其从单链表中移除 Looper的工作原理 Looper在Android的消息机制中扮演者消息循环的角色，具体来说就是它会不停地从MessageQueue中查看是否有新消息，如果有新消息就会立刻处理，否则就一直阻塞在那里。首先看一下它的构造方法，在构造中它会创建一个MessageQueue也就是消息队列，然后将当前线程的对象保存起来，如下：1234private Looper(boolean quitAllowed) &#123; mQueue = new MessageQueue(quitAllowed); mThread = Thread.currentThread(); &#125; Handler的工作需要Looper，没有Looper的线程就会报错，我们可以通过Looper.prepare()即可为当前线程创建一个Looper，接着通过Looper.loop()来开启消息循环。Looper除了prepare方法外，还提供了prepareMainLoop方法，这个方法主要是给主线程也就是ActivityThread创建Looper使用的，其本质也是通过prepare方法来实现的。由于主线程的Looper比较特殊，所有Looper提供了一个getMainLooper方法，通过它可以在任何地方获取到主线程的Looper。Looper也是可以退出的，Looper提供了quit个quitSafely来退出一个Looper，二者的区别是：quit会直接突出Looper，而quitSafely只是设定一个退出标记，然后把消息队列中的已有消息处理完毕后才安全的退出。Looper退出后，通过Handler发送的消息会失败，这个时候Handler的send方法会返回false。在子线程中，如果手动为其创建了Looper，那么在所有的事情完成以后应该调用quit方法来总之消息循环，否则这个子线程就会一直处于等待的状态，而如果退出Looper以后，这个县城就会立刻终止，因此甲乙不需要的时候终止Looper。 Looper最重要的一个方法是loop方法，只有调用了loop后，消息循环系统才会真正的起作用，实现如下： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960/** * Run the message queue in this thread. Be sure to call * &#123;@link #quit()&#125; to end the loop. */ public static void loop() &#123; final Looper me = myLooper(); if (me == null) &#123; throw new RuntimeException(\"No Looper; Looper.prepare() wasn't called on this thread.\"); &#125; final MessageQueue queue = me.mQueue; // Make sure the identity of this thread is that of the local process, // and keep track of what that identity token actually is. Binder.clearCallingIdentity(); final long ident = Binder.clearCallingIdentity(); for (;;) &#123; Message msg = queue.next(); // might block if (msg == null) &#123; // No message indicates that the message queue is quitting. return; &#125; // This must be in a local variable, in case a UI event sets the logger final Printer logging = me.mLogging; if (logging != null) &#123; logging.println(\"&gt;&gt;&gt;&gt;&gt; Dispatching to \" + msg.target + \" \" + msg.callback + \": \" + msg.what); &#125; final long traceTag = me.mTraceTag; if (traceTag != 0) &#123; Trace.traceBegin(traceTag, msg.target.getTraceName(msg)); &#125; try &#123; msg.target.dispatchMessage(msg); &#125; finally &#123; if (traceTag != 0) &#123; Trace.traceEnd(traceTag); &#125; &#125; if (logging != null) &#123; logging.println(\"&lt;&lt;&lt;&lt;&lt; Finished to \" + msg.target + \" \" + msg.callback); &#125; // Make sure that during the course of dispatching the // identity of the thread wasn't corrupted. final long newIdent = Binder.clearCallingIdentity(); if (ident != newIdent) &#123; Log.wtf(TAG, \"Thread identity changed from 0x\" + Long.toHexString(ident) + \" to 0x\" + Long.toHexString(newIdent) + \" while dispatching to \" + msg.target.getClass().getName() + \" \" + msg.callback + \" what=\" + msg.what); &#125; msg.recycleUnchecked(); &#125; &#125; loop方法是一个死循环，唯一跳出循环的方式是MessageQueue的next方法返回了null，当Looper的quit方法被调用时，Looper就会通知消息队列退出，当消息队列被标记为退出状态时，它的next方法就会返回null，也就是说，Looper必须退出，否则loop方法就会无限循环下去，loop方法会调用MessageQueue的next方法来获取新消息，而next方法是一个阻塞操作，当没有消息时，next方法会一直阻塞在那里，这也导致loop方法一直阻塞在那里，如果MessageQueue的next方法返回了新消息，Looper就会处理这条消息， msg.target.dispatchMessage(msg)，这里的 msg.target是发送这条消息的handler对象，这样Handler发送的消息最终又交个它的 dispatchMessage(msg);方法来处理了，但是这里不同的是，Handler的dispatchMessahe方法是在创建Handler时所使用的Looper中执行的，这样就成功的将代码逻辑切换到指定的线程中去执行了。 Handler的工作原理 Handler的工作主要包含消息的发送和接收过程。消息的发送可以通过post的一系列方法以及send的一系列方法来实现，post的一系列方法最终是通过send的一列方法来实现的。发送一条消息的典型过程如下： 12345678910111213141516171819202122232425262728 public final boolean sendMessage(Message msg) &#123; return sendMessageDelayed(msg, 0); &#125;public final boolean sendMessageDelayed(Message msg, long delayMillis) &#123; if (delayMillis &lt; 0) &#123; delayMillis = 0; &#125; return sendMessageAtTime(msg, SystemClock.uptimeMillis() + delayMillis); &#125;public boolean sendMessageAtTime(Message msg, long uptimeMillis) &#123; MessageQueue queue = mQueue; if (queue == null) &#123; RuntimeException e = new RuntimeException( this + \" sendMessageAtTime() called with no mQueue\"); Log.w(\"Looper\", e.getMessage(), e); return false; &#125; return enqueueMessage(queue, msg, uptimeMillis); &#125;private boolean enqueueMessage(MessageQueue queue, Message msg, long uptimeMillis) &#123; msg.target = this; if (mAsynchronous) &#123; msg.setAsynchronous(true); &#125; return queue.enqueueMessage(msg, uptimeMillis); &#125; 可以发现，Handler发送消息的过程仅仅是向消息队列中插入了一条消息，MessageQueue的next方法就会返回这条消息给Looper，Looper收到消息后就开始处理了，最终消息由Looper交由Handler处理，即Handler的dispatchMessage方法会被调用，这时Handler就是进入了处理消息的阶段。dispatchMessage的实现如下： 123456789101112public void dispatchMessage(Message msg) &#123; if (msg.callback != null) &#123; handleCallback(msg); &#125; else &#123; if (mCallback != null) &#123; if (mCallback.handleMessage(msg)) &#123; return; &#125; &#125; handleMessage(msg); &#125;&#125; Handler处理消息的过程如下： 检查Message的callback是否为null，不为null就通过handleCallback来处理消息，Message的callback是一个Runnable对象，实际上就是Handler的post方法所传递的Runnable参数。handleCallback的逻辑如下： 123private static void handleCallback(Message message) &#123; message.callback.run(); &#125; 其次，检查mCallback是否为null，不为null就调用没CallBack的HandlerMessage方法来处理消息，Callback是个接口，它的定义如下： /** * Callback interface you can use when instantiating a Handler to avoid * having to implement your own subclass of Handler. * * @param msg A {@link android.os.Message Message} object * @return True if no further handling is desired */ public interface Callback { public boolean handleMessage(Message msg); } 通过Callback可以采用如下方式来创建Handler对象：Handler handler = new Handler(callback)。 最后，调用Handler的handleMessahe方法来处理消息。 以上","tags":[{"name":"Android","slug":"Android","permalink":"http://www.huangyuanlove.com/tags/Android/"}]},{"title":"Window和WindowManager","date":"2017-03-21T12:05:01.000Z","path":"2017/03/21/Window和WindowManager/","text":"Window表示一个窗口的概念，在日常开发中直接接触WIndow的机会并不对，再试在某些特殊时候我们需要在桌面上显示一个类似悬浮窗的东西，那么这种效果就需要用到Window来实现。 Window只是个抽象类，它的具体实现是PhoneWindow。创建一个Window是很简单的事，只需要通过WindowManager即可完成，WindowManager是外界访问Window的入口，Window的具体实现位于WindowMangerService中，WindowMnager和WindowManager的交互是一个IPC过程，Android中所有的视图都是通过Window来呈现的，不管是Activity、Dialog还是Toast，它们的视图实际上都是附加在Window上的，因此Window实际是View的直接管理者。 Window的内部机制 Window是一个抽象的概念，每一个Window都对应着一个View和一个ViewRootImpl，Window和View通过ViewRootImpl来建立联系，因此Window并不是实际存在的，它是以View的形式存在，。这点从WindowManager的定义也可以看出，它提供的三个接口方法addView,updateViewLayout以及removeView都是针对View，这说明View才是Window存在的实体。在实际使用中无法直接访问Window，对Window的访问必须通过WindowManger。 Window的添加过程 Window的添加过程需要通过WindowManager的addView来实现，WindowManager是一个接口，它的真正实现是WindowManagerImpl类，在WindowManagerImpl中Window的三大操作实现如下：123456789101112131415161718192021@Override public void addView(@NonNull View view, @NonNull ViewGroup.LayoutParams params) &#123; applyDefaultToken(params); mGlobal.addView(view, params, mContext.getDisplay(), mParentWindow); &#125; @Override public void updateViewLayout(@NonNull View view, @NonNull ViewGroup.LayoutParams params) &#123; applyDefaultToken(params); mGlobal.updateViewLayout(view, params); &#125;@Override public void removeView(View view) &#123; mGlobal.removeView(view, false); &#125; @Override public void removeViewImmediate(View view) &#123; mGlobal.removeView(view, true); &#125; WindowManagerImpl并没有直接实现Window的三大操作，而是全部交给了WindowManagerGlobal来处理，WindowManagerGlobal以工厂的形式向外提供自己的实现，WindowManagerImpl这种工作模式是典型的桥接模式，将所有的操作全部委托给WindowManagerGlobal来实现。在WindowManagerGlobal的addView方法主要分为如下几步： 检查参数是否合法，如果是子Window，那么还需要调整一些布局参数。 1234567891011121314151617181920212223242526public void addView(View view, ViewGroup.LayoutParams params, Display display, Window parentWindow) &#123; if (view == null) &#123; throw new IllegalArgumentException(\"view must not be null\"); &#125; if (display == null) &#123; throw new IllegalArgumentException(\"display must not be null\"); &#125; if (!(params instanceof WindowManager.LayoutParams)) &#123; throw new IllegalArgumentException(\"Params must be WindowManager.LayoutParams\"); &#125; final WindowManager.LayoutParams wparams = (WindowManager.LayoutParams) params; if (parentWindow != null) &#123; parentWindow.adjustLayoutParamsForSubWindow(wparams); &#125; else &#123; // If there's no parent, then hardware acceleration for this view is // set from the application's hardware acceleration setting. final Context context = view.getContext(); if (context != null &amp;&amp; (context.getApplicationInfo().flags &amp; ApplicationInfo.FLAG_HARDWARE_ACCELERATED) != 0) &#123; wparams.flags |= WindowManager.LayoutParams.FLAG_HARDWARE_ACCELERATED; &#125; &#125;&#125; 创建ViewRootImpl并将View添加到列表中。在WindowManagerGlobal内部有如下几个列表比较重要： 12345private final ArrayList&lt;View&gt; mViews = new ArrayList&lt;View&gt;(); private final ArrayList&lt;ViewRootImpl&gt; mRoots = new ArrayList&lt;ViewRootImpl&gt;(); private final ArrayList&lt;WindowManager.LayoutParams&gt; mParams = new ArrayList&lt;WindowManager.LayoutParams&gt;(); private final ArraySet&lt;View&gt; mDyingViews = new ArraySet&lt;View&gt;(); 在以上声明中，mView存储的是多有WIndow所对应的View,mRoots存储的是所有Window所对应的ViewRootImpl，mParams存储的是所有Window所对应的布局参数，而mDyingView则存储了那些正在被删除的View对象，或者说是那些已经调用removeView方法但是删除操作还未完成的Window对象，在addView中通过如下方式将Window的一系列对象添加到列表中：12345root = new ViewRootImpl(view.getContext(), display); view.setLayoutParams(wparams); mViews.add(view); mRoots.add(root); mParams.add(wparams); 通过ViewRootImpl来更新界面并完成Window的添加过程。这个过程由ViewRootImpl的setView方法来完成：12345678910111213// do this last because it fires off messages to start doing things try &#123; root.setView(view, wparams, panelParentView); &#125; catch (RuntimeException e) &#123; // BadTokenException or InvalidDisplayException, clean up. synchronized (mLock) &#123; final int index = findViewLocked(view, false); if (index &gt;= 0) &#123; removeViewLocked(index, true); &#125; &#125; throw e; &#125; 在setView内部会通过requestLayout来完成异步刷新请求。在下面的代码中，scheduleTraversals实际是View绘制的入口：12345678@Override public void requestLayout() &#123; if (!mHandlingLayoutInLayoutRequest) &#123; checkThread(); mLayoutRequested = true; scheduleTraversals(); &#125; &#125; 接着会通过WindowSession最终来完成Window的添加过程。 Window的删除过程Window的删除过程和添加过程一样，都是先通过WindowManagerImpl后，再进一步通过WindowManagerGlobal来实现的，如下：1234567891011121314151617public void removeView(View view, boolean immediate) &#123; if (view == null) &#123; throw new IllegalArgumentException(\"view must not be null\"); &#125; synchronized (mLock) &#123; int index = findViewLocked(view, true); View curView = mRoots.get(index).getView(); removeViewLocked(index, immediate); if (curView == view) &#123; return; &#125; throw new IllegalStateException(\"Calling with view \" + view + \" but the ViewAncestor is attached to \" + curView); &#125; &#125; removeView的逻辑很清晰，首先通过findViewLocked来查找待删除的View的索引，这个查找过程就是建立的数据遍历，然后再通过调用removeViewLocked来做进一步的删除，如下：123456789101112131415161718private void removeViewLocked(int index, boolean immediate) &#123; ViewRootImpl root = mRoots.get(index); View view = root.getView(); if (view != null) &#123; InputMethodManager imm = InputMethodManager.getInstance(); if (imm != null) &#123; imm.windowDismissed(mViews.get(index).getWindowToken()); &#125; &#125; boolean deferred = root.die(immediate); if (view != null) &#123; view.assignParent(null); if (deferred) &#123; mDyingViews.add(view); &#125; &#125; &#125; removeViewLocked是通过ViewRootImpl来完成删除操作的，在WindowManager中提供了两种删除接口removeView和removeViewImmediate,它们分别表示异步删除和同步删除，一般不需要使用removeViewImmediate这个方法。这里主要说异步删除的情况：具体的删除操作由ViewRootImpl的die方法来完成，在异步删除的情况下，die方法只是发送了一个请求删除的消息后就立刻返回了，这个时候View并没有完成删除操作，所以最后会将其添加到mDyingView中。ViewRootImpl的die方法如下：1234567891011121314151617boolean die(boolean immediate) &#123; // Make sure we do execute immediately if we are in the middle of a traversal or the damage // done by dispatchDetachedFromWindow will cause havoc on return. if (immediate &amp;&amp; !mIsInTraversal) &#123; doDie(); return false; &#125; if (!mIsDrawing) &#123; destroyHardwareRenderer(); &#125; else &#123; Log.e(mTag, \"Attempting to destroy the window while drawing!\\n\" + \" window=\" + this + \", title=\" + mWindowAttributes.getTitle()); &#125; mHandler.sendEmptyMessage(MSG_DIE); return true; &#125; 在die方法中只是做了简单的判断，如果是异步删除，那么就发送一个MSG_DIE的消息，ViewRootImpl中的Handler会处理此消息并调用doDie方法，如果是同步删除，那么就不发送消息直接调用doDie方法。在doDie内部会调用dispatchDetachedFromWindow方法，真正删除View的逻辑在dispatchDetachedFromWindow方法内部实现。dispatchDetachedFromWindow方法主要做四件事： 垃圾回收相关的工作，比如清除数据和消息，移除回调等。 通过Session的remove方法删除Window：mWindowSession.remove(mWindow)，这同样是一个IPC过程，最终会调用WindowManagerService的removeWindow方法。 调用View的dispatchDetachedFromWindow方法，在内部会调用View的onDetachedFromWindow以及onDetachedFromWindowInternal()。 调用WindowManagerGlobal的doRemoveView方法刷新数据，包括mRoots、mParams以及mDyingViews，需要将当前Window锁关联的这三类对象从列表中删除。Window的更新过程1234567891011121314151617181920public void updateViewLayout(View view, ViewGroup.LayoutParams params) &#123; if (view == null) &#123; throw new IllegalArgumentException(\"view must not be null\"); &#125; if (!(params instanceof WindowManager.LayoutParams)) &#123; throw new IllegalArgumentException(\"Params must be WindowManager.LayoutParams\"); &#125; final WindowManager.LayoutParams wparams = (WindowManager.LayoutParams)params; view.setLayoutParams(wparams); synchronized (mLock) &#123; int index = findViewLocked(view, true); ViewRootImpl root = mRoots.get(index); mParams.remove(index); mParams.add(index, wparams); root.setLayoutParams(wparams, false); &#125; &#125; 首先它需要更新View的LayoutParams并替换掉老的LayoutParams，接着再更新ViewRootImpl中的layoutParams，这一步是通过ViewRootImpl的setLayoutParams方法来实现的。在ViewRootImpl中会通过scheduleTraversals方法来对View重新布局，包括测量、布局、重绘这三个过程，除了View本身的重绘以外，ViewRootImpl还会通过WindowSession开更新Window的视图，这个过程最终是由WindowManagerService的relayoutWindow()来具体实现，它同样是一个IPC的过程。 以上","tags":[{"name":"Android","slug":"Android","permalink":"http://www.huangyuanlove.com/tags/Android/"}]},{"title":"简单的桌面小部件","date":"2017-03-20T03:51:11.000Z","path":"2017/03/20/简单的桌面小部件/","text":"实现一个简单的桌面小部件，响应点击事件，更新等功能。 定义小部件界面 定义小部件配置信息 定义小部件的实现类 声明小部件在AndroidStudio中只需要在main\\java下新建一个widget,就可以了，IDE会自动在res\\layout添加布局文件，在res\\xml下新建配置信息文件。然后就可以进行具体实现了。 定义小部件界面RemoteView目前并不能支持所有的View，现在支持的类型如下： Layout FrameLayout LinearLayout RelativeLayout GridLayout View AnalogClock Button Chronometer ImageButton ImageView ProgressBar TextView ViewFlipper ListView GridView StackView AdapterViewFlipper ViewStub 这个没什么好说的，按照写界面布局的方式写就好了，但是不建议写过于复杂的布局。 定义小部件配置信息下面的代码就是IDE自动成的配置信息文件，不喜欢IDE代劳的同学可以自己创建。12345678910&lt;?xml version=\"1.0\" encoding=\"utf-8\"?&gt;&lt;appwidget-provider xmlns:android=\"http://schemas.android.com/apk/res/android\" android:initialKeyguardLayout=\"@layout/test_remote_view_widget\" android:initialLayout=\"@layout/test_remote_view_widget\" android:minHeight=\"40dp\" android:minWidth=\"40dp\" android:previewImage=\"@drawable/example_appwidget_preview\" android:resizeMode=\"horizontal|vertical\" android:updatePeriodMillis=\"86400000\" android:widgetCategory=\"home_screen\"&gt;&lt;/appwidget-provider&gt; initialLayout：布局文件previewImage： 预览的图片updatePeriodMillis：刷新周期，单位毫秒 定义小部件的实现类实现的功能是当点击这个小部件的时候改变文字内容12345678910111213141516171819202122232425public class TestRemoteViewWidget extends AppWidgetProvider &#123; private static final String CLICK_ACTION = \"com.huangyuan.testwidget.TAP_CLICK_ACTION\"; @Override public void onReceive(Context context, Intent intent) &#123; super.onReceive(context, intent); Toast.makeText(context,\"onReceive:\" + intent.getAction(),Toast.LENGTH_SHORT).show(); if(intent.getAction().equals(CLICK_ACTION))&#123; AppWidgetManager appWidgetManager = AppWidgetManager.getInstance(context); RemoteViews remoteViews = new RemoteViews(context.getPackageName(),R.layout.test_remote_view_widget); remoteViews.setTextViewText(R.id.appwidget_text,\"点击\"); appWidgetManager.updateAppWidget(new ComponentName(context,TestRemoteViewWidget.class),remoteViews); &#125; &#125; @Override public void onUpdate(Context context, AppWidgetManager appWidgetManager, int[] appWidgetIds) &#123; Toast.makeText(context,\"onUpdate\" ,Toast.LENGTH_SHORT).show(); RemoteViews remoteViews = new RemoteViews(context.getPackageName(),R.layout.test_remote_view_widget); Intent clickIntent = new Intent(); clickIntent.setAction(CLICK_ACTION); PendingIntent pendingIntent = PendingIntent.getBroadcast(context,0,clickIntent,0); remoteViews.setOnClickPendingIntent(R.id.appwidget_text,pendingIntent); appWidgetManager.updateAppWidget(appWidgetIds,remoteViews); &#125;&#125; 其中还有其他方法： onEnabled:当该窗口小部件第一次添加到桌面时调用该方法，可添加多次，但只在第一次调用 onUpdate:小部件被添加时或者每次小部件更新时都会调用一次该方法，小部件的更新时机由updatePeriodMillis指定。 onDeleted:每删除一次桌面小部件就调用一次。 onDisabled:当最后一个该类型的桌面小部件被删除时调用该方法，追时最后一个。需要注意的是，更新remoteView时，不能直接访问里面的View,需要通过RemoteView所提供的一系列方法更新View。 更新文本： remoteViews.setTextViewText(); 更新图片： remoteViews.setImageViewResource();remoteViews.setImageViewBitmap(); 添加单击事件：remoteViews.setOnClickPendingIntent();","tags":[{"name":"Android","slug":"Android","permalink":"http://www.huangyuanlove.com/tags/Android/"}]},{"title":"通过简单的自定义view来看View的工作流程","date":"2017-03-18T06:54:01.000Z","path":"2017/03/18/通过简单的自定义view来看View的工作流程/","text":"通过简单的自定义View(画个圆)，来了解一下View的工作流程以及自定义View应该注意的地方。 一、自定义View的分类1.1 继承View重写onDraw方法这种方法主要用于实现一些不规则的效果，比如动态或者静态显示一些不规则的图形，采用这种方式需要自己支持wrap_content,并且padding需要自己处理. 1.2 继承ViewGroup派生特殊的Layout这种方式主要用于实现自定义布局，如流式布局。采用这种方式需要合适的处理ViewGroup的测量、布局这两个过程，并同时处理子元素的测量和布局过程。 1.3 继承特定的View(如TextView)这种方法一般用于扩展某种已有的View的功能，比如TextView，这种方法比较容易实现，不需要自己支持wrap_content和padding。 1.4 继承特定的ViewGroup采用这种方式不需要自己处理ViewGroup的测量和布局这两个过程。 二、值得注意的地方2.1 让View支持wrap_content这是因为直接继承View或者ViewGroup的控件，如果不在onMeasure中对wrap_content做特殊处理，那么当外界在适用wrap_content时就无法达到预期的效果。 2.2 如果有必要，让View支持padding这是因为如果直接继承View，如果不在draw方法中处理padding，那么padding属性是无法起作用的。另外，直接继承自ViewGroup的控件需要在onMeasure和onLayout中考虑padding和子元素的margin对其造成的影响，不然将导致padding和子元素的margin失效。 2.3 尽量不要在View中使用Handler，没必要因为View内部本身就提供了post系列的方法， 完全可以替代Handler的作用，当然除非你很明确要使用Handler来发送消息 2.4 及时停止动画和线程如果需要停止线程或者动画，可以在onDetachedFromWindow方法中处理，当包含此View的Activity退出或者当前View被remove时，View的onDetachedFromWindow方法会被调用，和此方法对应的是onAttachedToWindow，当包含此View的Activity启动时，View的onAttachedToWindow方法会被调用。 2.5 View带有滑动嵌套情形时，需要处理好滑动冲突如果有滑动冲突的话，那么要合适的处理滑动冲突，否则将会严重影响View的效果。 三、自定义View3.1 继承View重写onDraw方法首先来看一下代码1234567891011121314151617181920212223242526272829303132public class TestCustomCircleView extends View &#123; private int color = Color.RED; private Paint paint; public TestCustomCircleView(Context context) &#123; super(context); init(); &#125; public TestCustomCircleView(Context context, AttributeSet attrs) &#123; super(context, attrs); init(); &#125; public TestCustomCircleView(Context context, AttributeSet attrs, int defStyleAttr) &#123; super(context, attrs, defStyleAttr); init(); &#125; private void init()&#123; paint = new Paint(); paint.setColor(color); &#125; @Override protected void onDraw(Canvas canvas) &#123; super.onDraw(canvas); int width = getWidth(); int height = getHeight(); int radius = Math.min(width,height)/2; canvas.drawCircle(width/2,height/2,radius,paint); &#125;&#125; 上面的代码只是一种初级的实现，当我们进行使用的时候，只支持margin属性，并不支持padding属性。对onDraw方法进行修改，只要在绘制的时候考虑一下padding即可。123456789101112@Override protected void onDraw(Canvas canvas) &#123; super.onDraw(canvas); int paddingLeft = getPaddingLeft(); int paddingRight = getPaddingRight(); int paddingTop = getPaddingTop(); int paddingBottom = getPaddingBottom(); int width = getWidth() - paddingLeft - paddingRight; int height = getHeight() - paddingBottom - paddingTop; int radius = Math.min(width, height) / 2; canvas.drawCircle(paddingLeft + width / 2, paddingTop + height / 2, radius, paint); &#125; 但是现在还不能支持warp_content属性，现在使用wrap_content和使用match_parent没有任何区别：对于直接继承自View的控件，如果不对wrap_content做特殊处理，那么使用wrap_content就相当于使用match_parent.这里就需要我们重写onMeasure方法，当宽高属性为wrap_content时，取一个默认值。123456789101112131415161718192021222324252627282930@Overrideprotected void onMeasure(int widthMeasureSpec, int heightMeasureSpec) &#123; int desiredWidth = 100; int desiredHeight = 100; int widthMode = MeasureSpec.getMode(widthMeasureSpec); int widthSize = MeasureSpec.getSize(widthMeasureSpec); int heightMode = MeasureSpec.getMode(heightMeasureSpec); int heightSize = MeasureSpec.getSize(heightMeasureSpec); int width; int height; //宽度 if (widthMode == MeasureSpec.AT_MOST) &#123; width = Math.min(desiredWidth, widthSize); &#125; else if (widthMode == MeasureSpec.EXACTLY) &#123; width = widthSize; &#125; else &#123; width = desiredWidth; &#125; //高度 if (heightMode == MeasureSpec.AT_MOST) &#123; height = Math.min(desiredHeight, heightSize); &#125; else if (heightMode == MeasureSpec.EXACTLY) &#123; height = heightSize; &#125; else &#123; height = desiredHeight; &#125; setMeasuredDimension(width, height);&#125; 这样，当我们使用wrap_content时，就是使用默认的100px的值。 四、使用自定义属性4.1 创建自定义的配置文件在values目录下面创建自定义属性的XML，比如attrs.xml，也可以选择类似于attrs_circleview.xml等这种以attrs开头的文件名，当然这个文件名并没有什么限制，可以随便取名字。我们选择创建attrs.xml文件。12345&lt;resources&gt; &lt;declare-styleable name=\"TestCustomCircleView\"&gt; &lt;attr name=\"circle_color\" format=\"color\"/&gt; &lt;/declare-styleable&gt;&lt;/resources&gt; 4.2 在构造方法中解析自定义的属性值并做相应的处理1234567public TestCustomCircleView(Context context, AttributeSet attrs, int defStyleAttr) &#123; super(context, attrs, defStyleAttr); TypedArray typedArray = context.obtainStyledAttributes(attrs, R.styleable.TestCustomCircleView); color = typedArray.getColor(R.styleable.TestCustomCircleView_circle_color,Color.RED); typedArray.recycle(); init();&#125; 首先加载自定义属性集合，接着解析属性集合中TestCustomCircleView_circle_color，如果没有指定属性值，则使用Color.RED作为默认值。 4.3 在布局文件中使用自定义属性&lt;com.example.huangyuan.custom.TestCustomCircleView android:layout_width=\"wrap_content\" android:layout_height=\"wrap_content\" android:layout_gravity=\"center_horizontal\" app:circle_color=\"@color/grey\" /&gt;","tags":[{"name":"Android","slug":"Android","permalink":"http://www.huangyuanlove.com/tags/Android/"}]},{"title":"View的滑动","date":"2017-03-15T03:01:46.000Z","path":"2017/03/15/View的滑动/","text":"View的位置主要由它的四个顶点来决定，分别对应于View的四个属性：top,left,right,bottom,其中top是左上角的纵坐标，left是左上角的横坐标，right是右下角的横坐标，bottom是右下角的纵坐标。需要注意的是，这些坐标都是相当于View的父容器来说的，因此它是一种相对坐标，View的坐标和父容器的关系如下所示： width = right - leftheight = bottom - topleft = getLeft()right = getRight()top = getTop()bottom = getBottom()从Android3.0 开始，View增加了额外的几个参数：x,y,trabslationX和translationY。其中x和y是View左上角的坐标，而translationX和translationY是View左上角相对于父容器的偏移量。这几个参数也是相对于父容器的坐标，并且translationX和translationY的默认值是0，和View的四个基本的位置参数一样，View也为他们提供了get/set方法，这几个参数的换算关系如下x = left + translationX需要注意的是，View在平移过程中，top和left表示的是原始左上角的位置信息，其值并不会发生改变，此时发生改变的是x,y,translationX和translationY。 一 VelocityTracker 和 GestureDetector速度最终，用于追踪手指在滑动过程中的速度，包括水平和竖直方向的速度。使用方法在View的onTouchEvent方法中追踪当前单击事件的速度：12VelocityTracker velocityTracker = VelocityTracker.obtain();velocityTracker.addMovement(event); 接着，当我们想知道当前的滑动速度时，这个时候可以采用如下方式来获得当前速度：123velocityTracker.computeCurrentVelocity(1000);float xVelocity = velocityTracker.getXVelocity();float yVelocity = velocityTracker.getYVelocity(); 在这一步中有两点需要注意 获取速度之前必须先计算速度，即getXVelocity()和getYVelocity()之前必须调用computeCurrentVelocity(1000) 这里的速度时指一段时间内手指所划过的像素数，速度可以是负数，当手指在水平方向从左向右滑动时，速度为正，反之为负数。最后，当不在使用它的时候，需要调用clear方法来重置并回收内存:12velocityTracker.clear();velocityTracker.recycle(); 手势检测，用于辅助检测用户的单击、滑动、长按、双击等行为。首先创建GestureDetector的对象，接着接管View的onTouchEvent方法。做完下面两部，就可以有选择的实现接口中的方法了123GestureDetector gestureDetector = new GestureDetector(this,this); gestureDetector.setIsLongpressEnabled(false); return gestureDetector.onTouchEvent(event); 其中gestureDetector.setIsLongpressEnabled(false)是为了解决长按之后无法拖动的现象。 二 使用ScrollTo/ScrollBy调用方式 View.scrollTo(int x, int y),View.scrollBy(int x, int y)方法源码：12345678910111213141516171819202122232425262728293031/** * Set the scrolled position of your view. This will cause a call to * &#123;@link #onScrollChanged(int, int, int, int)&#125; and the view will be * invalidated. * @param x the x position to scroll to * @param y the y position to scroll to */ public void scrollTo(int x, int y) &#123; if (mScrollX != x || mScrollY != y) &#123; int oldX = mScrollX; int oldY = mScrollY; mScrollX = x; mScrollY = y; invalidateParentCaches(); onScrollChanged(mScrollX, mScrollY, oldX, oldY); if (!awakenScrollBars()) &#123; postInvalidateOnAnimation(); &#125; &#125; &#125; /** * Move the scrolled position of your view. This will cause a call to * &#123;@link #onScrollChanged(int, int, int, int)&#125; and the view will be * invalidated. * @param x the amount of pixels to scroll by horizontally * @param y the amount of pixels to scroll by vertically */ public void scrollBy(int x, int y) &#123; scrollTo(mScrollX + x, mScrollY + y); &#125; 从源码中可以看出，scrollBy实际上也是调用scrollBy的方法。需要注意的是在View的滑动过程中，mScrollX和mScrollY的改变规则：在滑动过程中，mScrollX的值总是等于View左边缘和View内容左边缘在水平方向的距离，而mScrollY的值总是等于View上边缘和View内容上边缘在竖直方向的距离。其中mScrollX和mScrollY的单位是像素，并且当View左边缘在View内容左边缘的右边时，mScrollX为正值，反之为负值；当View上边缘在View内容上边缘的下边时，mScrollY为正值，反之为负值。换句话说：从左向右滑动，mScrollX为负值，反之为正值；如果从上往下滑动，mScrollY为负值，反之为正值。意思就是说ScrollTo/ScrollBy只能滑动View的内容而不能滑动View本身，比如，只能滑动TextView的文字，而不能滑动TextView控件本身 三 使用动画这个没什么好介绍的，想要兼容3.0以下的属性动画，建议使用nineoldandroids来实现 四 改变布局参数改变布局参数，也就是改变·LayoutParams· 五 使用Scroller进行平滑移动自定义一个控件，添加成员变量·Scroller·，如下：123456789101112131415161718192021222324252627282930313233343536373839public class ScrollerTextView extends TextView &#123; private Scroller mScroller; public ScrollerTextView(Context context) &#123; super(context); mScroller = new Scroller(context); &#125; public ScrollerTextView(Context context, AttributeSet attrs) &#123; super(context, attrs); mScroller = new Scroller(context); &#125; public ScrollerTextView(Context context, AttributeSet attrs, int defStyleAttr) &#123; super(context, attrs, defStyleAttr); mScroller = new Scroller(context); &#125; public void smoothScrollBy(int dx,int dy)&#123; mScroller.startScroll(mScroller.getFinalX(),mScroller.getFinalY(),dx,dy,2000); invalidate(); &#125; public void smoothScrollTo(int fx, int fy)&#123; int dx = fx - mScroller.getFinalX(); int dy = fy - mScroller.getFinalY(); smoothScrollBy(dx,dy); &#125; @Override public void computeScroll() &#123; if(mScroller.computeScrollOffset())&#123; scrollTo(mScroller.getCurrX(), mScroller.getCurrY()); postInvalidate(); &#125; super.computeScroll(); &#125;&#125; 其实Scroller也是通过ScrollTO/ScrollBy实现的，同样只能滑动内容，不能滑动本身。PS：在调用startScroll时，并没有让View进行滑动。而是在调用invalidate()进行重绘的时候，会去调用computeScroll方法，但是computeScroll在View只是个空实现，因此需要我们自己去实现。在computeScroll中进行平移。也就是说当View重绘后在draw方法中调用computeScroll,而computeScroll又会去向Scroller获取当前的scrollX和scrollY,然后通过scrollTo方法实现滑动，接着又调用postInvalidate()方法来进行第二次重绘，这一次重绘过程和第一次一样，还是会去调用computeScroll()方法，如此反复，直到整个滑动过程结束。 以上","tags":[{"name":"Android","slug":"Android","permalink":"http://www.huangyuanlove.com/tags/Android/"}]},{"title":"《我的安卓爬坑之旅》-高德地图遇到的坑(2)","date":"2017-02-25T03:57:23.000Z","path":"2017/02/25/《我的安卓爬坑之旅》-高德地图遇到的坑-2/","text":"这篇博客是关于高德使用中遇到的问题，或许是因为开发文档中没有说明，或许是因为自己段位不够，反正就是遇到坑了。 关于定位点和覆盖物 有这么一个业务需求：定位手机所在位置成功后，请求服务器数据，服务器返回手机所在地点指定范围内的的点，然后把这些点添加到地图上。刚开始还没有什么问题，按照官网的demo来做的，到后来数据量多的时候就出现了marker重叠的问题。当然，marker点多的话，重叠也是无法避免的，但是，把定位的标记也给覆盖掉了，这就有点不好了。也没有查到相关的api，demo上添加定位点也是用的marker，估计都是同一级别，按照添加的先后顺序覆盖叠加。后来找到了一个方法 mLocMarker.setToTop();这样可以把某个marker设置到最高的层级显示。还有一个方法是123456public void setDisplayLevel(int var1) &#123; IMarkerAction var2 = this.a.getIMarkerAction(); if(var2 != null) &#123; var2.setDisplayLevel(var1); &#125;&#125; 这个是Marker对象中的一个方法，但是从官方下载下来的文档中并没有提到这个方法，自己也没有去使用。了解过的朋友可以在评论区回复我一下，谢谢。 AndroidStudio第二次编译之后地图不显示 AS2.2版本加了 Instant Run 模式，通常情况下这回节省我们很多时间，比如当我们修改了界面布局，想要在手机上看一下效果，没有必要重启整个应用，这个时候就可以使用 Instant Run 模式了，ide内部会进行判断是否需要重启整个应用，如果不需要，只会热重启当前页面。为这个功能点赞啊，有的时候页面藏的比较深，需要多步操作才能打开，这个功能可以节省很多时间。但是啊但是。。。我在Fragment中使用高德地图的时候，使用这个功能会出现地图加载不出来（一片空白），但是定位成功的问题。刚开始的是吓尿了，以为代码出了什么问题，直到我提了工单，看到回复后放心了： 您好，Instant Run 确实是不支持这种，目前他们也没有给出解决方案，这里有详细的解释http://stackoverflow.com/questions/33902467/android-studio-2-0-why-does-instant-run-not-work-when-modifying-xml-layout-reso感谢您的致信，欢迎持续关注高德开放平台！ 地图加载完成的回调函数因为业务上的原因，需要在地图加载完成后做一些操作，当时官网的开发者文档上没有啊，于是又提了工单，接到回复后又放心了 您好，AMap 提供了地图加载完成的方法， 可详见：12345aMap.setOnMapLoadedListener(new AMap.OnMapLoadedListener() &#123; @Override public void onMapLoaded() &#123; &#125; &#125;); 感谢您的致信，欢迎持续关注高德开放平台！ 步行路径规划当距离比较短时路线不在地图中间位置 由于业务上的原因，自己的位置和目的地的距离较短，需要步行路径规划，但是啊但是，路径可以规划成功，但是把路径添加到地图上的时候，路径没有显示在屏幕中间位置啊，而是诡异的飘到了一边。反复检查了N边代码，没有问题啊，和官网demo一样啊，把坐标点抠出来，改一下官网demo的起始点(就是两个坐标值),然后，也出现了路径飘到一边的情况，于是又去提了万能的工单，看到工单的回复后，我又放心了 我：Demo是从官网的demo上改的，就在om.amap.map3d.demo.route包下的WalkRouteActivity这个类里面，改了一下mStartPoint，和 mEndPoint 的值，附件图片是我修改之后的值 private LatLonPoint mStartPoint = new LatLonPoint(39.990145, 116.481194);private LatLonPoint mEndPoint = new LatLonPoint(39.99026006391499, 116.4813472288069);从官网下载回来后只改了这两个地方，把key换成了自己的，其他地方的代码没有动。如果可以的话，你们可以试一下，找两个距离非常近的点。答复：您好，这个问题确实是由SDK内部处理不当引起的bug，我们会在下个版本中修复，给您带来不便深表歉意感谢您的致信，欢迎持续关注高德开放平台！ 解决方法：判断两个点的距离，小于500米的时候，取起始点位置连线的中间位置作为地图中间点，强制将地图上的此位置拉到屏幕中间。 以上","tags":[{"name":"Android爬坑之旅","slug":"Android爬坑之旅","permalink":"http://www.huangyuanlove.com/tags/Android爬坑之旅/"},{"name":"Android","slug":"Android","permalink":"http://www.huangyuanlove.com/tags/Android/"},{"name":"高德地图","slug":"高德地图","permalink":"http://www.huangyuanlove.com/tags/高德地图/"}]},{"title":"写在2016年末","date":"2016-12-31T15:29:04.000Z","path":"2016/12/31/写在2016年末/","text":"2016年的最后一天的最后半个小时了，写写这一年的收获总结和2017的计划吧。一个字总结了一下2016年：穷。当然这是开玩笑式的总结，但也是最接近事实的了。 2016总结技术方面：&nbsp;&nbsp;&nbsp;&nbsp;自从踏上IT这条不归路开始，就打算做一个全栈攻城狮，从敲下第一行hello world到自己独立用java写一个完整的大作业再到写出实际可用的程序到现在的工作，仔细想想已经五年多了吧。但是这仅仅是个开始，我对自己现在的定位是全栈攻城狮的道路刚刚慢出第一步，现在也就算是个全栈学徒吧。 编程技能自定级别python入门HTML初级J2EE初级JAVA中级Android中级Linux中级 在工作中也踩过、填过、挖过很多坑，万幸的是一直坚持了下来，没有放弃，也没有想过要转行的事，就想一直在这个行业发展，努力提高自己的技术。 15年双十二和今年的十二月四号，都参加了开源中国举办的源创汇年终盛典，接触到了很多大牛(虽然他们不曾记得我)，接触到很多以前没有见识过也没有想象过的东西，对自己的成长有很大帮助。 开通了自己的博客(gitpage),把博客从csdn迁移到github上，租用了腾讯云主机，备案了自己的域名，有了自己的简单的网站，可以写一些自己感兴趣的东西(自由的感觉真好，法无禁止皆可为)。 也感谢这一年来小伙伴的帮助，幸好有你们，帮我解决了困难。 当然，在这一年中也有很多事情不是那么顺利，从上家公司离职，从10月到12月，中间休息了两个月，回了一次家，跑去深圳和妹子玩了四五天的样子(几乎是全部时间都泡在图书馆了，沉迷学习无法自拔)，其余时间也就是看看书，打打游戏之类的，总之这两个月的时间大部分都被浪费掉了，没有任何收获。 生活上也没啥好说的，业余时间就是宅在家里，看看书，敲敲代码，打打游戏，不喜欢出去逛，貌似好像是在6、7月份的样子，二哥来北京玩，爬了一次八达岭长城，除此之外，就是去了三次漫展，其他的就没有什么了。 2017计划首先，最重要的就是提升自己的技术能力： python达到初级水平;html方面学习一下h5; J2EE方面学习一下ssm框架、nginx; JAVA和Android方面尽可能的提升自己，尽量在两年内能初步达到高级水平; Linux方面，熟悉一下vim，了解以下服务器方向的相关知识，毕竟自己只是拿linux做开发，没有把精力放在服务器假设方向。 生活方面就尽量改变一下自己宅的属性,尽量多出去走走吧(这个有点难，比提升技术实力还要难) 借用一本小说中的一段话吧： “其实所有的智慧生物都在饮鸩止渴。所有的智慧生物都在通过不断的科技进步，不断的探索未知来满足着自己的探索欲望。这些科技，以及理论还有知识，不是好东西，它们是毒药，它们会让文明形成强烈的依赖症，当所有的未知都被探索完毕的时候，这种鸩毒就会最终发作，并且让这个文明最终陷入到毒发身亡的境地之中。可是最可笑的是，虽然这个道理十分明显，可是包括我在内的所有文明，都无法逃脱这个怪圈。” “我……我怎么可以停止呢？就算它们明明是毒药，可是我也要不断的去吃啊。”萧宇喃喃自语着，“如果我的科技不能进步，如果现在就斩断我进步的道路，我现在就会发疯的。这一点是天生注定的，当我还在地球上的时候，当我拿起笔，拿起书本，学习到第一个数学公式，学习到第一个物理定理的时候，这种鸩毒就已经在我的灵魂深处深深的扎下了根，让我终其一生不得解脱。我的毒瘾会越来越大，我所需要的鸩毒分量会越来越多，我只能继续这样维持下去。以后再毒发，总比现在就毒发要好。” 这个死在旅途之中的文明，让萧宇想到了很多很多，对萧宇的灵魂造成了很深的触动。可是萧宇已经无法停下自己的脚步了。浩瀚广阔的星空，无边无际的宇宙，就像是美丽异常的罂粟花，明知道危险，可是还是有不计其数的文明，包括萧宇在内都踏了进去，并且一个个踊跃异常，生怕自己吸食毒品的速度要比其余的文明慢了一点。 以上。","tags":[{"name":"乱七八糟","slug":"乱七八糟","permalink":"http://www.huangyuanlove.com/tags/乱七八糟/"}]},{"title":"《我的安卓爬坑之旅》--高德地图遇到的坑","date":"2016-12-18T15:58:39.000Z","path":"2016/12/18/《我的安卓爬坑之旅》-高德地图遇到的坑-1/","text":"这篇博客是关于高德使用中遇到的问题，或许是因为开发文档中没有说明，或许是因为自己段位不够，反正就是遇到坑了。 ####生成key 生成key的时候，同一个app下，可以填入相同的包名、key名称等。注意不要用错了key 由于高德地图升级的原因，需要将原来没有整理过的key先整理，使其属于某个应用，才可以继续创建其他的key。 ####文档 仅在入门指南中提到了需要加入 &lt;service android:name=&quot;com.amap.api.location.APSService&quot;&gt;&lt;/service&gt;开发注意事项里面居然没有提到。最关键的是，没有加入这个service时，定位有时还能成功，只是不能连续定位。我看的时候时从开发注意事项开始看的，完全没有注意到这一点，后来在demo中看到了需要加入这个配置，才能生效。 文档里面只给出了部分关键代码和部分关键类，完全不知道这个类怎么实例化，怎么去调用方法，调用方法的时候需要传入哪种类型的参数。就我个人看来，看官方api文档还不如去看他们的demo，文档写的真心不算好。官方部分demo地址官方demo地址官方sdk以及开发文档、demo等相关下载官方sdk、开发文档以及demo以后遇到坑再补充吧，估计遇到的都是文档中没有标明但在demo中有示例的那种。","tags":[{"name":"Android爬坑之旅","slug":"Android爬坑之旅","permalink":"http://www.huangyuanlove.com/tags/Android爬坑之旅/"},{"name":"Android","slug":"Android","permalink":"http://www.huangyuanlove.com/tags/Android/"},{"name":"高德地图","slug":"高德地图","permalink":"http://www.huangyuanlove.com/tags/高德地图/"}]},{"title":"《我的安卓爬坑之旅》--融云IM遇到的坑","date":"2016-12-01T07:20:47.000Z","path":"2016/12/01/《我的安卓爬坑之旅》-融云IM遇到的坑/","text":"这篇博客是关于融云IM使用中遇到的问题，不算是坑，只能说是注意事项吧 后端向 在自己的应用”OurStories”中打算接入IM即时通讯功能，就使用了融云提供的sdk，需要自己写后台获取Token，这个比较简单，官方给出了Demo，按照自己的习惯，把demo里面的方法封装一下就可以使用了。 Token向 获取Token时可以在融云后台（登录自己帐号，控制台）可以设置Token有效期。 在初始情况下开发环境下最多只能有100个测试用户，当达到上限后可以点击添加用户的按钮，每次添加20人上限，生产环境没有上限。 开发环境和生产环境在融云后台是两套独立的环境，拥有不同的App Key和App Secret，当产品上线时不要忘记切换自己服务器和app的配置，另外，app的App Key和服务器端的App Key要一致。前端 Android向 由于集成融云的聊天界面个会话列表界面都是Fragment形式，在集成的过程中，包含该Fragment的Activity要继承自FragmentActivity，否则在开启聊天界面的时候会报如下异常： 1234Caused by: android.view.InflateException: Binary XML file line #6: Binary XML file line #6: Error inflating class fragment Caused by: android.view.InflateException: Binary XML file line #6: Error inflating class fragment Caused by: android.app.Fragment$InstantiationException: Trying to instantiate a class io.rong.imkit.fragment.ConversationFragment that is not a Fragment Caused by: java.lang.ClassCastException 融云在初始化的时候建议放在Applicatuon中进行，但是融云会开启3个进程，每个进程都会执行Application的OnCreate方法，建议在初始化自己的配置时检测以下进程，在自己的主进程中初始化自己的配置. 千万不要忘记配置包含融云Fragment的Activity的&lt;intent-filter&gt; 融云不同步也不会保存应用下的好友关系，需要自己的服务器保存 注意阅读融云的开发文档，注意每一个细节 有问题先去搜知识库，然后提工单。提工单的时候尽可能详细的描述自己的开发环境，遇到的问题以及异常日志。 非必要情况下，不要自己去反编译出融云的sdk，然后自己使用用其中的代码。","tags":[{"name":"Android爬坑之旅","slug":"Android爬坑之旅","permalink":"http://www.huangyuanlove.com/tags/Android爬坑之旅/"},{"name":"Android","slug":"Android","permalink":"http://www.huangyuanlove.com/tags/Android/"},{"name":"融云IM","slug":"融云IM","permalink":"http://www.huangyuanlove.com/tags/融云IM/"}]},{"title":"《我的安卓爬坑之旅》","date":"2016-11-21T08:07:25.000Z","path":"2016/11/21/《我的安卓爬坑之旅》/","text":"准备记录一下自己在工作学习中遇到的bug以及解决方案。不定期更新。内容包括但不限于android，J2EE，HTML，以及各种各样的需求。形式如下：bug：①出现bug的场景②尽可能放上代码③分析原因：源码及原理④解决方案：思路及尽可能的放上代码需求：①产品需求：尽可能详细描述产品需求，尽量能放上UI②分析可能的解决方案：思路③解决过程：自己的思路及解决方案和踩到的坑④解决方法：尽可能放上关键代码或者伪代码⑤其他：一些意想不到的事。 大家也可以发邮件到我的邮箱，把自己遇到的问题和大家分享一下email: huangyuan@huangyuanlove.com","tags":[{"name":"Android爬坑之旅","slug":"Android爬坑之旅","permalink":"http://www.huangyuanlove.com/tags/Android爬坑之旅/"},{"name":"android","slug":"android","permalink":"http://www.huangyuanlove.com/tags/android/"},{"name":"bug","slug":"bug","permalink":"http://www.huangyuanlove.com/tags/bug/"}]},{"title":"hexo+gitpage搭建自己的博客(三)","date":"2016-10-30T13:05:54.000Z","path":"2016/10/30/hexo-gitpage搭建自己的博客-三/","text":"前两篇介绍了怎么用gitpage+github搭建自己的博客，这次主要介绍怎么更换主题和加入评论、统计等。 更换主题首先将 yilia主题从github克隆到本地thems文件夹里面1git clone https://github.com/litten/hexo-theme-yilia.git themes/yilia 看一下当前博客目录的结构 其中_config.yml文件就是整个hexo系统的主配置文件另外刚才克隆的yilia主题就在thems文件夹下面首先修改根目录下的_config.yml文件，切换到yilia主题大概在文件的63-65行左右的位置1234# Extensions## Plugins: https://hexo.io/plugins/## Themes: https://hexo.io/themes/theme: yilia 将原来的theme后面的 landscape主题改成yilia重启服务后主题就切换到yilia了，下面是thems/yilia文件夹下的_config.yml文件的配置. 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566# Headermenu: 主页: / 简历: \"\"# SubNavsubnav: github: \"https://github.com/huangyuanlove\" #weibo: \"#\" #rss: \"#\" zhihu: \"https://www.zhihu.com/people/huangyuan_xuan\" #douban: \"#\" #mail: \"#\" #facebook: \"#\" #google: \"#\" #twitter: \"#\" #linkedin: \"#\"rss: /atom.xml# 是否需要修改 root 路径# 如果您的网站存放在子目录中，例如 http://yoursite.com/blog，# 请将您的 url 设为 http://yoursite.com/blog 并把 root 设为 /blog/。root:# Contentexcerpt_link: morefancybox: truemathjax: false# 是否开启动画效果animate: true# 是否在新窗口打开链接open_in_new: false# 自己添加的百度统计baidu_tongji: true# 网站iconfavicon: favicon.ico#你的头像urlavatar: \"\"#是否开启分享share_jia: falseshare_addthis: false#多说评论duoshuo:# 如不需要，将该项置为false# 比如#smart_menu:# friends: falsesmart_menu: innerArchive: '所有文章' tagcloud: '标签' #friends: '友链' aboutme: '关于我'friends:aboutme: &lt;a href=\"http://www.huangyuanlove.com\"&gt;什么懂都点的Android攻城狮&lt;/a&gt; 以上是yilia主题的配置说明接入百度统计首先到百度统计平台 申请一个帐号，按照提示填写完自己网站的信息，在网站中心左边栏点击代码获取，得到统计访问量的代码。新建themes/yilia/layout/_partial/baidu_tongji.ejs文件，内容如下：12345&lt;% if (theme.baidu_tongji) &#123; %&gt;&lt;script&gt; 统计访问量的代码&lt;/script&gt;&lt;% &#125; %&gt; 然后编辑themes/yilia/_config.yml文件，添加一行baidu_tongji: true，注意冒号后面有空格。编辑themes/yilia/layout/_partial/head.ejs 在 &lt;/head&gt; 前添加&lt;%- partial(&quot;baidu_tongji&quot;) %&gt;重启部署代码即可。安装完成20分钟后就可以在后台看到统计的信息了，如果看不到统计信息，请检查是否配置正确，检测方式点这里 http://tieba.baidu.com/p/3775626020以上是添加百度统计的方式添加多说评论到多说 申请帐号使用三方登录完成后，点击我要安装，根据提示填写完信息记住站点名称，将站点名称填入 thems/yilia/_config.yml文件里面多说评论之后，注意冒号后面有空格。保存重新部署就可以看到评论框了。至于评论样式，可以在后台管理页面中的设置选项中设置。后台管理中还可以管理评论内容，添加敏感词汇过滤等。以上是添加多说评论的过程。 以上","tags":[{"name":"hexo","slug":"hexo","permalink":"http://www.huangyuanlove.com/tags/hexo/"},{"name":"gitpage","slug":"gitpage","permalink":"http://www.huangyuanlove.com/tags/gitpage/"},{"name":"blog","slug":"blog","permalink":"http://www.huangyuanlove.com/tags/blog/"}]},{"title":"hexo+gitpage搭建自己的博客(二)","date":"2016-10-25T13:11:53.000Z","path":"2016/10/25/hexo-gitpage搭建自己的博客-二/","text":"之前我们已经安装好了hexo，接下来就是初始化了。123hexo init &lt;dir&gt;cd &lt;dir&gt;npm install 现在hexo就安装完成了，在存放hexo的文件夹目录下执行 hexo s，就可以启动hexo的服务，启动之后有提示，在浏览器中输入127.0.0.1:4000就可以看到最初的效果了，如下 对了，还要发布到github。前提准备是在上一篇中已经创建好了github的仓库。接下来在存放hexo资源的文件夹下(以下用 heox_blog这个文件夹代替)执行npm install hexo-deployer-git --save修改hexo_blog文件夹下的_config.yml文件在末尾添加1234deploy: type: git repository: git@github.com:your name/your name.github.io.git branch: master 注意，type，repository，branch冒号后面都有一个空格。保存后执行123hexo cleanhexo ghexo d 就可以将写好的博客部署到github上了。（部署到github时建议按照顺序执行以上命令） 12345hexo generate == hexo g --&gt;将md文件解析成静态的html文件hexo deploy == hexo d --&gt; 将文件部署到githubhexo server == hexo s --&gt; 启动本地hexo服务hexo clean --&gt; 清除缓存hexo new &quot;title&quot; --&gt; 创建新的文章，文件在`hexo_blog/source/_posts`文件夹下 以上","tags":[{"name":"hexo","slug":"hexo","permalink":"http://www.huangyuanlove.com/tags/hexo/"},{"name":"gitpage","slug":"gitpage","permalink":"http://www.huangyuanlove.com/tags/gitpage/"},{"name":"blog","slug":"blog","permalink":"http://www.huangyuanlove.com/tags/blog/"}]},{"title":"hexo+gitpage搭建自己的博客(一)","date":"2016-10-20T16:04:26.000Z","path":"2016/10/21/hexo-gitpage搭建自己的博客-一/","text":"不说环境直接写配置的行为都是耍流氓按照惯例,先说自己的环境:ubunu,然后就没有然后了. hexo类似wordpress的博客框架,gitpage是github的一个服务,请原谅我这个不大准确的表达,事实上真的差不多.安装hexo需要安装nodejs,使用gitpage需要git,至于如何安装git,在原来的csdn博客上有,点击这里 http://blog.csdn.net/huangyuan_xuan/article/details/49125597.之后需要在自己的github上创建一个仓库,名称结构如下:username.github.io,例如我的github主页是https://github.com/huangyuanlove,那么我的gitpage就是huangyuanlove.github.io.到这里,默认大家的gitpage和git已经配置好了,包括sshkey之类的东西. 我安装node是用nvm(node version manager)安装的,然后使用node中的npm(node package manager)安装hexo.windows下安装请转这里 https://github.com/coreybutler/nvm-windows首先安装nvm: wget -qO- https://raw.github.com/creationix/nvm/master/install.sh | sh 安装时间长短视网速而定,我安装了大概十多分钟,然后重启一下终端.然后使用 nvm ls-remote查看一下有哪些本版可以安装,我当时安装的最新版是6.6.0,现在不知道是哪一版,如下找一个合适的版本使用如下命令安装nvm install version,例如 nvm install 6.6.0,安装时间还是视网速而定,我也忘了装了多长时间了.安装完成之后是这样的之后npm install -g hexo安装hexo,-g参数是全局安装安装完成之后使用hexo -v查看hexo的版本号到此hexo安装完成,接下来就是初始化,进行配置了.下一篇再说吧,睡觉了. 以上.","tags":[{"name":"hexo","slug":"hexo","permalink":"http://www.huangyuanlove.com/tags/hexo/"},{"name":"gitpage","slug":"gitpage","permalink":"http://www.huangyuanlove.com/tags/gitpage/"},{"name":"blog","slug":"blog","permalink":"http://www.huangyuanlove.com/tags/blog/"}]},{"title":"如何获取csdn中个人所有文章标题及链接","date":"2016-10-19T14:32:42.000Z","path":"2016/10/19/如何获取csdn中个人所有文章标题及链接/","text":"小伙伴问如何把自己csdn上的文章标题和超链接都扒下来,问我是不是一个个点开之后抄过去的…当然不是,做为一个爱(sha)好(dou)广(dong)泛(dian)的程序员,怎么会用这么麻烦的方法. 本来打算写java模拟登录之后获取网页源码,然后再用jsoup去解析,得到自己需要的数据.原来就这么干过,好像是写学校的绩点计算器来着吧,就是输入帐号密码就能查到自己的成绩和绩点的那种.翻出来代码看了看太麻烦了,想到自己最近在看python,就想着用python来解决,但是问题又来了,python不熟啊,就算写出来了也得看网页源码,找到规律才行,讲道理的说挺烦这东西的.最后,还是用js来解决,毕竟这种事也干过,也不是多麻烦.登录自己的帐号,找到文章列表,打开控制台窗口,忘了说一下自己的环境了ubuntu,chrom,找到文章标题和超链接的部分,如下图:发现所有的文章标题和超链接结构如下:12345 &lt;span class=\"link_title\"&gt; &lt;a href=\"/huangyuan_xuan/article/details/51935666\"&gt; 初步编写IDEA\\AndroidStudio翻译插件 &lt;/a&gt;&lt;/span&gt; 另外,界面中还引入了jQuery这个三方库,这就更简单了:找到开发者工具的控制台(console),写入下面两行代码12345var aTags = $(\".link_title &gt; a\")for(var i = 0;i&lt;50;i++)&#123; console.log(\"[\" + aTags[i].text.trim() + \"](\" + aTags[i].href +\") \"+ aTags[i].href) +\"&lt;br/&gt;\" &#125; ok,执行结果如下 在控制台写的代码第一行是使用jQuery库找到所有文章的超链接集合,第二行是按照markdown超链接的语法打印出来文章标题和超链接,至于循环中的50这个数字,一页最多只有50篇文章,我偷懒了,建议使用aTags.length 以上","tags":[{"name":"csdn","slug":"csdn","permalink":"http://www.huangyuanlove.com/tags/csdn/"}]},{"title":"原CSDN博客","date":"2016-10-16T14:39:41.000Z","path":"2016/10/16/原CSDN博客/","text":"不打算在csdn上面写博客了,转到gitpage上面,自己用hexo搭建了博客系统.现在把原csdn的博客链接抄在下面 使用openfire搭建IM聊天系统(一) http://blog.csdn.net/huangyuan_xuan/article/details/52549416 浅谈使用单元素的枚举类型实现单例模式 http://blog.csdn.net/huangyuan_xuan/article/details/52193006 初步编写IDEA\\AndroidStudio翻译插件 http://blog.csdn.net/huangyuan_xuan/article/details/51935666 多线程 的理解（一） http://blog.csdn.net/huangyuan_xuan/article/details/50881452 运行时数据区域 http://blog.csdn.net/huangyuan_xuan/article/details/50570461 虚拟机字节码执行引擎 http://blog.csdn.net/huangyuan_xuan/article/details/50569443 虚拟机类加载机制 http://blog.csdn.net/huangyuan_xuan/article/details/50550725 垃圾收集器与内存分配策略 http://blog.csdn.net/huangyuan_xuan/article/details/50513881 JDK的一些命令行工具 http://blog.csdn.net/huangyuan_xuan/article/details/50513861 MongoDB基础 http://blog.csdn.net/huangyuan_xuan/article/details/50155345 tomcat图形化界面管理及数据源配置 http://blog.csdn.net/huangyuan_xuan/article/details/49859151 android 四大图片缓存原理、特性对比 http://blog.csdn.net/huangyuan_xuan/article/details/49362701 github分支管理 http://blog.csdn.net/huangyuan_xuan/article/details/49356523 github 远程仓库 http://blog.csdn.net/huangyuan_xuan/article/details/49356505 github建立本地与远程仓库的连接 http://blog.csdn.net/huangyuan_xuan/article/details/49336403 Git 本地版本控制 http://blog.csdn.net/huangyuan_xuan/article/details/49162309 安装github http://blog.csdn.net/huangyuan_xuan/article/details/49125597 ubuntu 14.04 apt-get install 不能自动补全解决办法 http://blog.csdn.net/huangyuan_xuan/article/details/48915299 String的一点小东西 http://blog.csdn.net/huangyuan_xuan/article/details/48116365 wireshark error: There are no interfaces on which a capture can be done. http://blog.csdn.net/huangyuan_xuan/article/details/46632395 windows下使用cmd（命令行）发送邮件 http://blog.csdn.net/huangyuan_xuan/article/details/46564319 Notepad++ 搭建java编译环境 http://blog.csdn.net/huangyuan_xuan/article/details/45936413 JVM虚拟机 http://blog.csdn.net/huangyuan_xuan/article/details/44537233 servlet向浏览器输出验证码图片 http://blog.csdn.net/huangyuan_xuan/article/details/43817631 ubuntu14.04开热点共享网络 http://blog.csdn.net/huangyuan_xuan/article/details/43759585 UNIX/linux的find命令细节 http://blog.csdn.net/huangyuan_xuan/article/details/43739353 编写shell时，提示let：not found http://blog.csdn.net/huangyuan_xuan/article/details/43490373 cmd命令大全 http://blog.csdn.net/huangyuan_xuan/article/details/42804537 华为 ap ac设备配置命令 http://blog.csdn.net/huangyuan_xuan/article/details/41647447 更改SQLserver的登录方式 http://blog.csdn.net/huangyuan_xuan/article/details/41085629 汇编FLAG寄存器简介 http://blog.csdn.net/huangyuan_xuan/article/details/40949147 汇编指令——转移指令 http://blog.csdn.net/huangyuan_xuan/article/details/40949119 汇编指令 http://blog.csdn.net/huangyuan_xuan/article/details/40949109 汇编寻址方式 http://blog.csdn.net/huangyuan_xuan/article/details/40949087 一段汇编小程序及说明——将数据，代码，栈放入不同的段 http://blog.csdn.net/huangyuan_xuan/article/details/40949075 一段简单汇编语言程序及说明 http://blog.csdn.net/huangyuan_xuan/article/details/40949069 8086寄存器 http://blog.csdn.net/huangyuan_xuan/article/details/40949063 oracle创建实例化数据库或者连接别的远程主机数据库提示“无监听程序”的解决办法 http://blog.csdn.net/huangyuan_xuan/article/details/40857207 安装tomcat提示Faild to install Tomcat7 service 解决办法 http://blog.csdn.net/huangyuan_xuan/article/details/40821859 mysql事物处理和管理配置 http://blog.csdn.net/huangyuan_xuan/article/details/40821521 mysql 连接查询 http://blog.csdn.net/huangyuan_xuan/article/details/40783341 MySQL常用命令 http://blog.csdn.net/huangyuan_xuan/article/details/40783331 ubuntu下MySQL键值不支持中文解决办法 http://blog.csdn.net/huangyuan_xuan/article/details/40783317 Myeclipse新建webservice客户端 http://blog.csdn.net/huangyuan_xuan/article/details/39992799 MyEclips新建webservice http://blog.csdn.net/huangyuan_xuan/article/details/39992723 intellij IDEA更换主题为Darcula后中文项目名称变口（方框）的解决办法 http://blog.csdn.net/huangyuan_xuan/article/details/39896009 java模拟登录校内成绩查询网站，将获得的HTML代码用jsoup解析 http://blog.csdn.net/huangyuan_xuan/article/details/39723251 Ubuntu14.04 LTS更新源 http://blog.csdn.net/huangyuan_xuan/article/details/39119797 ubuntu14.04开机自动挂载windows磁盘的配置方法 http://blog.csdn.net/huangyuan_xuan/article/details/39118723 java实现MD5和sha1加密 http://blog.csdn.net/huangyuan_xuan/article/details/39081435 22 PPP协议 http://blog.csdn.net/huangyuan_xuan/article/details/38427607 21 串行接口封装 http://blog.csdn.net/huangyuan_xuan/article/details/38427547 20 internet connection http://blog.csdn.net/huangyuan_xuan/article/details/38427527 19 广域网 WAN http://blog.csdn.net/huangyuan_xuan/article/details/38423675 java的JDK的安装配置图文详解 http://blog.csdn.net/huangyuan_xuan/article/details/38405103 18 ACL访问控制列表（access control list） http://blog.csdn.net/huangyuan_xuan/article/details/38387045 17 NAT转换 http://blog.csdn.net/huangyuan_xuan/article/details/38342675 16 DHCP http://blog.csdn.net/huangyuan_xuan/article/details/38278825 Java常见错误列表 http://blog.csdn.net/huangyuan_xuan/article/details/37957229 LXLE Linux取代Windows XP的11个大招 http://blog.csdn.net/huangyuan_xuan/article/details/37937957 jQuery语法简介 http://blog.csdn.net/huangyuan_xuan/article/details/37738127 cookie简介 http://blog.csdn.net/huangyuan_xuan/article/details/37728211 DOM 简介 http://blog.csdn.net/huangyuan_xuan/article/details/37699891 vim 命令 http://blog.csdn.net/huangyuan_xuan/article/details/28880287 我们大神都这样——提问的智慧 http://blog.csdn.net/huangyuan_xuan/article/details/28276437 初学C语言的人看不懂的关机代码 http://blog.csdn.net/huangyuan_xuan/article/details/27972015 ubuntu连接路由器无线网络，却不能上网 http://blog.csdn.net/huangyuan_xuan/article/details/27792089 sublime-text2的中英文对照表（附带个人的配置习惯） http://blog.csdn.net/huangyuan_xuan/article/details/26969041 电脑蓝屏代码大全 http://blog.csdn.net/huangyuan_xuan/article/details/26246709 VC6.0 快捷键整理 http://blog.csdn.net/huangyuan_xuan/article/details/26245513 玩游戏无法全屏 http://blog.csdn.net/huangyuan_xuan/article/details/26245135 15 Ospf http://blog.csdn.net/huangyuan_xuan/article/details/26244991 14 EIGRP 配置 http://blog.csdn.net/huangyuan_xuan/article/details/26244541 13 ERGIP http://blog.csdn.net/huangyuan_xuan/article/details/26244439 12 rip-2 配置命令 http://blog.csdn.net/huangyuan_xuan/article/details/26244201 11 rip -1 http://blog.csdn.net/huangyuan_xuan/article/details/26244031 10动态路由 http://blog.csdn.net/huangyuan_xuan/article/details/26243735 9静态路由 http://blog.csdn.net/huangyuan_xuan/article/details/26243487 8网络拓扑结构 http://blog.csdn.net/huangyuan_xuan/article/details/26243293 7VLSM子网划分 http://blog.csdn.net/huangyuan_xuan/article/details/26243041 6常用网络相关命令 http://blog.csdn.net/huangyuan_xuan/article/details/26242799 5数据包发送流程 http://blog.csdn.net/huangyuan_xuan/article/details/26242589 网线 http://blog.csdn.net/huangyuan_xuan/article/details/26242183 osi七层网络模型4 http://blog.csdn.net/huangyuan_xuan/article/details/26242101 osi七层网络模型3 http://blog.csdn.net/huangyuan_xuan/article/details/26242015 osi七层网络模型2 http://blog.csdn.net/huangyuan_xuan/article/details/26241831 OSI七层网络模型1 http://blog.csdn.net/huangyuan_xuan/article/details/26241631 sublime-text2 编译java出错 Decode error - output not utf-8的解决办法 http://blog.csdn.net/huangyuan_xuan/article/details/26164349 安装虚拟机报错解决办法 TheVMware Authorization Service is not running http://blog.csdn.net/huangyuan_xuan/article/details/26162201 我的vim配置 http://blog.csdn.net/huangyuan_xuan/article/details/26162083 sublime text 2 搭建java运行环境 http://blog.csdn.net/huangyuan_xuan/article/details/26161983 ubuntu的一点命令 http://blog.csdn.net/huangyuan_xuan/article/details/26160973 以后主要就在gitpage上写博客了. 以上","tags":[{"name":"csdn","slug":"csdn","permalink":"http://www.huangyuanlove.com/tags/csdn/"}]},{"title":"2016年国庆-在深圳","date":"2016-10-08T04:42:33.000Z","path":"2016/10/08/2016国庆/","text":"国庆之前,辞了工作,跑到深圳找妹子玩了几天.妹子在哈工大深圳校区读研究生,去了之后也没有出去逛,吃饭,图书馆,写作业,折腾hexo写博客.也就在校园里逛了一下,拍了几张照片.在深圳市南山区的大学城里面,好像是有清华北大哈工大三所研究生院校组成的,据说哈工大深研院开始招本科生了.南门 ,没去其他的门,就从这边进去的,别问为啥,近. 哈工大深研院的标志?不知道是不是标志性建筑 图书馆,吐槽一下,图书馆的书好少.电梯的海报上面说是有电影放映,但是我们沉迷于学习无法自拔,理所当然的错过了. 图书馆门口的植物标本,我也不知道是啥,装作看懂的样子 食堂,食堂的饭菜还是不错的,听说非学校人员也能在里面办卡,只是比学生买饭要贵40%.表示理解. 北大汇丰商学院,就在图书馆旁边小树林里面有蛇,晚上去吃饭的时候路过的小树林,里面真的有蛇,亲眼所见,大概有食指粗细,一尺来长,黑灰色.可惜没拍到.清华大学深研院,不知道是不是这么叫的,吃完晚饭去瞻仰了一下 本打算去蹭课来着,但是看着妹子的作业就不想去了,我觉得我应该听不大懂. 就这些,待了貌似有四五天的样子,然后就滚回北京找工作了. 以上.","tags":[{"name":"乱七八糟","slug":"乱七八糟","permalink":"http://www.huangyuanlove.com/tags/乱七八糟/"}]}]