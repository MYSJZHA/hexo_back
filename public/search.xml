<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[Coordinatorlayout]]></title>
    <url>%2F2018%2F08%2F20%2FCoordinatorlayout%2F</url>
    <content type="text"><![CDATA[上图的动画其实挺简单的，如果你知道的话，就不要继续往下看了，那是在浪费时间。主要用的前几年推出的几个support包，可惜国内没有流行起来。 简单直接放代码：gradle依赖：123implementation 'com.android.support:appcompat-v7:28.0.0-rc01'implementation 'com.android.support.constraint:constraint-layout:1.1.2'implementation 'com.android.support:design:28.0.0-rc01' 布局文件：12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849&lt;?xml version="1.0" encoding="utf-8"?&gt;&lt;android.support.design.widget.CoordinatorLayout xmlns:android="http://schemas.android.com/apk/res/android" xmlns:app="http://schemas.android.com/apk/res-auto" android:layout_width="match_parent" android:fitsSystemWindows="true" android:layout_height="match_parent"&gt; &lt;android.support.design.widget.AppBarLayout android:layout_width="match_parent" android:layout_height="160dp" android:fitsSystemWindows="true" android:theme="@style/ThemeOverlay.AppCompat.ActionBar"&gt; &lt;android.support.design.widget.CollapsingToolbarLayout android:id="@+id/collapsingToolbarLayout" android:layout_width="match_parent" android:layout_height="match_parent" android:fitsSystemWindows="true" app:collapsedTitleTextAppearance="@style/TextAppearance.AppCompat.Title" app:contentScrim="?attr/colorPrimaryDark" app:expandedTitleMarginStart="48dp" app:expandedTitleTextAppearance="@style/TextAppearance.AppCompat.Title" app:layout_scrollFlags="scroll|exitUntilCollapsed"&gt; &lt;ImageView android:layout_width="match_parent" android:layout_height="wrap_content" android:fitsSystemWindows="true" android:scaleType="fitXY" android:src="@drawable/title_bg" app:layout_collapseMode="parallax" app:layout_collapseParallaxMultiplier="0.5" /&gt; &lt;android.support.v7.widget.Toolbar android:id="@+id/toolbar" android:layout_width="match_parent" android:layout_height="?attr/actionBarSize" /&gt; &lt;/android.support.design.widget.CollapsingToolbarLayout&gt; &lt;/android.support.design.widget.AppBarLayout&gt; &lt;android.support.v7.widget.RecyclerView android:id="@+id/recyclerview" android:layout_width="match_parent" android:layout_height="match_parent" app:layout_behavior="@string/appbar_scrolling_view_behavior" /&gt;&lt;/android.support.design.widget.CoordinatorLayout&gt; activity代码：12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667public class MainActivity extends AppCompatActivity &#123; private List&lt;String&gt; data = new ArrayList&lt;&gt;(); @Override protected void onCreate(Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); setContentView(R.layout.activity_main); Toolbar toolbar = findViewById(R.id.toolbar); setSupportActionBar(toolbar); CollapsingToolbarLayout collapsingToolbarLayout = findViewById(R.id.collapsingToolbarLayout); collapsingToolbarLayout.setTitle("Test CoordinatorLayout"); collapsingToolbarLayout.setContentScrimColor(Color.GRAY); collapsingToolbarLayout.setCollapsedTitleTextColor(ContextCompat.getColor(this,R.color.colorAccent)); collapsingToolbarLayout.setExpandedTitleColor(Color.WHITE); for(int i = 0 ; i &lt; 100 ;i ++)&#123; data.add("item -- &gt;" + i); &#125; RecyclerView recyclerView = findViewById(R.id.recyclerview); LinearLayoutManager linearLayoutManager = new LinearLayoutManager(MainActivity.this); linearLayoutManager.setOrientation(LinearLayoutManager.VERTICAL); recyclerView.setLayoutManager(linearLayoutManager); RecyclerViewAdapter adapter = new RecyclerViewAdapter(); recyclerView.setAdapter(adapter); &#125; class RecyclerViewAdapter extends RecyclerView.Adapter&lt;RecyclerViewAdapter.ViewHolder&gt;&#123; @NonNull @Override public ViewHolder onCreateViewHolder(@NonNull ViewGroup viewGroup, int i) &#123; View view = LayoutInflater.from(MainActivity.this).inflate(android.R.layout.simple_list_item_1,viewGroup,false); return new ViewHolder(view); &#125; @Override public void onBindViewHolder(@NonNull ViewHolder viewHolder, int i) &#123; viewHolder.textView.setText(data.get(i)); viewHolder.textView.setTextColor(ContextCompat.getColor(MainActivity.this,R.color.colorAccent)); &#125; @Override public int getItemCount() &#123; return data.size(); &#125; class ViewHolder extends RecyclerView.ViewHolder&#123; TextView textView; public ViewHolder(@NonNull View itemView) &#123; super(itemView); textView = itemView.findViewById(android.R.id.text1); &#125; &#125; &#125;&#125; 不想多写什么了，可以自己去搜这些东西的用法。傲娇脸~_~ 以上]]></content>
      <tags>
        <tag>Android</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[ConstraintLayout]]></title>
    <url>%2F2018%2F08%2F09%2FConstraintLayout%2F</url>
    <content type="text"><![CDATA[https://developer.android.google.cn/reference/android/support/constraint/ConstraintLayoutA ConstraintLayout is a ViewGroup which allows you to position and size widgets in a flexible way. 版本支持ConstraintLayout是一个支持库，向前兼容到Android9，以后还会添加更多的新特性。现在公司的产品的最低版本支持都在2.3之上，部分产品最低版本支持保持在4.4之上。这就意味着我们不需要关心最低版本支持的事情。 新特性在使用新特性的时候是不能有循环依赖的，比如相对定位，不能A依赖于B的位置，B依赖C的位置，而C又依赖A的位置 Relative positioning相对定位是ConstraintLayout中最基本的构建方式，也就是一个空间相对于另外一个空间进行位置确定，可以在横向和竖向上进行约束： Horizontal Axis: left, right, start and end sides Vertical Axis: top, bottom sides and text baseline 如果我们需要让ButtonB在ButtonA的右侧，如下图： 在布局文件中只需要：123&lt;Button android:id="@+id/buttonA" ... /&gt;&lt;Button android:id="@+id/buttonB" ... app:layout_constraintLeft_toRightOf="@+id/buttonA" /&gt; 这就告诉系统 让buttonB的左边约束于buttonA的右边下面列出了所有可用的约束方式： layout_constraintLeft_toLeftOf layout_constraintLeft_toRightOf layout_constraintRight_toLeftOf layout_constraintRight_toRightOf layout_constraintTop_toTopOf layout_constraintTop_toBottomOf layout_constraintBottom_toTopOf layout_constraintBottom_toBottomOf layout_constraintBaseline_toBaselineOf layout_constraintStart_toEndOf layout_constraintStart_toStartOf layout_constraintEnd_toStartOf layout_constraintEnd_toEndOf 各约束位置如下：上面这些约束关系全部都是本身相对于另外一个控件(使用@id方式引用另外控件)或者父布局(使用parent方式引用父控件)进行约束 Margins这里的外边距和其他布局方式的外边距一样，不能是负数，属性如下： android:layout_marginStart android:layout_marginEnd android:layout_marginLeft android:layout_marginTop android:layout_marginRight android:layout_marginBottom 添加的一个新属性是 maiginGone,当一个约束目标的可见性为GONE的时候(View.GONE)，可以改变当前控件的外边距，比如B是相对于A进行约束，当A不可见的时候，可以改变B的外边距，也就是B的外边距可以根据Ade可见性设置不同的值，属性如下 layout_goneMarginStart layout_goneMarginEnd layout_goneMarginLeft layout_goneMarginTop layout_goneMarginRight layout_goneMarginBottom Centering positioning and bias Centering Positioning 如果对一个控件的左右(上下)都添加的约束，那么ConstraintLayout的表现就像有两个大小相等方向相反的力在拉这个控件一个样，比如12345&lt;android.support.constraint.ConstraintLayout ...&gt; &lt;Button android:id="@+id/button" ... app:layout_constraintLeft_toLeftOf="parent" app:layout_constraintRight_toRightOf="parent/&gt;&lt;/&gt; 表现如下：这样就会产生居中效果，如果子控件和父控件的尺寸相同，这写属性就没有意义了 bias 当遇到上面这种约束的时候，我们可以使用bias属性让控件偏向于哪一个方向,属性如下： layout_constraintHorizontal_bias layout_constraintVertical_bias例如，如下代码：123456&lt;android.support.constraint.ConstraintLayout ...&gt; &lt;Button android:id="@+id/button" ... app:layout_constraintHorizontal_bias="0.3" app:layout_constraintLeft_toLeftOf="parent" app:layout_constraintRight_toRightOf="parent/&gt;&lt;/&gt; 表现如下： Circular positioning (Added in 1.1)这个属性是1.1版本添加进去的，可以使用angle和distance来约束一个控件的中心点和另外一个空间的中心点的位置关系，这样就可以把空间定位在一个圆上，可用属性如下： layout_constraintCircle : references another widget id layout_constraintCircleRadius : the distance to the other widget center layout_constraintCircleAngle : which angle the widget should be at (in degrees, from 0 to 360) 示例如下：12345&lt;Button android:id="@+id/buttonA" ... /&gt;&lt;Button android:id="@+id/buttonB" ... app:layout_constraintCircle="@+id/buttonA" app:layout_constraintCircleRadius="100dp" app:layout_constraintCircleAngle="45" /&gt; 表现如下： Visibility behaviorConstraintLayout对于被标记为GONE的控件有特殊的处理。一般布局中，GONE控件是不会展示在界面上并且不再属于布局的一部分，但是在布局计算上，ConstraintLayout和传统布局有很大的区别 传统布局下，GONE控件会被认为大小是0，也就是一个点 在ConstraintLayout中其大小仍然按照可见大小计算，但是其外边距为0 Dimension constraintsMinimum dimensions on ConstraintLayout可以像普通控件一样设置最小最大尺寸,属性如下： android:minWidth set the minimum width for the layout android:minHeight set the minimum height for the layout android:maxWidth set the maximum width for the layout android:maxHeight set the maximum height for the layout 这些属性当ConstraintLayout的宽高为WRAP_CONTENT时有效。 Widgets dimension constraints可以通过android:layout_width和android:layout_height设置控件的尺寸，有三种方式： 固定值 WRAP_CONTENT 0dp, 相当于MATCH_CONSTRAINT 前两种方式和普通布局表现出来的行为一样。最后一种会通过约束来重新设置控件尺寸，如果设置了margin，在布局计算的时候也会被考虑进去。 上图中的a是wrap_content,b是0dp，c是设置了margin的0dp。需要注意的是，在ConstraintLayout中，MATCH_PARENT是不推荐使用的。 WRAP_CONTENT:enforcing constraints (Added in 1.1)如果控件实际尺寸超过了约束的尺寸，那么约束就会失效，这时候可以添加如下属性来限制： app:layout_constrainedWidth=”true|false” app:layout_constrainedHeight=”true|false” 将B控件约束于A控件和父控件的中间，尺寸都为wrap_content这时候如果将B控件填充很长的文件，那么B控件的左侧则会突破约束，和A控件的中心对齐，如果我们不想要这种方式，还是要求B的左侧和Ade右侧对齐，则可以天剑layout_constrainedWidth=&quot;true&quot;属性进行约束，实例如下： MATCH_CONSTRAINT dimensions (Added in 1.1)当控件的尺寸被设置为MATCH_CONSTRAINT时，默认的行为是占据所有的剩余空间，可以使用如下属性来更改此行为： layout_constraintWidth_min 和 layout_constraintHeight_min : will set the minimum size for this dimension layout_constraintWidth_max 和 layout_constraintHeight_max : will set the maximum size for this dimension layout_constraintWidth_percent 和 layout_constraintHeight_percent : will set the size of this dimension as a percentage of the parent Percent dimensionTo use percent, you need to set the following:想要使用百分比布局，需要设置如下属性： 控件宽高设置为 MATCH_CONSTRAINT (0dp) app:layout_constraintWidth_default属性值设置为percent 设置 layout_constraintWidth_percent或者layout_constraintHeight_percent属性值(0-1之间) 下面的TextView控件将占据剩余宽度的50%和剩余高度的50%,示例：123456789&lt;TextView android:id="@+id/textView6" android:layout_width="0dp" android:layout_height="0dp" android:background="@color/colorAccent" app:layout_constraintHeight_default="percent" app:layout_constraintHeight_percent="0.5" app:layout_constraintWidth_default="percent" app:layout_constraintWidth_percent="0.5" /&gt; Ratio可以设置控件的宽高比例，为了实现这种方式，需要让控件的宽或者高设置为0dp(MATCH_CONSTRAINT)，如下： 123&lt;Button android:layout_width="wrap_content" android:layout_height="0dp" app:layout_constraintDimensionRatio="1:1" /&gt; 这样的话，高度会随着宽度的改变而改变，并且大小和宽度一致。设置宽高比的方式有两种： 一个浮点数，受约束的一方的尺寸/另一方尺寸得到的数字 宽度:高度 如果宽高两个方向同时设置了0dp(MATCH_CONSTRAINT)，系统会设置满足比例的最大尺寸，这种情况下还要保持宽高比例，需要在比例前面添加W或者H以确定受约束的是高还是宽。 You can also use ratio if both dimensions are set to MATCH_CONSTRAINT (0dp). In this case the system sets the largest dimensions the satisfies all constraints and maintains the aspect ratio specified. To constrain one specific side based on the dimensions of another, you can pre append W,” or H, to constrain the width or height respectively. For example, If one dimension is constrained by two targets (e.g. width is 0dp and centered on parent) you can indicate which side should be constrained, by adding the letter W (for constraining the width) or H (for constraining the height) in front of the ratio, separated by a comma: 12345&lt;Button android:layout_width="0dp" android:layout_height="0dp" app:layout_constraintDimensionRatio="H,16:9" app:layout_constraintBottom_toBottomOf="parent" app:layout_constraintTop_toTopOf="parent"/&gt; will set the height of the button following a 16:9 ratio, while the width of the button will match the constraints to parent. ChainsChains 在单轴（水平或垂直）上提供类似组的行为。另一个轴可以独立地约束。 Creating a chain如果一组小部件通过双向连接链接在一起，则它们被视为链（参见下图，显示最小链，具有两个小部件）。 Chain heads横向上，Chain头部是Chain最左边的控件；纵向上，Chain头部是Chain最顶部的控件。 Margins in chains如果连接时定义了外边距，Chain就会发生变化。在SPREAD CHAIN中，外边距会从已经分配好的空间中去掉。原文如下： If margins are specified on connections, they will be taken in account. In the case of spread chains, margins will be deducted from the allocated space. Chain Style当对Chain的第一个元素设置layout_constraintHorizontal_chainStyle或layout_constraintVertical_chainStyle属性，Chain就会根据特定的样式（默认样式为CHAIN_SPREAD）进行相应变化，样式类型如下： CHAIN_SPREAD – 元素呗分散开 (默认样式) Weighted chain – 在 CHAIN_SPREAD mo样式中,如果某些控件设置了MATCH_CONSTRAINT属性, 他们将平分剩余空间 CHAIN_SPREAD_INSIDE – Chain的头尾元素紧贴父容器 CHAIN_PACKED – Chain中的所有控件合并在一起后在剩余的空间中居中 图示如下： Weighted chains默认的Chain会在空间里平均散开。如果其中有一个或多个元素使用了MATCH_CONSTRAINT属性，那么他们会将剩余的空间平均填满。属性layout_constraintHorizontal_height和layout_constraintVertical_weight控制使用MATCH_CONSTRAINT的元素如何均分空间。 例如，一个Chain中包含两个使用MATCH_CONSTRAINT的元素，第一个元素使用的权重为2，第二个元素使用的权重为1，那么被第一个元素占用的空间是第二个元素的2倍。 Margins and chains (in 1.1)在chain中是可以使用margin属性的，例如，在一个水平的chain中，一个元素定义了right_magin=10dp,下一个元素定义了margin_left=5dp，那么两者之间的间距就是15dp. Virtual Helpers objectsGuidelineGuideline是只能用在ConstraintLayout布局里面的一个工具类，用于辅助布局，类似为辅助线，可以设置android:orientation属性来确定是横向的还是纵向的。 当设置为vertical的时候，Guideline的宽度为0，高度是parent也就是ConstraintLayout的高度 同样设置为horizontal的时候，高度为0，宽度是parent的宽度 定位Guideline有三种方式，这三种方式只能选择一个 指定距离左侧或顶部的固定距离（layout_constraintGuide_begin） 指定距离右侧或底部的固定距离（layout_constraintGuide_end） 指定在父控件中的宽度或高度的百分比（layout_constraintGuide_percent） 示例如下：1234567891011121314&lt;android.support.constraint.Guideline android:id="@+id/vertical_guideline" android:layout_width="wrap_content" android:layout_height="wrap_content" android:orientation="vertical" app:layout_constraintGuide_percent="0.5" /&gt; &lt;android.support.constraint.Guideline android:id="@+id/horizontal_guideline" android:layout_width="wrap_content" android:layout_height="wrap_content" android:orientation="horizontal" app:layout_constraintGuide_percent="0.5" /&gt; 声明了一个垂直居中，一个水平居中的GuideLine，效果如下，这两个控件在View上是不可见的。 接着就可以根据这两条辅助线来定位其他控件了123456789101112131415161718192021222324252627282930313233343536373839&lt;Button android:text="top_left" android:id="@+id/top_left_button" android:layout_width="wrap_content" android:layout_height="wrap_content" app:layout_constraintBottom_toBottomOf="@id/horizontal_guideline" app:layout_constraintLeft_toLeftOf="parent" app:layout_constraintRight_toLeftOf="@id/vertical_guideline" app:layout_constraintTop_toTopOf="parent" /&gt;&lt;Button android:text="top_right" android:id="@+id/top_right_button" android:layout_width="wrap_content" android:layout_height="wrap_content" app:layout_constraintBottom_toBottomOf="@id/horizontal_guideline" app:layout_constraintLeft_toLeftOf="@id/vertical_guideline" app:layout_constraintRight_toRightOf="parent" app:layout_constraintTop_toTopOf="parent" /&gt;&lt;Button android:text="bottom_right" android:id="@+id/bottom_right_button" android:layout_width="wrap_content" android:layout_height="wrap_content" app:layout_constraintBottom_toBottomOf="parent" app:layout_constraintLeft_toLeftOf="@id/vertical_guideline" app:layout_constraintRight_toRightOf="parent" app:layout_constraintTop_toTopOf="@id/horizontal_guideline" /&gt;&lt;Button android:text="bottom_left" android:id="@+id/bottom_left_button" android:layout_width="wrap_content" android:layout_height="wrap_content" app:layout_constraintBottom_toBottomOf="parent" app:layout_constraintLeft_toLeftOf="parent" app:layout_constraintRight_toRightOf="@id/vertical_guideline" app:layout_constraintTop_toTopOf="@id/horizontal_guideline" /&gt; 效果如下： BarrierBarrier可以引用多个控件，根据他们之中最大的宽高来创建一个虚拟的guideline，假设我们有两个按钮，@id/button1和@id/button2,让Barrier的constraint_referenced_ids属性引用这两个id，如下：123456&lt;android.support.constraint.Barrier android:id="@+id/barrier" android:layout_width="wrap_content" android:layout_height="wrap_content" app:barrierDirection="end" app:constraint_referenced_ids="button1,button2" /&gt; 示例如下：图中蓝色的线就是Barrier，Barrier所在问的方位由barrierDirection确定，可以设置为start,end,top,bottom,right,left这时候我们改变一个两个按钮的宽度，让button2的宽度小于button1，则效果如下：这样我们就可以把其他控件约束于barrier的右侧，使得button1和button2不会覆盖(被覆盖)其他控件 GroupGroup可以包含多个对其他控件的引用，这样我们操作这个group就相当于操作引用的控件123456&lt;android.support.constraint.Group android:visibility="gone" android:id="@+id/button_group" app:constraint_referenced_ids="login,register,modify_password" android:layout_width="wrap_content" android:layout_height="wrap_content" /&gt; 像上面这样，只要操作Group的visibility属性，就相当于同时操作@id/login,@id/register,@id/modify_password这三个控件的visibility属性。 Placeholders顾名思义就是一个用来占位的东西，对于样式相同，功能不同的界面，可以把样式做成style或者使用PlaceHolders来做：12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061&lt;?xml version="1.0" encoding="utf-8"?&gt;&lt;merge xmlns:android="http://schemas.android.com/apk/res/android" xmlns:app="http://schemas.android.com/apk/res-auto" xmlns:tools="http://schemas.android.com/tools" android:layout_width="match_parent" android:layout_height="match_parent" tools:layout_editor_absoluteX="0dp" tools:layout_editor_absoluteY="81dp" tools:parentTag="android.support.constraint.ConstraintLayout"&gt; &lt;android.support.constraint.Placeholder android:id="@+id/template_main_image" android:layout_width="0dp" android:layout_height="0dp" android:layout_marginTop="16dp" app:content="@+id/top_image" app:layout_constraintDimensionRatio="16:9" app:layout_constraintLeft_toLeftOf="parent" app:layout_constraintRight_toRightOf="parent" /&gt; &lt;android.support.constraint.Placeholder android:id="@+id/template_save" android:layout_width="48dp" android:layout_height="48dp" app:content="@+id/save" app:layout_constraintEnd_toStartOf="@+id/template_delete" app:layout_constraintHorizontal_bias="0.5" app:layout_constraintStart_toStartOf="parent" tools:layout_editor_absoluteY="460dp" /&gt; &lt;android.support.constraint.Placeholder android:id="@+id/template_delete" android:layout_width="48dp" android:layout_height="48dp" app:content="@+id/delete" app:layout_constraintEnd_toStartOf="@+id/template_cancel" app:layout_constraintHorizontal_bias="0.5" app:layout_constraintStart_toEndOf="@+id/template_save" tools:layout_editor_absoluteY="460dp" /&gt; &lt;android.support.constraint.Placeholder android:id="@+id/template_cancel" android:layout_width="48dp" android:layout_height="48dp" app:content="@+id/cancel" app:layout_constraintEnd_toStartOf="@+id/template_edit" app:layout_constraintHorizontal_bias="0.5" app:layout_constraintStart_toEndOf="@+id/template_delete" tools:layout_editor_absoluteY="460dp" /&gt; &lt;android.support.constraint.Placeholder android:id="@+id/template_edit" android:layout_width="48dp" android:layout_height="48dp" app:content="@+id/edit" app:layout_constraintEnd_toEndOf="parent" app:layout_constraintHorizontal_bias="0.5" app:layout_constraintStart_toEndOf="@+id/template_cancel" tools:layout_editor_absoluteY="460dp" /&gt; &lt;/merge&gt; 如果想要在预览界面看起来像是在ConstraintLayout里面的话就加上tools:parentTag=&quot;android.support.constraint.ConstraintLayout&quot;预览如下：在上面的布局文件中，每一个Placeholder都添加了app:content属性，表示要用这个属性指定的id对应的控件来替换Placeholder，在其他布局文件中：1234567891011121314151617181920212223242526272829303132333435363738394041&lt;android.support.constraint.ConstraintLayout android:layout_width="match_parent" android:layout_height="match_parent"&gt; &lt;include android:id="@+id/root" layout="@layout/constraint_layout_placeholder"/&gt; &lt;ImageButton android:id="@+id/main_title_image" android:src="@drawable/main_title_image" android:layout_width="wrap_content" android:layout_height="wrap_content" /&gt; &lt;ImageButton android:id="@+id/save" android:layout_width="wrap_content" android:layout_height="wrap_content" android:layout_marginBottom="16dp" app:layout_constraintBottom_toBottomOf="parent" app:srcCompat="@drawable/ic_save_black_24dp" /&gt; &lt;ImageButton android:id="@+id/edit" android:layout_width="wrap_content" android:layout_height="wrap_content" app:srcCompat="@drawable/ic_edit_black_24dp" /&gt; &lt;ImageButton android:id="@+id/cancel" android:layout_width="wrap_content" android:layout_height="wrap_content" android:layout_marginBottom="16dp" app:srcCompat="@drawable/ic_cancel_black_24dp" /&gt; &lt;ImageButton android:id="@+id/delete" android:layout_width="wrap_content" android:layout_height="wrap_content" android:layout_marginBottom="16dp" app:srcCompat="@drawable/ic_delete_black_24dp" /&gt;&lt;/android.support.constraint.ConstraintLayout&gt; 首先使用include标签将模板包含进来，然后创建其他需要替换的控件：当然也可以在代码中调用Placeholder.setContent(id)动态替换，配合CoordinatorLayout可以做出比较好玩的动画效果：代码在这里https://github.com/Thumar/Placeholder ConstraintLayout 1.1版本之后的东西常用的差不多就这些了 以上]]></content>
      <tags>
        <tag>Android</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Android hook--示例]]></title>
    <url>%2F2018%2F08%2F06%2FAndroid-hook-%E7%A4%BA%E4%BE%8B%2F</url>
    <content type="text"><![CDATA[Hook过程： 寻找 Hook 点，原则是静态变量或者单例对象，尽量 Hook public 的对象和方法。Hook的选择点：静态变量和单例，因为一旦创建对象，它们不容易变化，非常容易定位。 选择合适的代理方式，如果是接口可以用动态代理。 偷梁换柱——用代理对象替换原始对象。注意Android 的 API 版本比较多，方法和类可能不一样，所以要做好 API 的兼容工作。还有不要hook太底层的东西，各个厂商的rom代码不一样 hookView的点击事件先来个简单点的，View的点击事件。 hookOnLongClick顺着View的setOnClickListener方法找到了getListenerInfo方法，进而找到了ListenerInfo类，而view的click，longClick，ScrollChange的监听事件都存放在这里面。1234567891011121314151617181920212223242526272829303132333435363738private void hookOnLongCLickListener(View view) &#123; try &#123; //拿到mListenerInfo ，可以通过getListenerInfo方法 Class&lt;?&gt; clazzView = Class.forName("android.view.View"); Method getListenerInfoMethod = clazzView.getDeclaredMethod("getListenerInfo"); getListenerInfoMethod.setAccessible(true); Object listenerInfo = getListenerInfoMethod.invoke(view); //拿到 mOnLongClickListener字段，这里的ListenerInfo是View的内部类，需要用$符号链接。 Class&lt;?&gt; clazz = Class.forName("android.view.View$ListenerInfo"); Field field = clazz.getDeclaredField("mOnLongClickListener"); field.setAccessible(true); //拿到原来的mOnLongClickListener字段的值 View.OnLongClickListener raw =(View.OnLongClickListener) field.get(listenerInfo); //替换成我们自己的 field.set(listenerInfo, new HookOnLongClickListener(raw)); &#125; catch (Exception e) &#123; e.printStackTrace(); &#125;&#125;class HookOnLongClickListener implements View.OnLongClickListener&#123; private View.OnLongClickListener raw; public HookOnLongClickListener(View.OnLongClickListener raw)&#123; this.raw = raw; &#125; @Override public boolean onLongClick(View v) &#123; Log.e("HookUtil","HookOnLongClickListener"); Toast.makeText(MainActivity.this,"替换之后",Toast.LENGTH_SHORT).show(); if(raw!=null)&#123; //调用原来的onLongClick，保持原有逻辑不变 raw.onLongClick(v); &#125; return false; &#125;&#125; 这样调用hookOnLongCLickListerner(view)方法即可在原有逻辑不变的情况下添加我们自己的逻辑。 hookOnLongClick1234567891011121314151617181920212223242526272829303132333435363738private void hookOnClickListener(View view) &#123; try &#123; //拿到mListenerInfo ，可以通过getListenerInfo方法 Method getListenerInfoMethod = view.getClass().getDeclaredMethod("getListenerInfo"); getListenerInfoMethod.setAccessible(true); Object listenerInfo = getListenerInfoMethod.invoke(view); // 得到 原始的 OnClickListener 对象 Class&lt;?&gt; listenerInfoClz = Class.forName("android.view.View$ListenerInfo"); Field mOnClickListener = listenerInfoClz.getDeclaredField("mOnClickListener"); mOnClickListener.setAccessible(true); View.OnClickListener originOnClickListener = (View.OnClickListener) mOnClickListener.get(listenerInfo); // 用自定义的 OnClickListener 替换原始的 OnClickListener View.OnClickListener hookedOnClickListener = new HookedOnClickListener(originOnClickListener); mOnClickListener.set(listenerInfo, hookedOnClickListener); &#125; catch (Exception e) &#123; &#125;&#125;class HookedOnClickListener implements View.OnClickListener &#123; private View.OnClickListener origin; HookedOnClickListener(View.OnClickListener origin) &#123; this.origin = origin; &#125; @Override public void onClick(View v) &#123; Toast.makeText(MainActivity.this, "hook click", Toast.LENGTH_SHORT).show(); Log.i("hook", "Before click, do what you want to to."); if (origin != null) &#123; origin.onClick(v); &#125; Log.i("hook", "After click, do what you want to to."); &#125;&#125; 这样调用hookOnLongClickListerner(view)方法即可在原有逻辑不变的情况下添加我们自己的逻辑。 hookAlarmManager在设置Alarm的过程中，会调用AlarmManager.set方法，而AlarmManager对象又很方便得到： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061AlarmManager alarm = (AlarmManager) getSystemService(ALARM_SERVICE);Class&lt;?&gt; alarmManagerClass = alarm.getClass();Field mService = alarmManagerClass.getDeclaredField("mService");mService.setAccessible(true);Object mSerViceInstant = mService.get(alarm);AlarmManagerInvocationHandler handler = new AlarmManagerInvocationHandler(mSerViceInstant);Class&lt;?&gt; IActivityManagerIntercept = Class.forName("android.app.IAlarmManager");Object proxy = Proxy.newProxyInstance(Thread.currentThread().getContextClassLoader(), new Class&lt;?&gt;[]&#123;IActivityManagerIntercept&#125;, handler);mService.set(alarm, proxy);//动态代理class AlarmManagerInvocationHandler implements InvocationHandler &#123; private Object iAlarmManagerObject; private AlarmManagerInvocationHandler(Object iAlarmManagerObject) &#123; this.iAlarmManagerObject = iAlarmManagerObject; &#125; @Override public Object invoke(Object proxy, Method method, Object[] args) throws Throwable &#123; Log.i("alarm_manager", method.getName()); if ("set".equals(method.getName())) &#123; Log.e("alarm_manager", "调用了mService.set()"); try &#123; long interval = 0; int alarmManagerTimeType = Integer.valueOf(args[1].toString()); long alarmManagerAtTime = Long.valueOf(args[2].toString()); Log.e("alarm_manager_interval", "alarmManagerTimeType:" +alarmManagerTimeType); Log.e("alarm_manager_interval", "alarmManagerAtTime:" +alarmManagerAtTime); switch (alarmManagerTimeType) &#123; case AlarmManager.RTC_WAKEUP: case AlarmManager.RTC: Log.e("alarm_manager_interval", "currentTimeMillis--RTC:" +System.currentTimeMillis()); interval = alarmManagerAtTime - System.currentTimeMillis(); break; case AlarmManager.ELAPSED_REALTIME: case AlarmManager.ELAPSED_REALTIME_WAKEUP: Log.e("alarm_manager_interval", "currentTimeMillis--ELAPSED_REALTIME:" +SystemClock.elapsedRealtime()); interval = alarmManagerAtTime - SystemClock.elapsedRealtime(); break; &#125; Log.e("alarm_manager_interval",interval+"--&gt;" + interval/1000/60 ); &#125; catch (Exception e) &#123; e.printStackTrace(); &#125; &#125; return method.invoke(iAlarmManagerObject, args); &#125;&#125; hookAMS对于Activity的启动过程，我们可以hook它的startActivity方法 12345678910111213141516171819202122232425262728293031323334353637383940414243 public void hookASM()&#123; try &#123; Class&lt;?&gt; activityManagerNativeClass = Class.forName("android.app.ActivityManagerNative"); Field field = activityManagerNativeClass.getDeclaredField("gDefault"); field.setAccessible(true); Object gDefault= field.get(null); Class&lt;?&gt; singletonClass = Class.forName("android.util.Singleton"); Field mInstance = singletonClass.getDeclaredField("mInstance"); mInstance.setAccessible(true); Object iActivityManagerObject = mInstance.get(gDefault); //开始动态代理，用代理对象替换掉真实的ActivityManager， AmsInvocationHandler amsInvocationHandler = new AmsInvocationHandler(iActivityManagerObject); Object proxy = Proxy.newProxyInstance(Thread.currentThread().getContextClassLoader(), iActivityManagerObject.getClass().getInterfaces(), amsInvocationHandler); //现在替换掉这个对象 mInstance.set(gDefault, proxy); &#125;catch (Exception e)&#123; e.printStackTrace(); &#125;&#125; private class AmsInvocationHandler implements InvocationHandler &#123; private Object iActivityManagerObject; private AmsInvocationHandler(Object iActivityManagerObject) &#123; this.iActivityManagerObject = iActivityManagerObject; &#125; @Override public Object invoke(Object proxy, Method method, Object[] args) throws Throwable &#123; Log.i("hookASM", method.getName()); //我要在这里搞点事情 if ("startActivity".contains(method.getName())) &#123; Log.e("hookASM","Activity已经开始启动"); &#125; return method.invoke(iActivityManagerObject, args); &#125; &#125; 既然我们能够接管startActivity方法，我们就可以伪造一个Intent去启动一个没有在清单文件中注册的Activity。以上]]></content>
      <tags>
        <tag>Android</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Android hook--反射基础]]></title>
    <url>%2F2018%2F08%2F06%2FAndroid-hook--%E5%8F%8D%E5%B0%84%E5%9F%BA%E7%A1%80%2F</url>
    <content type="text"><![CDATA[假如你已经非常熟悉java中反射(reflect)和代理(Proxy)，那你还在这里看我这篇文章纯粹就是浪费时间了。 反射是什么官方介绍 Reflection is commonly used by programs which require the ability to examine or modify the runtime behavior of applications running in the Java virtual machine. This is a relatively advanced feature and should be used only by developers who have a strong grasp of the fundamentals of the language. With that caveat in mind, reflection is a powerful technique and can enable applications to perform operations which would otherwise be impossible. 概括来讲就是： 反射这个功能很XX 大家常见的对反射机制的概念:在Java中的反射机制是指在运行状态中，对于任意一个类都能够知道这个类所有的属性和方法；并且对于任意一个对象，都能够调用它的任意一个方法；这种动态获取信息以及动态调用对象方法的功能成为Java语言的反射机制。 涉及到的类 Class：反射的核心类，可以获取类的属性，方法等信息。 Field：Java.lang.reflec包中的类，表示类的成员变量，可以用来获取和设置类之中的属性值。 Method： Java.lang.reflec包中的类，表示类的方法，它可以用来获取类中的方法信息或者执行方法。 Constructor： Java.lang.reflec包中的类，表示类的构造方法。 简介先写一个简单的Person类当做目标类1234567891011121314151617181920212223242526272829303132class Person &#123; public String name; private String nickName; int age; public Person()&#123;&#125; protected Person(int age) &#123; this. age = age; &#125; private Person(String name) &#123; this.name = name; &#125; public Person(String name,String nickName) &#123; this.name = name; this.nickName = nickName; &#125; public Person(String name, String nickName, int age) &#123; super(); this.name = name; this.nickName = nickName; this.age = age; &#125; @Override public String toString() &#123; return "Person [name=" + name + ", nickName=" + nickName + ", age=" + age + "]"; &#125;&#125; 获取想要操作的类的Class对象 Object.getClass(); 12 Person person = new Person();Class personClass = person.getClass(); 任何数据类型（包括基本数据类型）都有一个“静态”的class属性 1Class personClass2 = Person.class; 通过Class类的静态方法：forName（String className）(常用) 1Class personClass3 = Class.forName("com.huangyuanlove.Person"); 需要注意的是，在运行期间，一个只有一个Class对象： 123System.out.println(personClass);System.out.println(personClass == personClass2);System.out.println(personClass == personClass3); 输出： class com.huangyuanlove.Person true true 调用Class类中的方法获取构造方法并创造对象： 123456789101112131415161718192021222324252627282930313233343536 Person person = new Person();Class personClass = person.getClass();// 获取所有的公有构造方法Constructor[] publicConstructors = personClass.getConstructors();System.out.println("获取所有的公有构造方法");for (Constructor c : publicConstructors) &#123; System.out.println(c);&#125;// 获取所有的构造方法Constructor[] allConstructors = personClass.getDeclaredConstructors();System.out.println("获取所有的构造方法");for (Constructor c : allConstructors) &#123; System.out.println(c);&#125;// 获取公有，无参构造方法Constructor publicConstructorWithoutArgs = personClass.getConstructor();System.out.println("获取公有，无参构造方法");System.out.println(publicConstructorWithoutArgs);System.out.println(publicConstructorWithoutArgs.newInstance());// 获取私有，有一个String类型参数的构造方法Constructor publicConstructorWithOneStringArgs = personClass.getDeclaredConstructor(String.class);System.out.println("获取私有，有一个String类型参数的构造方法");System.out.println(publicConstructorWithOneStringArgs);personClass.getDeclaredField("nickName").setAccessible(true);System.out.println(publicConstructorWithOneStringArgs.newInstance("xuan"));// 获取公有，有两个个String类型参数的构造方法Constructor publicConstructorWithTwoStringArgs = personClass.getConstructor(String.class, String.class);System.out.println("获取公有，有两个个String类型参数的构造方法");System.out.println(publicConstructorWithTwoStringArgs);publicConstructorWithTwoStringArgs.setAccessible(true);System.out.println(publicConstructorWithTwoStringArgs.newInstance("xuan", "huangyuan")); 这里需要注意的是，在获取私有，有一个String类型参数的构造方法，并调用newInstance方法的时候会抛出异常，这是因为该构造方法中的nickName字段是私有的,将其注释掉可获得如下输出 输出： 获取所有的公有构造方法 public com.huangyuanlove.Person(java.lang.String,java.lang.String,int) public com.huangyuanlove.Person(java.lang.String,java.lang.String) public com.huangyuanlove.Person() 获取所有的构造方法 public com.huangyuanlove.Person(java.lang.String,java.lang.String,int) public com.huangyuanlove.Person(java.lang.String,java.lang.String) private com.huangyuanlove.Person(java.lang.String) protected com.huangyuanlove.Person(int) public com.huangyuanlove.Person() 获取公有，无参构造方法 public com.huangyuanlove.Person() Person [name=null, nickName=null, age=0] 获取私有，有一个String类型参数的构造方法 private com.huangyuanlove.Person(java.lang.String) 获取公有，有两个个String类型参数的构造方法 public com.huangyuanlove.Person(java.lang.String,java.lang.String) Person [name=xuan, nickName=huangyuan, age=0] 获取成员变量并进行操作 123456789101112131415161718192021222324252627 Person person = new Person();Class personClass = person.getClass();// 获取所有的公共成员变量Field publicFields[] = personClass.getFields();System.out.println("获取所有的公共成员变量");for (Field f : publicFields) &#123; System.out.println(f);&#125;// 获取所有的成员变量Field allFields[] = personClass.getDeclaredFields();System.out.println("获取所有的成员变量");for (Field f : allFields) &#123; System.out.println(f);&#125;// 获取某个公有成员变量并赋值Field nameField = personClass.getField("name");nameField.set(person, "huangyuan");System.out.println(person);// 获取某个私有成员变量并赋值Field nickNameField = personClass.getDeclaredField("nickName"); //因为nickName是私有的，所有需要先设置可访问nickNameField.setAccessible(true);nickNameField.set(person, "xuan");System.out.println(person); 可以得到如下输出： 获取所有的公共成员变量 public java.lang.String com.huangyuanlove.Person.name 获取所有的成员变量 public java.lang.String com.huangyuanlove.Person.name private java.lang.String com.huangyuanlove.Person.nickName int com.huangyuanlove.Person.age Person [name=huangyuan, nickName=null, age=0] Person [name=huangyuan, nickName=xuan, age=0] 重要的事情来了，一定要记住，谁要是想上面那样反射获取类的公有成员变量然后进行赋值操作，肯定被骂的祸国殃民、民不聊生、生灵涂炭，都public了你还反射。 获取私有变量的时候需要使用getDeclaredField方法，否则会抛出noSuchFieldException 获取方法并进行调用 在类中添加两个方法 1234567public void sayHi() &#123; System.out.println("hi");&#125;private void saySomeThing(String someThing) &#123; System.out.println(someThing);&#125; 反射获取类方法并进行调用 123456789101112131415161718192021222324252627 Person person = new Person();Class personClass = person.getClass();// 获取所有公共方法System.out.println("获取所有公共方法");Method publicMethods[] = personClass.getMethods();for (Method m : publicMethods) &#123; System.out.println(m.getName());&#125;// 获取所有方法System.out.println("获取所有方法");Method allMethods[] = personClass.getDeclaredMethods();for (Method m : allMethods) &#123; System.out.println(m.getName());&#125;// 获取指定的公有方法System.out.println("获取指定的公有方法");Method publicMethodWithoutArgs = personClass.getMethod("sayHi");publicMethodWithoutArgs.invoke(person);// 获取指定的私有方法System.out.println("获取指定的私有方法");Method privateMethodWithStringArgs = personClass.getDeclaredMethod("saySomeThing", String.class);privateMethodWithStringArgs.setAccessible(true);privateMethodWithStringArgs.invoke(person, "someThing"); 得到输出： 获取所有公共方法 toString sayHi wait wait wait equals hashCode getClass notify notifyAll 获取所有方法 toString sayHi saySomeThing 获取指定的公有方法 hi 获取指定的私有方法 someThing 获取到的方法中并不包含构造方法，但是包含从父类继承下来的公共方法。和上面的获取成员变量赋值一样，谁要是反射去获取公共方法再去调用，基本上就凉了。 静态代理和动态代理静态代理简单来说，代理就是用一个代理类来封装一个委托类，这样做有两个好处：可以隐藏委托类的具体实现；可以在不改变委托类的情况下增加额外的操作。而静态代理，就是在程序运行之前，代理类就已经存在了。静态代理一般的实现方式为：委托类和代理类都实现同一个接口或者是继承自同一个父类，然后在代理类中保存一个委托类的对象引用（父类或者父类接口的对象引用），通过给构造器传入委托类的对象进行初始化，在同名方法中通过调用委托类的方法实现静态代理。除此之外，在代理类同名方法中还可以实现一些额外的功能。代码如下：RealObject类为委托类，SimpleProxy类为代理类：1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556interface Interface &#123; void doSomething(); void somethingElse(String arg);&#125;class RealObject implements Interface &#123; @Override public void doSomething() &#123; // TODO Auto-generated method stub System.out.println("doSomething"); &#125; @Override public void somethingElse(String arg) &#123; // TODO Auto-generated method stub System.out.println("somethingElse " + arg); &#125;&#125;class SimpleProxy implements Interface &#123; // 保存委托类（父接口的引用） private Interface proxied; // 传入委托类的对象用于初始化 public SimpleProxy(Interface proxied) &#123; this.proxied = proxied; &#125; // 两个同名方法中还实现了其他的功能 @Override public void doSomething() &#123; // TODO Auto-generated method stub System.out.println("SimpleProxy doSomething"); proxied.doSomething(); &#125; @Override public void somethingElse(String arg) &#123; // TODO Auto-generated method stub System.out.println("SimpleProxy somethingElse " + arg); proxied.somethingElse(arg); &#125;&#125;public class SimpleProxyDemo &#123; public static void main(String[] args) &#123; consumer(new RealObject()); consumer(new SimpleProxy(new RealObject())); &#125; public static void consumer(Interface iface) &#123; iface.doSomething(); iface.somethingElse("bonobo"); &#125;&#125; 动态代理静态代理的局限性在于，代理类需要在程序运行之前就编写好，而动态代理则可以在程序运行的过程中动态创建并处理对所代理方法的调用。在动态代理中，需要定义一个中介类，这个类实现InvocationHandle接口（主要是里面的invoke方法）。这个中介类位于委托类和代理类之间，作为一个调用处理器而存在。它保存一个委托类的引用，通过传入委托类对象进行初始化；然后在invoke方法中，实现对委托类方法的调用，并增加需要的额外操作。在需要使用动态代理时，首先通过Proxy类中的newProxyInstance方法得到代理类对象（方法的三个参数分别是：（通常是委托类实现接口的）类加载器，希望代理类实现的接口列表（通常也是委托类实现的接口），以及一个调用处理器的对象），然后通过这个代理类对象直接调用代理类的方法。这种调用实际上会通过调用处理器调用invoke方法，进而实现对委托类相应方法的调用。 注意在动态代理中，只实现了一个调用处理器，而没有真正实现代理类。代理类对象是通过Proxy类中的newProxyInstance方法得到的。这样，不管你在调用委托类任何方法时需要加入的额外操作都可以仅仅在调用处理器中的invoke方法中实现就可以了。代码示例如下1234567891011121314151617181920212223242526272829303132333435363738394041public class SimpleDynamiProxyDemo &#123; public static void consumer(Interface iface) &#123; iface.doSomething(); iface.somethingElse("bonobo"); &#125; public static void main(String[] args) &#123; RealObject real = new RealObject(); consumer(real); // 通过Proxy.newProxyInstance方法得到代理类对象 Interface proxy = (Interface) Proxy.newProxyInstance(Interface.class.getClassLoader(), new Class[] &#123; Interface.class &#125;, new DynamicProxyHandler(real)); // 通过代理类对象直接调用方法，会被重定向到调用处理器上的invoke方法 consumer(proxy); &#125;&#125;// 中介类（调用处理器）class DynamicProxyHandler implements InvocationHandler &#123; // 保存一个委托类的对象 private Object proxied; public DynamicProxyHandler(Object proxied) &#123; this.proxied = proxied; &#125; // 三个参数：代理类的引用，方法名和方法的参数列表 @Override public Object invoke(Object proxy, Method method, Object[] args) throws Throwable &#123; // TODO Auto-generated method stub System.out.println("**** proxy: " + proxy.getClass() + ", method: " + method + ", args: " + args); if (args != null) &#123; for (Object arg : args) &#123; System.out.println(" " + arg); &#125; &#125; // 实现对委托类方法的调用，参数表示委托类对象和参数 return method.invoke(proxied, args); &#125;&#125; 以上以上静态代理和动态代理相关的文字代码出自于 https://www.cnblogs.com/hrcnblogs/p/8711418.html]]></content>
      <tags>
        <tag>Android</tag>
        <tag>java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Toast显示过程]]></title>
    <url>%2F2018%2F08%2F03%2FToast%E6%98%BE%E7%A4%BA%E8%BF%87%E7%A8%8B%2F</url>
    <content type="text"><![CDATA[抄书抄的有点烦，自己也学着分析一下源码，挑了个在我看来比较简单的Toast显示过程来玩一玩。1Toast.makeText(context, text, duration).show(); 先了解一下makeText过程，该过程最终都会调用下面的方法：1234567891011121314151617181920/** * Make a standard toast to display using the specified looper. * If looper is null, Looper.myLooper() is used. * @hide */ public static Toast makeText(@NonNull Context context, @Nullable Looper looper, @NonNull CharSequence text, @Duration int duration) &#123; Toast result = new Toast(context, looper); LayoutInflater inflate = (LayoutInflater) context.getSystemService(Context.LAYOUT_INFLATER_SERVICE); View v = inflate.inflate(com.android.internal.R.layout.transient_notification, null); TextView tv = (TextView)v.findViewById(com.android.internal.R.id.message); tv.setText(text); result.mNextView = v; result.mDuration = duration; return result; &#125; 创建一个新的Toast对象，在Toast的构造方法中有一个TN类型的mTN对象：1mTN = new TN(context.getPackageName(), looper); TN是ITransientNotification.Stub的子类，注意一下这个对象，这对后面的过程很重要。得到Toast对象后接着调用show方法：12345678910111213141516171819/** * Show the view for the specified duration. */ public void show() &#123; if (mNextView == null) &#123; throw new RuntimeException("setView must have been called"); &#125; INotificationManager service = getService(); String pkg = mContext.getOpPackageName(); TN tn = mTN; tn.mNextView = mNextView; try &#123; service.enqueueToast(pkg, tn, mDuration); &#125; catch (RemoteException e) &#123; // Empty &#125; &#125; 重点在service上，它是INotificationManager的实例对象，是个用于Binder机制IPC通信的接口，实际上getService返回了一个以”notification”为标记的远程服务对象的代理。这个远程服务对象就是NotificationManagerService，以下简称NMS。NMS中的enqueueToast方法：12345678910111213141516171819202122232425262728293031323334353637383940414243@Overridepublic void enqueueToast(String pkg, ITransientNotification callback, int duration)&#123; ...... synchronized (mToastQueue) &#123; int callingPid = Binder.getCallingPid(); long callingId = Binder.clearCallingIdentity(); try &#123; ToastRecord record; int index; // All packages aside from the android package can enqueue one toast at a time if (!isSystemToast) &#123; index = indexOfToastPackageLocked(pkg); &#125; else &#123; index = indexOfToastLocked(pkg, callback); &#125; // If the package already has a toast, we update its toast // in the queue, we don't move it to the end of the queue. if (index &gt;= 0) &#123; record = mToastQueue.get(index); record.update(duration); record.update(callback); &#125; else &#123; Binder token = new Binder(); mWindowManagerInternal.addWindowToken(token, TYPE_TOAST, DEFAULT_DISPLAY); record = new ToastRecord(callingPid, pkg, callback, duration, token); mToastQueue.add(record); index = mToastQueue.size() - 1; &#125; keepProcessAliveIfNeededLocked(callingPid); // If it's at index 0, it's the current toast. It doesn't matter if it's // new or just been updated. Call back and tell it to show itself. // If the callback fails, this will remove it from the list, so don't // assume that it's valid after this. if (index == 0) &#123; showNextToastLocked(); &#125; &#125; finally &#123; Binder.restoreCallingIdentity(callingId); &#125; &#125;&#125; 方法中的第二个参数callBack就是上面的TN对象，关键在于下面的index的判断：mToastQueue是个list，如果是非系统tost，并且该taost存在于list中(根据pkg判断)，就取出该ToastRecord并且更新，如果不存在，则新建一个ToastRecord存入list中。如果ToastRecord是在list的第一个位置，接着调用showNextToastLocaked方法1234567891011121314151617181920212223242526@GuardedBy("mToastQueue")void showNextToastLocked() &#123; ToastRecord record = mToastQueue.get(0); while (record != null) &#123; if (DBG) Slog.d(TAG, "Show pkg=" + record.pkg + " callback=" + record.callback); try &#123; record.callback.show(record.token); scheduleTimeoutLocked(record); return; &#125; catch (RemoteException e) &#123; Slog.w(TAG, "Object died trying to show notification " + record.callback + " in package " + record.pkg); // remove it from the list and let the process die int index = mToastQueue.indexOf(record); if (index &gt;= 0) &#123; mToastQueue.remove(index); &#125; keepProcessAliveIfNeededLocked(record.pid); if (mToastQueue.size() &gt; 0) &#123; record = mToastQueue.get(0); &#125; else &#123; record = null; &#125; &#125; &#125;&#125; 关键的两行代码12record.callback.show(record.token);scheduleTimeoutLocked(record); 第一行负责显示，第二行负责超时关闭并显示队列中的下一个Toast。在第一行中，callBack就是我们上面提到的TN对象的实例mTN：12345678/*** schedule handleShow into the right thread*/@Overridepublic void show(IBinder windowToken) &#123; if (localLOGV) Log.v(TAG, "SHOW: " + this); mHandler.obtainMessage(SHOW, windowToken).sendToTarget();&#125; 在mHandler中调用了handleShow方法：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354public void handleShow(IBinder windowToken) &#123; if (localLOGV) Log.v(TAG, "HANDLE SHOW: " + this + " mView=" + mView + " mNextView=" + mNextView); // If a cancel/hide is pending - no need to show - at this point // the window token is already invalid and no need to do any work. if (mHandler.hasMessages(CANCEL) || mHandler.hasMessages(HIDE)) &#123; return; &#125; if (mView != mNextView) &#123; // remove the old view if necessary handleHide(); mView = mNextView; Context context = mView.getContext().getApplicationContext(); String packageName = mView.getContext().getOpPackageName(); if (context == null) &#123; context = mView.getContext(); &#125; mWM = (WindowManager)context.getSystemService(Context.WINDOW_SERVICE); // We can resolve the Gravity here by using the Locale for getting // the layout direction final Configuration config = mView.getContext().getResources().getConfiguration(); final int gravity = Gravity.getAbsoluteGravity(mGravity, config.getLayoutDirection()); mParams.gravity = gravity; if ((gravity &amp; Gravity.HORIZONTAL_GRAVITY_MASK) == Gravity.FILL_HORIZONTAL) &#123; mParams.horizontalWeight = 1.0f; &#125; if ((gravity &amp; Gravity.VERTICAL_GRAVITY_MASK) == Gravity.FILL_VERTICAL) &#123; mParams.verticalWeight = 1.0f; &#125; mParams.x = mX; mParams.y = mY; mParams.verticalMargin = mVerticalMargin; mParams.horizontalMargin = mHorizontalMargin; mParams.packageName = packageName; mParams.hideTimeoutMilliseconds = mDuration == Toast.LENGTH_LONG ? LONG_DURATION_TIMEOUT : SHORT_DURATION_TIMEOUT; mParams.token = windowToken; if (mView.getParent() != null) &#123; if (localLOGV) Log.v(TAG, "REMOVE! " + mView + " in " + this); mWM.removeView(mView); &#125; if (localLOGV) Log.v(TAG, "ADD! " + mView + " in " + this); // Since the notification manager service cancels the token right // after it notifies us to cancel the toast there is an inherent // race and we may attempt to add a window after the token has been // invalidated. Let us hedge against that. try &#123; mWM.addView(mView, mParams); trySendAccessibilityEvent(); &#125; catch (WindowManager.BadTokenException e) &#123; /* ignore */ &#125; &#125; &#125; 上面的一坨是获取到WindowManager然后通过mWM.addView将Toast显示到窗口上。至于WindowManager如何添加view的，可以看这个：http://blog.huangyuanlove.com/2017/03/21/Window和CWindowManager/接下来看一下怎么取消Toast弹窗，上面提到了调用了scheduleTimeoutLocked方法。1234567@GuardedBy("mToastQueue")private void scheduleTimeoutLocked(ToastRecord r)&#123; mHandler.removeCallbacksAndMessages(r); Message m = Message.obtain(mHandler, MESSAGE_TIMEOUT, r); long delay = r.duration == Toast.LENGTH_LONG ? LONG_DELAY : SHORT_DELAY; mHandler.sendMessageDelayed(m, delay);&#125; 调用mHandler发送了一个延时消息去调用handleTimeout方法，延迟时间就是根据duration来判断的。这里的mHandler是WorkerHandler继承自Handler12345678910private void handleTimeout(ToastRecord record) &#123; if (DBG) Slog.d(TAG, "Timeout pkg=" + record.pkg + " callback=" + record.callback); synchronized (mToastQueue) &#123; int index = indexOfToastLocked(record.pkg, record.callback); if (index &gt;= 0) &#123; cancelToastLocked(index); &#125; &#125; &#125; 接着调用了cancelToastLocked方法1234567891011121314151617181920212223@GuardedBy("mToastQueue") void cancelToastLocked(int index) &#123; ToastRecord record = mToastQueue.get(index); try &#123; record.callback.hide(); &#125; catch (RemoteException e) &#123; Slog.w(TAG, "Object died trying to hide notification " + record.callback + " in package " + record.pkg); // don't worry about this, we're about to remove it from // the list anyway &#125; ToastRecord lastToast = mToastQueue.remove(index); mWindowManagerInternal.removeWindowToken(lastToast.token, true, DEFAULT_DISPLAY); keepProcessAliveIfNeededLocked(record.pid); if (mToastQueue.size() &gt; 0) &#123; // Show the next one. If the callback fails, this will remove // it from the list, so don't assume that the list hasn't changed // after this point. showNextToastLocked(); &#125; &#125; 在该方法中调用了callback.hide()方法移除toast的显示。1234567891011121314 public void handleHide() &#123; if (localLOGV) Log.v(TAG, "HANDLE HIDE: " + this + " mView=" + mView); if (mView != null) &#123; // note: checking parent() just to make sure the view has // been added... i have seen cases where we get here when // the view isn't yet added, so let's try not to crash. if (mView.getParent() != null) &#123; if (localLOGV) Log.v(TAG, "REMOVE! " + mView + " in " + this); mWM.removeViewImmediate(mView); &#125; mView = null; &#125;&#125; 如果这时候mToastQueue中还有ToastRecord，则调用showNextToastLocked方法显示下一个。 以上]]></content>
      <tags>
        <tag>Android</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Android ContentProvider]]></title>
    <url>%2F2018%2F08%2F02%2FAndroid-ContentProvider%2F</url>
    <content type="text"><![CDATA[《Android开发艺术探索》9.5章 系统预置了许多ContentProvider，比如通讯录信息、日程表信息等，要跨进程访问这些信息，只需要通过ContentResolver的query、update、insert和delete方法即可。虽然ContentProvider的底层实现是Binder，但是它的使用过程要比AIDL简单许多，这是因为系统已经为我们做了封装，使得我们无须关心底层细节即可轻松实现IPC。系统预置了许多ContentProvider，比如通讯录信息、日程表信息等，要跨进程访问这些信息，只需要通过ContentResolver的query、update、insert和delete方法即可。 使用ContentResolver读取联系人123456789101112131415161718private ArrayList&lt;HashMap&lt;String, String&gt;&gt; readContact() &#123; String NUM = ContactsContract.CommonDataKinds.Phone.NUMBER; String NAME = ContactsContract.CommonDataKinds.Phone.DISPLAY_NAME; Uri uri = ContactsContract.CommonDataKinds.Phone.CONTENT_URI; ArrayList&lt;HashMap&lt;String, String&gt;&gt; list = new ArrayList&lt;HashMap&lt;String, String&gt;&gt;(); ContentResolver cr = getContentResolver(); Cursor cursor = cr.query(uri,new String[]&#123;NUM,NAME&#125;,null,null,null); while (cursor.moveToNext())&#123; String name = cursor.getString(cursor.getColumnIndex(NAME)); String phone = cursor.getString(cursor.getColumnIndex(NUM)); HashMap&lt;String,String&gt; contact = new HashMap&lt;&gt;(); contact.put("name",name); contact.put("phone",phone); list.add(contact); &#125; return list; 工作过程ContentProvider是一种内容共享型组件，它通过Binder向其他组件乃至其他应用提供数据。当ContentProvider所在的进程启动时，ContentProvider会同时启动并被发布到AMS中。需要注意的是，这个时候ContentProvider的onCreate要先于Application的onCreate而执行。当一个应用启动时，入口方法为ActivityThread的main方法，main方法是一个静态方法，在main方法中会创建ActivityThread的实例并创建主线程的消息队列，然后在ActivityThread的attach方法中会远程调用AMS的attachApplication方法并将ApplicationThread对象提供给AMS。ApplicationThread是一个Binder对象，它的Binder接口是IApplicationThread，它主要用于ActivityThread和AMS之间的通信，这一点在前面多次提到。在AMS的attachApplication方法中，会调用ApplicationThread的bindApplication方法，注意这个过程同样是跨进程完成的，bindApplication的逻辑会经过ActivityThread中的mH Handler切换到ActivityThread中去执行，具体的方法是handleBindApplication。在handleBindApplication方法中，ActivityThread会创建Application对象并加载ContentProvider。需要注意的是，ActivityThread会先加载ContentProvider，然后再调用Application的onCreate方法。这就是ContentProvider的启动过程，ContentProvider启动后，外界就可以通过它所提供的增删改查这四个接口来操作ContentProvider中的数据源，即insert、delete、update和query四个方法。这四个方法都是通过Binder来调用的，外界无法直接访问ContentProvider，它只能通过AMS根据Uri来获取对应的ContentProvider的Binder接口IConentProvider，然后再通过IConentProvider来访问ContentProvider中的数据源。一般来说，ContentProvider都应该是单实例的。ContentProvider到底是不是单实例，这是由它的android:multiprocess属性来决定的，当android:multiprocess为false时，ContentProvider是单实例，这也是默认值；当android:multiprocess为true时，ContentProvider为多实例，这个时候在每个调用者的进程中都存在一个ContentProvider对象。访问ContentProvider需要通过ContentResolver，ContentResolver是一个抽象类，通过Context的getContentResolver方法获取的实际上是ApplicationContentResolver对象，ApplicationContentResolver类继承了ContentResolver并实现了ContentResolver中的抽象方法。当ContentProvider所在的进程未启动时，第一次访问它时就会触发ContentProvider的创建，当然这也伴随着ContentProvider所在进程的启动。通过ContentProvider的四个方法的任何一个都可以触发ContentProvider的启动过程，这里选择query方法。ContentProvider的query方法中，首先会获取IContentProvider对象，不管是通过acquireUnstableProvider方法还是直接通过acquireProvider方法，它们的本质都是一样的，最终都是通过acquireProvider方法来获取ContentProvider。下面是ApplicationContentResolver的acquireProvider方法的具体实现:123456@Override protected IContentProvider acquireProvider(Context context, String auth) &#123; return mMainThread.acquireProvider(context, ContentProvider.getAuthorityWithoutUserId(auth), resolveUserIdFromAuthority(auth), true); &#125; ApplicationContentResolver的acquireProvider方法并没有处理任何逻辑，它直接调用了ActivityThread的acquireProvider方法，ActivityThread的acquireProvider方法的源码如下:12345678910111213141516171819202122232425262728293031public final IContentProvider acquireProvider( Context c, String auth, int userId, boolean stable) &#123; final IContentProvider provider = acquireExistingProvider(c, auth, userId, stable); if (provider != null) &#123; return provider; &#125; // There is a possible race here. Another thread may try to acquire // the same provider at the same time. When this happens, we want to ensure // that the first one wins. // Note that we cannot hold the lock while acquiring and installing the // provider since it might take a long time to run and it could also potentially // be re-entrant in the case where the provider is in the same process. ContentProviderHolder holder = null; try &#123; holder = ActivityManager.getService().getContentProvider( getApplicationThread(), auth, userId, stable); &#125; catch (RemoteException ex) &#123; throw ex.rethrowFromSystemServer(); &#125; if (holder == null) &#123; Slog.e(TAG, "Failed to find provider info for " + auth); return null; &#125; // Install provider will increment the reference count for us, and break // any ties in the race. holder = installProvider(c, holder, holder.info, true /*noisy*/, holder.noReleaseNeeded, stable); return holder.provider;&#125; 上面的代码首先会从ActivityThread中查找是否已经存在目标ContentProvider了，如果存在就直接返回。ActivityThread中通过mProviderMap来存储已经启动的ContentProvider对象，mProviderMap的声明如下所示:1inal ArrayMap&lt;providerKey,ProviderClientRecord&gt; mProviderMap = new ArrayMap&lt;providerKey,ProviderClientRecord&gt;(); 如果目前ContentProvider没有启动，那么就发送一个进程间请求给AMS让其启动目标ContentProvider，最后再通过installProvider方法来修改引用计数。ContentProvider被启动时会伴随着进程的启动，在AMS中，首先会启动ContentProvider所在的进程，然后再启动ContentProvider。启动进程是由AMS的startProcessLocked方法来完成的，其内部主要是通过Process的start方法来完成一个新进程的启动，新进程启动后其入口方法为ActivityThread的main方法，如下所示:123456789101112131415161718192021222324252627282930313233343536373839public static void main(String[] args) &#123; Trace.traceBegin(Trace.TRACE_TAG_ACTIVITY_MANAGER, "ActivityThreadMain"); // CloseGuard defaults to true and can be quite spammy. We // disable it here, but selectively enable it later (via // StrictMode) on debug builds, but using DropBox, not logs. CloseGuard.setEnabled(false); Environment.initForCurrentUser(); // Set the reporter for event logging in libcore EventLogger.setReporter(new EventLoggingReporter()); // Make sure TrustedCertificateStore looks in the right place for CA certificates final File configDir = Environment.getUserConfigDirectory(UserHandle.myUserId()); TrustedCertificateStore.setDefaultUserDirectory(configDir); Process.setArgV0("&lt;pre-initialized&gt;"); Looper.prepareMainLooper(); ActivityThread thread = new ActivityThread(); thread.attach(false); if (sMainThreadHandler == null) &#123; sMainThreadHandler = thread.getHandler(); &#125; if (false) &#123; Looper.myLooper().setMessageLogging(new LogPrinter(Log.DEBUG, "ActivityThread")); &#125; // End of event ActivityThreadMain. Trace.traceEnd(Trace.TRACE_TAG_ACTIVITY_MANAGER); Looper.loop(); throw new RuntimeException("Main thread loop unexpectedly exited");&#125; 可以看到，ActivityThread的main方法是一个静态方法，在它内部首先会创建ActivityThread的实例并调用attach方法来进行一系列初始化，接着就开始进行消息循环了。ActivityThread的attach方法会将ApplicationThread对象通过AMS的attachApplication方法跨进程传递给AMS，最终AMS会完成ContentProvider的创建过程，AMS的attachApplication方法调用了attachApplicationLocked方法，attachApplicationLocked中又调用了ApplicationThread的bindApplication，注意这个过程也是进程间调用，1234567891011121314151617181920212223242526272829303132333435363738394041try &#123; mgr.attachApplication(mAppThread);&#125; catch (RemoteException ex) &#123; throw ex.rethrowFromSystemServer();&#125;@Override public final void attachApplication(IApplicationThread thread) &#123; synchronized (this) &#123; int callingPid = Binder.getCallingPid(); final long origId = Binder.clearCallingIdentity(); attachApplicationLocked(thread, callingPid); Binder.restoreCallingIdentity(origId); &#125; &#125;private final boolean attachApplicationLocked(IApplicationThread thread,int pid) &#123; ......if (app.instr != null) &#123; thread.bindApplication(processName, appInfo, providers, app.instr.mClass, profilerInfo, app.instr.mArguments, app.instr.mWatcher, app.instr.mUiAutomationConnection, testMode, mBinderTransactionTrackingEnabled, enableTrackAllocation, isRestrictedBackupMode || !normalMode, app.persistent, new Configuration(getGlobalConfiguration()), app.compat, getCommonServicesLocked(app.isolated), mCoreSettingsObserver.getCoreSettingsLocked(), buildSerial); &#125; else &#123; thread.bindApplication(processName, appInfo, providers, null, profilerInfo, null, null, null, testMode, mBinderTransactionTrackingEnabled, enableTrackAllocation, isRestrictedBackupMode || !normalMode, app.persistent, new Configuration(getGlobalConfiguration()), app.compat, getCommonServicesLocked(app.isolated), mCoreSettingsObserver.getCoreSettingsLocked(), buildSerial); &#125; ......&#125; ActivityThread的bindApplication会发送一个BIND_APPLICATION类型的消息给mH，mH是一个Handler，它收到消息后会调用ActivityThread的handleBindApplication方法，bindApplication发送消息的过程如下所示:123456789101112131415161718AppBindData data = new AppBindData(); data.processName = processName; data.appInfo = appInfo; data.providers = providers; data.instrumentationName = instrumentationName; data.instrumentationArgs = instrumentationArgs; data.instrumentationWatcher = instrumentationWatcher; data.instrumentationUiAutomationConnection = instrumentationUiConnection; data.debugMode = debugMode; data.enableBinderTracking = enableBinderTracking; data.trackAllocation = trackAllocation; data.restrictedBackupMode = isRestrictedBackupMode; data.persistent = persistent; data.config = config; data.compatInfo = compatInfo; data.initProfilerInfo = profilerInfo; data.buildSerial = buildSerial; sendMessage(H.BIND_APPLICATION, data); ActivityThread的handleBindApplication则完成了Application的创建以及ContentProvider的创建，可以分为如下四个步骤: 创建ContextImpl和Instrumentation 12345678910111213final ContextImpl appContext = ContextImpl.createAppContext(this, data.info);updateLocaleListFromAppContext(appContext, mResourcesManager.getConfiguration().getLocales()); try &#123; final ClassLoader cl = instrContext.getClassLoader(); mInstrumentation = (Instrumentation) cl.loadClass(data.instrumentationName.getClassName()).newInstance();&#125; catch (Exception e) &#123; throw new RuntimeException( "Unable to instantiate instrumentation " + data.instrumentationName + ": " + e.toString(), e);&#125;final ComponentName component = new ComponentName(ii.packageName, ii.name);mInstrumentation.init(this, instrContext, appContext, component, data.instrumentationWatcher, data.instrumentationUiAutomationConnection); 创建Application对象 1234// If the app is being launched for full backup or restore, bring it up in// a restricted environment with the base application class.app = data.info.makeApplication(data.restrictedBackupMode, null);mInitialApplication = app; 启动当前进程的ContentProvider并调用其onCreate方法 12345678910// don't bring up providers in restricted mode; they may depend on the// app's custom Application classif (!data.restrictedBackupMode) &#123; if (!ArrayUtils.isEmpty(data.providers)) &#123; installContentProviders(app, data.providers); // For process that contains content providers, we want to // ensure that the JIT is enabled "at some point". mH.sendEmptyMessageDelayed(H.ENABLE_JIT, 10*1000); &#125;&#125; installContentProviders完成了ContentProvider的启动工作，它的实现如下所示。首先会遍历当前进程的ProviderInfo的列表并一一调用调用installProvider方法来启动它们，接着将已经启动的ContentProvider发布到AMS中，AMS会把它们存储在ProviderMap中，这样一来外部调用者就可以直接从AMS中获取ContentProvider了。12345678910111213141516171819202122232425262728private void installContentProviders( Context context, List&lt;ProviderInfo&gt; providers) &#123; final ArrayList&lt;ContentProviderHolder&gt; results = new ArrayList&lt;&gt;(); for (ProviderInfo cpi : providers) &#123; if (DEBUG_PROVIDER) &#123; StringBuilder buf = new StringBuilder(128); buf.append("Pub "); buf.append(cpi.authority); buf.append(": "); buf.append(cpi.name); Log.i(TAG, buf.toString()); &#125; ContentProviderHolder cph = installProvider(context, null, cpi, false /*noisy*/, true /*noReleaseNeeded*/, true /*stable*/); if (cph != null) &#123; cph.noReleaseNeeded = true; results.add(cph); &#125; &#125; try &#123; ActivityManager.getService().publishContentProviders( getApplicationThread(), results); &#125; catch (RemoteException ex) &#123; throw ex.rethrowFromSystemServer(); &#125; &#125; 下面看一下ContentProvider对象的创建过程，在installProvider方法中有下面一段代码，其通过类加载器完成了ContentProvider对象的创建:12345final java.lang.ClassLoader cl = c.getClassLoader();localProvider = (ContentProvider)cl.loadClass(info.name).newInstance();provider = localProvider.getIContentProvider();// XXX Need to create the correct context for this provider.localProvider.attachInfo(c, info); 在上述代码中，除了完成ContentProvider对象的创建，还会通过ContentProvider的attachInfo方法来调用它的onCreate方法:12345678910111213141516171819202122232425private void attachInfo(Context context, ProviderInfo info, boolean testing) &#123; mNoPerms = testing; /* * Only allow it to be set once, so after the content service gives * this to us clients can't change it. */ if (mContext == null) &#123; mContext = context; if (context != null) &#123; mTransport.mAppOpsManager = (AppOpsManager) context.getSystemService( Context.APP_OPS_SERVICE); &#125; mMyUid = Process.myUid(); if (info != null) &#123; setReadPermission(info.readPermission); setWritePermission(info.writePermission); setPathPermissions(info.pathPermissions); mExported = info.exported; mSingleUser = (info.flags &amp; ProviderInfo.FLAG_SINGLE_USER) != 0; setAuthorities(info.authority); &#125; ContentProvider.this.onCreate(); &#125;&#125; 到此为止，ContentProvider已经被创建并且其onCreate方法也已经被调用，这意味着ContentProvider已经启动完成了。 调用Application的onCreate方法 12345678910111213141516171819// Do this after providers, since instrumentation tests generally start their// test thread at this point, and we don't want that racing.try &#123; mInstrumentation.onCreate(data.instrumentationArgs);&#125;catch (Exception e) &#123; throw new RuntimeException( "Exception thrown in onCreate() of " + data.instrumentationName + ": " + e.toString(), e);&#125;try &#123; mInstrumentation.callApplicationOnCreate(app);&#125; catch (Exception e) &#123; if (!mInstrumentation.onException(app, e)) &#123; throw new RuntimeException( "Unable to create application " + app.getClass().getName() + ": " + e.toString(), e); &#125;&#125; 经过上面的四个步骤，ContentProvider已经成功启动，并且其所在进程的Application也已经启动，这意味着ContentProvider所在的进程已经完成了整个的启动过程，然后其他应用就可以通过AMS来访问这个ContentProvider了。拿到了ContentProvider以后，就可以通过它所提供的接口方法来访问它了。需要注意的是，这里的ContentProvider并不是原始的ContentProvider，而是ContentProvider的Binder类型的对象IContentProvider，IContentProvider的具体实现是ContentProviderNative和ContentProvider.Transport，其中ContentProvider.Transport继承了ContentProviderNative。这里仍然选择query方法，首先其他应用会通过AMS获取到ContentProvider的Binder对象即IContentProvider，而IContentProvider的实现者实际上是ContentProvider.Transport。因此其他应用调用IContentProvider的query方法时最终会以进程间通信的方式调用到ContentProvider.Transport的query方法，它的实现如下所示:123456789101112131415161718192021222324252627282930313233343536373839@Overridepublic Cursor query(String callingPkg, Uri uri, @Nullable String[] projection, @Nullable Bundle queryArgs, @Nullable ICancellationSignal cancellationSignal) &#123; validateIncomingUri(uri); uri = maybeGetUriWithoutUserId(uri); if (enforceReadPermission(callingPkg, uri, null) != AppOpsManager.MODE_ALLOWED) &#123; // The caller has no access to the data, so return an empty cursor with // the columns in the requested order. The caller may ask for an invalid // column and we would not catch that but this is not a problem in practice. // We do not call ContentProvider#query with a modified where clause since // the implementation is not guaranteed to be backed by a SQL database, hence // it may not handle properly the tautology where clause we would have created. if (projection != null) &#123; return new MatrixCursor(projection, 0); &#125; // Null projection means all columns but we have no idea which they are. // However, the caller may be expecting to access them my index. Hence, // we have to execute the query as if allowed to get a cursor with the // columns. We then use the column names to return an empty cursor. Cursor cursor = ContentProvider.this.query( uri, projection, queryArgs, CancellationSignal.fromTransport(cancellationSignal)); if (cursor == null) &#123; return null; &#125; // Return an empty cursor for all columns. return new MatrixCursor(cursor.getColumnNames(), 0); &#125; final String original = setCallingPackage(callingPkg); try &#123; return ContentProvider.this.query( uri, projection, queryArgs, CancellationSignal.fromTransport(cancellationSignal)); &#125; finally &#123; setCallingPackage(original); &#125;&#125; 很显然，ContentProvider.Transport的query方法调用了ContentProvider的query方法，query方法的执行结果再通过Binder返回给调用者，这样一来整个调用过程就完成了。除了query方法，insert、delete和update方法也是类似的。 以上]]></content>
      <tags>
        <tag>Android</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[AndroidService]]></title>
    <url>%2F2018%2F08%2F01%2FAndroidService%2F</url>
    <content type="text"><![CDATA[《Android开发艺术探索》9.3章Service分为两种工作状态,一种是启动状态，主要用于执行后台计算;另一种是绑定态,主要用于其他组件和Service的交互。需要注意的是，Service的这两种状态是可以共存的，即Service既可以处于启动状态也可以同时处于绑定状态。通过Context的startService方法即可启动一个Service:12Intent intent = new Intent(content,Service.class);startService(intent); 通过Context的bindService方法可以绑定一个Service：12Intent intent = new Intent(content,Service.class);bindService(intent,connection,BIND_AUTO_CREATE); Service启动过程Service的启动时从ContextWrapper的startService开始的：1234@Override public ComponentName startService(Intent service) &#123; return mBase.startService(service); &#125; mBase是Context的实现类ContextImpl，在Activity启动的时候会通过attach方法关联一个ContextImpl，这个ContextImpl就是上面的mBase，从ContextWrapper的实现来看，大部分的实现都是通过mBase来实现的，这是一种典型的桥接模式。在ContextImpl的startService方法中又调用了startServiceCommon。12345678910111213141516171819202122 @Override public ComponentName startService(Intent service) &#123; warnIfCallingFromSystemProcess(); return startServiceCommon(service, false, mUser); &#125;private ComponentName startServiceCommon(Intent service, boolean requireForeground,UserHandle user) &#123; validateServiceIntent(service); service.prepareToLeaveProcess(this); //api 27 ComponentName cn = ActivityManager.getService().startService( mMainThread.getApplicationThread(), service, service.resolveTypeIfNeeded( getContentResolver()), requireForeground, getOpPackageName(), user.getIdentifier()); //api 25 //ComponentName cn = ActivityManagerNative.getDefault().startService( // mMainThread.getApplicationThread(), service, service.resolveTypeIfNeeded( // getContentResolver()), getOpPackageName(), user.getIdentifier()); return cn;&#125; 在startServiceCommon中通过getService这个对象来启动一个服务，这个对象就是AMS，需要注意的是，在上述代码中通过AMS来启动服务的过程是一个跨进程调用。AMS的startService如下：1234567891011121314@Override public ComponentName startService(IApplicationThread caller, Intent service, String resolvedType, String callingPackage, int userId) throws TransactionTooLargeException &#123; synchronized(this) &#123; final int callingPid = Binder.getCallingPid(); final int callingUid = Binder.getCallingUid(); final long origId = Binder.clearCallingIdentity(); ComponentName res = mServices.startServiceLocked(caller, service, resolvedType, callingPid, callingUid, callingPackage, userId); Binder.restoreCallingIdentity(origId); return res; &#125; &#125; AMS会通过mServices来完成service的启动过程，mServices的对象类型是ActiveServices，ActiveServices是一个辅助AMS进行Service管理的类，包括Service的启动、绑定和停止。在startService方法的尾部会调用startServiceInnerLocked方法12345678910111213ComponentName startServiceInnerLocked(ServiceMap smap, Intent service, ServiceRecord r, boolean callerFg, boolean addToStarting) throws TransactionTooLargeException &#123; ServiceState stracker = r.getTracker(); if (stracker != null) &#123; stracker.setStarted(true, mAm.mProcessStats.getMemFactorLocked(), r.lastActivity); &#125; r.callStart = false; synchronized (r.stats.getBatteryStats()) &#123; r.stats.startRunningLocked(); &#125; String error = bringUpServiceLocked(r, service.getFlags(), callerFg, false, false); return r.name; &#125; 上述代码中ServiceRecord是描述一个Service记录，ServiceRecord一直贯穿整个Service流程，startServiceInnerLocked并没有完成启动Service的完整流程，而是将后续的过程交给了bringUpServiceLocked，在该方法中又调用了realStartServiceLocked方法:12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182private final void realStartServiceLocked(ServiceRecord r, ProcessRecord app, boolean execInFg) throws RemoteException &#123; r.app = app; r.restartTime = r.lastActivity = SystemClock.uptimeMillis(); final boolean newService = app.services.add(r); bumpServiceExecutingLocked(r, execInFg, "create"); mAm.updateLruProcessLocked(app, false, null); mAm.updateOomAdjLocked(); boolean created = false; try &#123; synchronized (r.stats.getBatteryStats()) &#123; r.stats.startLaunchedLocked(); &#125; mAm.notifyPackageUse(r.serviceInfo.packageName, PackageManager.NOTIFY_PACKAGE_USE_SERVICE); app.forceProcessStateUpTo(ActivityManager.PROCESS_STATE_SERVICE); app.thread.scheduleCreateService(r, r.serviceInfo, mAm.compatibilityInfoForPackageLocked(r.serviceInfo.applicationInfo), app.repProcState); r.postNotification(); created = true; &#125; catch (DeadObjectException e) &#123; Slog.w(TAG, "Application dead when creating service " + r); mAm.appDiedLocked(app); throw e; &#125; finally &#123; if (!created) &#123; // Keep the executeNesting count accurate. final boolean inDestroying = mDestroyingServices.contains(r); serviceDoneExecutingLocked(r, inDestroying, inDestroying); // Cleanup. if (newService) &#123; app.services.remove(r); r.app = null; &#125; // Retry. if (!inDestroying) &#123; scheduleServiceRestartLocked(r, false); &#125; &#125; &#125; if (r.whitelistManager) &#123; app.whitelistManager = true; &#125; requestServiceBindingsLocked(r, execInFg); updateServiceClientActivitiesLocked(app, null, true); // If the service is in the started state, and there are no // pending arguments, then fake up one so its onStartCommand() will // be called. if (r.startRequested &amp;&amp; r.callStart &amp;&amp; r.pendingStarts.size() == 0) &#123; r.pendingStarts.add(new ServiceRecord.StartItem(r, false, r.makeNextStartId(), null, null)); &#125; sendServiceArgsLocked(r, execInFg, true); if (r.delayed) &#123; if (DEBUG_DELAYED_STARTS) Slog.v(TAG_SERVICE, "REM FR DELAY LIST (new proc): " + r); getServiceMap(r.userId).mDelayedStartList.remove(r); r.delayed = false; &#125; if (r.delayedStop) &#123; // Oh and hey we've already been asked to stop! r.delayedStop = false; if (r.startRequested) &#123; if (DEBUG_DELAYED_STARTS) Slog.v(TAG_SERVICE, "Applying delayed stop (from start): " + r); stopServiceLocked(r); &#125; &#125; &#125; 在realStartServiceLocked方法中，首先通过app.thread的scheduleCreateService方法来创建Service对象并调用其onCreate,接着再通过sendServiceArgsLocked方法来调用Service的其他方法，比如onStartCommand,这两个过程均是进程间通信。app.thread对象是IApplicationThread类型，它实际上是一个Binder,它的具体实现是ApplicationThread和ApplicationThreadNative。由于ApplicationThread继承了ApplicationThreadNative,因此只需要看ApplicationThread对Service启动过程的处理即可，这对应着它的scheduleCreateService方法，如下所示：12345678910public final void scheduleCreateService(IBinder token, ServiceInfo info, CompatibilityInfo compatInfo, int processState) &#123; updateProcessState(processState, false); CreateServiceData s = new CreateServiceData(); s.token = token; s.info = info; s.compatInfo = compatInfo; sendMessage(H.CREATE_SERVICE, s); &#125; 通过发送消息给Handler H来完成的。H会接收这个CREATE_ SERVICE消息并通过ActivityThread的handleCreateService方法来完成Service的最终启动，handleCreateService的源码如下所示：12345678910111213141516171819202122private void handleCreateService(CreateServiceData data) &#123; // If we are getting ready to gc after going to the background, well // we are back active so skip it. unscheduleGcIdler(); LoadedApk packageInfo = getPackageInfoNoCheck( data.info.applicationInfo, data.compatInfo); Service service = null; java.lang.ClassLoader cl = packageInfo.getClassLoader(); service = (Service) cl.loadClass(data.info.name).newInstance(); ContextImpl context = ContextImpl.createAppContext(this, packageInfo); context.setOuterContext(service); Application app = packageInfo.makeApplication(false, mInstrumentation); service.attach(context, this, data.info.name, data.token, app, ActivityManagerNative.getDefault()); service.onCreate(); mServices.put(data.token, service); ActivityManagerNative.getDefault().serviceDoneExecuting( data.token, SERVICE_DONE_EXECUTING_ANON, 0, 0); &#125; handleCreateService主要完成了以下几件事：首先通过类加载器创建了Service实例，接着创建ContextImpl对象和Application对象 并通过service.attach方法建立联系，最后调用service.onCreate方法，并将service存储在ActivityThread中的一个列表mServices中1final ArrayMap&lt;IBinder, Service&gt; mServices = new ArrayMap&lt;&gt;(); 由于service的onCreate方法执行了，也就意味着Service已经启动了。除此之外，ActivityThead中还会通过handleServiceArgs方法调用Service的onStartCommand方法。 Service绑定过程和启动过程一样，也是从ContextWrapper开始的：12345@Overridepublic boolean bindService(Intent service, ServiceConnection conn, int flags) &#123; return mBase.bindService(service, conn, flags);&#125; 然后是ContextImpl的bindService方法调用bindServiceCommon方法，然后远程调用AMS的bindService:123456789101112131415161718192021222324252627282930313233private boolean bindServiceCommon(Intent service, ServiceConnection conn, int flags, Handler handler, UserHandle user) &#123; // Keep this in sync with DevicePolicyManager.bindDeviceAdminServiceAsUser. IServiceConnection sd; if (conn == null) &#123; throw new IllegalArgumentException("connection is null"); &#125; if (mPackageInfo != null) &#123; sd = mPackageInfo.getServiceDispatcher(conn, getOuterContext(), handler, flags); &#125; else &#123; throw new RuntimeException("Not supported in system context"); &#125; validateServiceIntent(service); try &#123; IBinder token = getActivityToken(); if (token == null &amp;&amp; (flags&amp;BIND_AUTO_CREATE) == 0 &amp;&amp; mPackageInfo != null &amp;&amp; mPackageInfo.getApplicationInfo().targetSdkVersion &lt; android.os.Build.VERSION_CODES.ICE_CREAM_SANDWICH) &#123; flags |= BIND_WAIVE_PRIORITY; &#125; service.prepareToLeaveProcess(this); int res = ActivityManager.getService().bindService( mMainThread.getApplicationThread(), getActivityToken(), service, service.resolveTypeIfNeeded(getContentResolver()), sd, flags, getOpPackageName(), user.getIdentifier()); if (res &lt; 0) &#123; throw new SecurityException( "Not allowed to bind to service " + service); &#125; return res != 0; &#125; catch (RemoteException e) &#123; throw e.rethrowFromSystemServer(); &#125;&#125; 在该方法中，首先将客户端的ServiceConnection转化为ServiceDispatcher.InnerConnection对象，因为服务绑定是跨进程的，所以ServiceConnection对象必须借助Binder对象才能让远程服务端调用自己的方法。ServiceDispatcher起着连接ServiceConnection和InnerConnection的作用。这个过程由LoadedApk.getServiceDispatcher方法完成：1234567891011121314151617181920212223public final IServiceConnection getServiceDispatcher(ServiceConnection c, Context context, Handler handler, int flags) &#123; synchronized (mServices) &#123; LoadedApk.ServiceDispatcher sd = null; ArrayMap&lt;ServiceConnection, LoadedApk.ServiceDispatcher&gt; map = mServices.get(context); if (map != null) &#123; if (DEBUG) Slog.d(TAG, "Returning existing dispatcher " + sd + " for conn " + c); sd = map.get(c); &#125; if (sd == null) &#123; sd = new ServiceDispatcher(c, context, handler, flags); if (DEBUG) Slog.d(TAG, "Creating new dispatcher " + sd + " for conn " + c); if (map == null) &#123; map = new ArrayMap&lt;&gt;(); mServices.put(context, map); &#125; map.put(c, sd); &#125; else &#123; sd.validate(context, handler); &#125; return sd.getIServiceConnection(); &#125; &#125; 在上面的代码中，mServices是一个ArrayMap，它存储了一个应用当前活动的ServiceConnection和ServiceDispatcher的映射关系，其声明如下：12private final ArrayMap&lt;Context, ArrayMap&lt;ServiceConnection, LoadedApk.ServiceDispatcher&gt;&gt; mServices = new ArrayMap&lt;&gt;(); 系统首先会查找是否存在相同的ServiceConnection,如果不存在就重新创建一个ServiceDispatcher对象，并将其存储在mServices中，其中映射关系的key是ServiceConnection,value是ServiceDispatcher,在ServiceDispatcher的内部又保存了ServiceConnection和InnerConnection对象。当Service和客户端建立连接后，系统会通过InnerConnection来调用ServiceConnection中的onServiceConnected方法，这个过程有可能是跨进程的。当ServiceDispatcher创建好了以后，getServiceDispatcher会 返回其保存的InnerConnection对象。接着调用AMS的bindService 方法，该方法又调用了bindServiceLocked–&gt;bringUpServiceLocked–&gt;realStartServiceLocked，这个过程和上面的StartService过程逻辑类似，最终都是通过ApplicationThread来完成Service的实例创建并调用onCreate方法。和启动Service过程不同的是，绑定过程会调用app.thread的scheduleBindService方法，这个过程的实现在ActivityService的requestServiceBindingsLocked方法中：123456789private final void requestServiceBindingsLocked(ServiceRecord r, boolean execInFg) throws TransactionTooLargeException &#123; for (int i=r.bindings.size()-1; i&gt;=0; i--) &#123; IntentBindRecord ibr = r.bindings.valueAt(i); if (!requestServiceBindingLocked(r, ibr, execInFg, false)) &#123; break; &#125; &#125; &#125; 该方法用到了r.bindings。它是一个ArrayMap，保存了客户端的bind消息：1final ArrayMap&lt;Intent.FilterComparison, IntentBindRecord&gt; bindings = new ArrayMap&lt;Intent.FilterComparison, IntentBindRecord&gt;(); 具体保存方法在AMS一开始的方法bindServiceLocked中：1AppBindRecord b = s.retrieveAppBindingLocked(service, callerApp); 在requestServiceBindingsLocked方法中调用了了requestServiceBindingLocked方法:1234567891011121314151617181920212223242526272829303132333435private final boolean requestServiceBindingLocked(ServiceRecord r, IntentBindRecord i, boolean execInFg, boolean rebind) throws TransactionTooLargeException &#123; if (r.app == null || r.app.thread == null) &#123; // If service is not currently running, can't yet bind. return false; &#125; if (DEBUG_SERVICE) Slog.d(TAG_SERVICE, "requestBind " + i + ": requested=" + i.requested + " rebind=" + rebind); if ((!i.requested || rebind) &amp;&amp; i.apps.size() &gt; 0) &#123; try &#123; bumpServiceExecutingLocked(r, execInFg, "bind"); r.app.forceProcessStateUpTo(ActivityManager.PROCESS_STATE_SERVICE); r.app.thread.scheduleBindService(r, i.intent.getIntent(), rebind, r.app.repProcState); if (!rebind) &#123; i.requested = true; &#125; i.hasBound = true; i.doRebind = false; &#125; catch (TransactionTooLargeException e) &#123; // Keep the executeNesting count accurate. if (DEBUG_SERVICE) Slog.v(TAG_SERVICE, "Crashed while binding " + r, e); final boolean inDestroying = mDestroyingServices.contains(r); serviceDoneExecutingLocked(r, inDestroying, inDestroying); throw e; &#125; catch (RemoteException e) &#123; if (DEBUG_SERVICE) Slog.v(TAG_SERVICE, "Crashed while binding " + r); // Keep the executeNesting count accurate. final boolean inDestroying = mDestroyingServices.contains(r); serviceDoneExecutingLocked(r, inDestroying, inDestroying); return false; &#125; &#125; return true; &#125; 在上述代码中，app.thread这个对象多次出现过，它实际上就是ApplicationThread。ApplicationThread的一系列以schedule开头的方法，其内部都是通过Handler H来中转的，对于scheduleBindService方法来说也是如此，它的实现如下所示：123456789public final void scheduleBindService(IBinder token, Intent intent, boolean rebind, int processState) &#123; updateProcessState(processState, false); BindServiceData s = new BindServiceData(); s.token = token; s.intent = intent; s.rebind = rebind; sendMessage(H.BIND_SERVICE, s); &#125; 在H内部，接收到BIND_SERVICE这类消息时，会交给ActivityThread的handleBindService方法来处理。在handleBindService中，首先根据Service的token取出Service对象，然后调用Service的onBind方法，Service的onBind方法会返回一个Binder对象给客户端使用，原则上来说，Service的onBind方法被调用以后，Service就处于绑定状态了，但是onBind方法是Service的方法，这个时候客户端并不知道已经成功连接Service了，所以还必须调用客户端的ServiceConnection中的onServiceConnected,这个过程是由ActivityManager.getService()的publishService方法来完成的，而前面多次提到，ActivityManager.getService()就是AMS。handleBindService的实现过程如下所示。1234567891011121314151617181920212223242526272829private void handleBindService(BindServiceData data) &#123; Service s = mServices.get(data.token); if (s != null) &#123; try &#123; data.intent.setExtrasClassLoader(s.getClassLoader()); data.intent.prepareToEnterProcess(); try &#123; if (!data.rebind) &#123; IBinder binder = s.onBind(data.intent); ActivityManager.getService().publishService( data.token, data.intent, binder); &#125; else &#123; s.onRebind(data.intent); ActivityManager.getService().serviceDoneExecuting( data.token, SERVICE_DONE_EXECUTING_ANON, 0, 0); &#125; ensureJitEnabled(); &#125; catch (RemoteException ex) &#123; throw ex.rethrowFromSystemServer(); &#125; &#125; catch (Exception e) &#123; if (!mInstrumentation.onException(s, e)) &#123; throw new RuntimeException( "Unable to bind to service " + s + " with " + data.intent + ": " + e.toString(), e); &#125; &#125; &#125; &#125; Service有一个特性，当多次绑定同一个Service时，Service的onBind方法只会执行一次，除非Service被终止了。当Service的onBind执行以后，系统还需要告知客户端已经成功连接Service了。根据上面的分析，这个过程由AMS的publishService方法来实现:12345678910111213public void publishService(IBinder token, Intent intent, IBinder service) &#123; // Refuse possible leaked file descriptors if (intent != null &amp;&amp; intent.hasFileDescriptors() == true) &#123; throw new IllegalArgumentException("File descriptors passed in Intent"); &#125; synchronized(this) &#123; if (!(token instanceof ServiceRecord)) &#123; throw new IllegalArgumentException("Invalid service token"); &#125; mServices.publishServiceLocked((ServiceRecord)token, intent, service); &#125; &#125; 从_上面代码可以看出，AMS的publishService方法将具体的工作交给了ActiveServices类型的mServices对象来处理。ActiveServices的publishServiceLocked方法看起来很复杂，但其实核心代码就只有一- 句话: c.conn.connected(r.name,service)， 其中c的类型是ConnectionRecord，c.comn的类型是ServiceDispatcher.InnerConnection, service就是Service的onBind方法返回的Binder对象。为了分析具体的逻辑，下面看一下ServiceDispatcher.InnerConnection的定义：123456789101112131415private static class InnerConnection extends IServiceConnection.Stub &#123; final WeakReference&lt;LoadedApk.ServiceDispatcher&gt; mDispatcher; InnerConnection(LoadedApk.ServiceDispatcher sd) &#123; mDispatcher = new WeakReference&lt;LoadedApk.ServiceDispatcher&gt;(sd); &#125; public void connected(ComponentName name, IBinder service, boolean dead) throws RemoteException &#123; LoadedApk.ServiceDispatcher sd = mDispatcher.get(); if (sd != null) &#123; sd.connected(name, service, dead); &#125; &#125; &#125; 从InnerConnection的定义可以看出来，它的connected方法又调用了ServiceDispatcher的connected方法1234567public void connected(ComponentName name, IBinder service, boolean dead) &#123; if (mActivityThread != null) &#123; mActivityThread.post(new RunConnection(name, service, 0, dead)); &#125; else &#123; doConnected(name, service, dead); &#125; &#125; 对于Service的绑定过程来讲，ServiceDispatcher中的mActivityThread就是一个handler，它就是ActivityThread中的H，从Service的创建过程来讲，mActivityTHread不会为null，这样一来，RunConnection就可以经由H的post方法从而运行在主线程中，因此，客户端的ServiceConnection中的方法回调是在主线程中执行的。123456789101112131415161718192021private final class RunConnection implements Runnable &#123; RunConnection(ComponentName name, IBinder service, int command, boolean dead) &#123; mName = name; mService = service; mCommand = command; mDead = dead; &#125; public void run() &#123; if (mCommand == 0) &#123; doConnected(mName, mService, mDead); &#125; else if (mCommand == 1) &#123; doDeath(mName, mService); &#125; &#125; final ComponentName mName; final IBinder mService; final int mCommand; final boolean mDead; &#125; 很显然，RunConnection的run方法也是简单调用了ServiceDispatcher的doConnected方法，由于ServiceDispatcher内部保存了客户端的ServiceConnection对象，因此它可以很方便地调用ServiceConnection对象的onServiceConnected方法，如下所示。至此，bindService的过程完成。 以上]]></content>
      <tags>
        <tag>Android</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Android广播]]></title>
    <url>%2F2018%2F07%2F31%2FAndroid%E5%B9%BF%E6%92%AD%2F</url>
    <content type="text"><![CDATA[面试APUS的时候被问到广播：面试官：聊一下广播吧。我：广播啊，四大组件之一，自己创建个类继承自BroadcastReceiver，重写onReceive()方法，需要注意的是不要在这个方法中做耗时操作。注册的话可以在AndroidManifest文件中静态注册，也可以在代码中动态注册。都做完了之后就可以调用sendBroadCast()方法发送广播了。面试官：了解广播注册过程么？我：哈~！这个没怎么看过。面试官：了解怎么接收到的广播么？我：没有。。。。 广播的注册过程《Android开发艺术探索》9.4章广播的注册分为静态注册和动态注册，其中静态注册的广播在应用安装时由系统自动完成注册，具体来说是由PMS ( PackageManagerService)来完成整个注册过程的，除了广播以外，其他三大组件也都是在应用安装时由PMS解析并注册的。这里只分析广播的动态注册的过程，动态注册的过程是从ContextWrapper的registerReceiver方法开始的，和Activity以及Service一样 。ContextWrapper并 没有做实际的工作，而是将注册过程直接交给了ContextImpl来完成，如下所示：123456789@Overridepublic Intent registerReceiver(BroadcastReceiver receiver, IntentFilter filter) &#123; return mBase.registerReceiver(receiver, filter);&#125;@Overridepublic Intent registerReceiver(BroadcastReceiver receiver, IntentFilter filter,String broadcastPermission, Handler scheduler) &#123; return registerReceiverInternal(receiver, getUserId(), filter, broadcastPermission, scheduler, getOuterContext(), 0);&#125; 这里的registerReceiver方法是重载方法，最终调用了registerReceiverInternal方法：123456789101112131415161718192021222324252627282930313233private Intent registerReceiverInternal(BroadcastReceiver receiver, int userId, IntentFilter filter, String broadcastPermission, Handler scheduler, Context context, int flags) &#123; IIntentReceiver rd = null; if (receiver != null) &#123; if (mPackageInfo != null &amp;&amp; context != null) &#123; if (scheduler == null) &#123; scheduler = mMainThread.getHandler(); &#125; rd = mPackageInfo.getReceiverDispatcher( receiver, context, scheduler, mMainThread.getInstrumentation(), true); &#125; else &#123; if (scheduler == null) &#123; scheduler = mMainThread.getHandler(); &#125; rd = new LoadedApk.ReceiverDispatcher( receiver, context, scheduler, null, true).getIIntentReceiver(); &#125; &#125; try &#123; final Intent intent = ActivityManager.getService().registerReceiver( mMainThread.getApplicationThread(), mBasePackageName, rd, filter, broadcastPermission, userId, flags); if (intent != null) &#123; intent.setExtrasClassLoader(getClassLoader()); intent.prepareToEnterProcess(); &#125; return intent; &#125; catch (RemoteException e) &#123; throw e.rethrowFromSystemServer(); &#125; &#125; 在上面的代码中，系统首先从mPackageInfo获取IIntentReceiver对象，然后再采用跨进程的方式向AMS发送广播注册的请求。之所以采用IIntentReceiver而不是直接采用BroadcastReceiver ,这是因为上述注册过程是一个进程间通信的过程，而BroadcastReceiver作为Android的一个组件是不能直接跨进程传递的，所以需要通过IIntentReceiver来中转一下。毫无疑问，IIntentReceiver必须是一个Binder接口，它的具体实现是LoadedApk.ReceiverDispatcher.InnerReceiver, ReceiverDispatcher的内部同时保存了BroadcastReceiver和InnerReceiver,这样当接收到广播时，ReceiverDispatcher可以很方便地调用BroadcastReceiver的onReceive方法。看一下LoadedApk.getReceiverDispatcher方法：1234567891011121314151617181920212223242526272829public IIntentReceiver getReceiverDispatcher(BroadcastReceiver r, Context context, Handler handler, Instrumentation instrumentation, boolean registered) &#123; synchronized (mReceivers) &#123; LoadedApk.ReceiverDispatcher rd = null; ArrayMap&lt;BroadcastReceiver, LoadedApk.ReceiverDispatcher&gt; map = null; if (registered) &#123; map = mReceivers.get(context); if (map != null) &#123; rd = map.get(r); &#125; &#125; if (rd == null) &#123; rd = new ReceiverDispatcher(r, context, handler, instrumentation, registered); if (registered) &#123; if (map == null) &#123; map = new ArrayMap&lt;BroadcastReceiver, LoadedApk.ReceiverDispatcher&gt;(); mReceivers.put(context, map); &#125; map.put(r, rd); &#125; &#125; else &#123; rd.validate(context, handler); &#125; rd.mForgotten = false; return rd.getIIntentReceiver(); &#125; &#125; 很显然，getReceiverDispatcher方法重新创建了一个ReceiverDispatcher对象并将其保存的InnerReceiver对象作为返回值返回，其中InnerReceiver对象和BroadcastReceiver都是在ReceiverDispatcher的构造方法中被保存起来的。由于注册广播的真正实现过程是在AMS中，因此我们需要看一下AMS的具体实现。AMS的registerReceiver方法看起来很长，其实关键点就只有下面一部分，最终会把远程的InnerReceiver对象以及IntentFilter对象存储起来，这样整个广播的注册过程就完成了，代码如下所示。123456789public Intent registerReceiver(IApplicationThread caller, String callerPackage,IIntentReceiver receiver, IntentFilter filter, String permission, int userId) &#123; // The first sticky in the list is returned directly back to the client. Intent sticky = allSticky != null ? allSticky.get(0) : null; ReceiverList rl = mRegisteredReceivers.get(receiver.asBinder()); BroadcastFilter bf = new BroadcastFilter(filter, rl, callerPackage,permission, callingUid, userId); rl.add(bf); mReceiverResolver.addFilter(bf); return sticky;&#125; 广播的发送过程当通过send方法来发送广播时，AMS会查找出匹配的广播接收者并将广播发送给它们处理。广播的发送有几种类型:普通广播、有序广播和粘性广播，有序广播和粘性广播与普通广播相比具有不同的特性，但是它们的发送/接收过程的流程是类似的，因此这里只分析普通厂播的实现。广播的发送和接收，其本质是一个过程的两个阶段。这里从广播的发送可以说起，广播的发送仍然开始于ContextWrapper的sendBroadcast方法，之所以不是Context,那是因为Context的sendBroadcast是-一个抽象方法。和广播的注册过程一样，ContextWrapper的sendBroadcast方法仍然什么都不做，只是把事情交给ContextImpl去处理，ContextImpl的sendBroadcast方法的源码如下所示。1234567891011121314@Override public void sendBroadcast(Intent intent) &#123; warnIfCallingFromSystemProcess(); String resolvedType = intent.resolveTypeIfNeeded(getContentResolver()); try &#123; intent.prepareToLeaveProcess(this); ActivityManager.getService().broadcastIntent( mMainThread.getApplicationThread(), intent, resolvedType, null, Activity.RESULT_OK, null, null, null, AppOpsManager.OP_NONE, null, false, false, getUserId()); &#125; catch (RemoteException e) &#123; throw e.rethrowFromSystemServer(); &#125; &#125; 从_上面的代码来看，ContextImpl也是几乎什么事都没干，它直接向AMS发起了一个异步请求用于发送广播。因此，下面直接看AMS对广播发送过程的处理，AMS的broadcastIntent方法又调用了broadcastIntentLocked,在这个方法的开始有这么一行：12// By default broadcasts do not go to stopped apps.intent.addFlags(Intent.FLAG_EXCLUDE_STOPPED_PACKAGES); 从Android3.1开始广播默认情况下广播不会发送给已经停止的应用。这是因为系统在Android3.1中为Intent添加了两个标记位，分别是FLAG_INCLUDE_STOPPED_PACKAGES和FLAG_EXCLUDE_STOPPED_PACKAGES，用来控制广播是否要对处于停止状态的应用起作用，它们的含义如下所示。 FLAG_INCLUDE_STOPPED_PACKAGES 表示包含已经停止的应用，这个时候广播会发送给已经停止的应用。 FLAG_EXCLUDE_STOPPED_PACKAGES 表示不包含已经停止的应用，这个时候广播不会发送给已经停止的应用。 从Android3.1开始，系统为所有广播默认添加了FLAG_EXCLUDE_STOPPED_PACKAGES标志，这样做是为了防止广播无意间或者在不必要的时候调起已经停止运行的应用。如果的确需要调起未启动的应用，那么只需要为广播的Intent添加FLAG_INCLUDE_STOPPED_PACKAGES标记即可。当FLAG_EXCLUDE_STOPPED_PACKAGES和FLAG_INCLUDE_STOPPED_PACKAGES两种标记位共存时,以FLAG_INCLUDE_STOPPED_PACKAGES为准。这里需要补充一下，一个应用处于停止状态分为两种情形:第一种是应用安装后未运行，第二种是应用被手动或者其他应用强停了。Android3.1中广播的这个特性同样会影响开机广播，从Android3.1开始，处于停止状态的应用同样无法接收到开机广播，而在Android 3.1之前，处于停止状态的应用是可以收到开机广播的。在broadcastIntentLocked的内部，会根据intent-filter查找出匹配的广播接收者并经过一系列的条件过滤，最终会将满足条件的广播接收者添加到BroadcastQueue中，接着BroadcastQueue就会将广播发送给相应的广播接收者，这个过程的源码如下所示。123456789101112131415161718192021222324252627if ((receivers != null &amp;&amp; receivers.size() &gt; 0) || resultTo != null) &#123; BroadcastQueue queue = broadcastQueueForIntent(intent); BroadcastRecord r = new BroadcastRecord(queue, intent, callerApp, callerPackage, callingPid, callingUid, resolvedType, requiredPermissions, appOp, brOptions, receivers, resultTo, resultCode, resultData, resultExtras, ordered, sticky, false, userId); if (DEBUG_BROADCAST) Slog.v(TAG_BROADCAST, "Enqueueing ordered broadcast " + r + ": prev had " + queue.mOrderedBroadcasts.size()); if (DEBUG_BROADCAST) Slog.i(TAG_BROADCAST, "Enqueueing broadcast " + r.intent.getAction()); boolean replaced = replacePending &amp;&amp; queue.replaceOrderedBroadcastLocked(r); if (!replaced) &#123; queue.enqueueOrderedBroadcastLocked(r); queue.scheduleBroadcastsLocked(); &#125; &#125; else &#123; // There was nobody interested in the broadcast, but we still want to record // that it happened. if (intent.getComponent() == null &amp;&amp; intent.getPackage() == null &amp;&amp; (intent.getFlags()&amp;Intent.FLAG_RECEIVER_REGISTERED_ONLY) == 0) &#123; // This was an implicit broadcast... let's record it for posterity. addBroadcastStatLocked(intent.getAction(), callerPackage, 0, 0, 0); &#125; &#125; 将广播添加到BroadCastQueue之后，接着调用了scheduleBroadcastsLocked方法：1234567891011public void scheduleBroadcastsLocked() &#123; if (DEBUG_BROADCAST) Slog.v(TAG_BROADCAST, "Schedule broadcasts [" + mQueueName + "]: current=" + mBroadcastsScheduled); if (mBroadcastsScheduled) &#123; return; &#125; mHandler.sendMessage(mHandler.obtainMessage(BROADCAST_INTENT_MSG, this)); mBroadcastsScheduled = true; &#125; 方法内发送了一个BROADCAST_INTENT_MSG消息，handler接到消息后，调用了processNextBroadcast方法 1234567891011121314151617181920212223242526private final class BroadcastHandler extends Handler &#123; public BroadcastHandler(Looper looper) &#123; super(looper, null, true); &#125; @Override public void handleMessage(Message msg) &#123; switch (msg.what) &#123; case BROADCAST_INTENT_MSG: &#123; if (DEBUG_BROADCAST) Slog.v(TAG_BROADCAST, "Received BROADCAST_INTENT_MSG"); processNextBroadcast(true); &#125; break; case BROADCAST_TIMEOUT_MSG: &#123; synchronized (mService) &#123; broadcastTimeoutLocked(true); &#125; &#125; break; case SCHEDULE_TEMP_WHITELIST_MSG: &#123; DeviceIdleController.LocalService dic = mService.mLocalDeviceIdleController; if (dic != null) &#123; dic.addPowerSaveTempWhitelistAppDirect(UserHandle.getAppId(msg.arg1),msg.arg2, true, (String)msg.obj); &#125; &#125; break; &#125; &#125; &#125; 收到消息后会调用processNextBroadcast方法，内容如下：123456789101112131415161718192021222324252627// First, deliver any non-serialized broadcasts right away. while (mParallelBroadcasts.size() &gt; 0) &#123; r = mParallelBroadcasts.remove(0); r.dispatchTime = SystemClock.uptimeMillis(); r.dispatchClockTime = System.currentTimeMillis(); if (Trace.isTagEnabled(Trace.TRACE_TAG_ACTIVITY_MANAGER)) &#123; Trace.asyncTraceEnd(Trace.TRACE_TAG_ACTIVITY_MANAGER, createBroadcastTraceTitle(r, BroadcastRecord.DELIVERY_PENDING), System.identityHashCode(r)); Trace.asyncTraceBegin(Trace.TRACE_TAG_ACTIVITY_MANAGER, createBroadcastTraceTitle(r, BroadcastRecord.DELIVERY_DELIVERED), System.identityHashCode(r)); &#125; final int N = r.receivers.size(); for (int i=0; i&lt;N; i++) &#123; Object target = r.receivers.get(i); if (DEBUG_BROADCAST) Slog.v(TAG_BROADCAST, "Delivering non-ordered on [" + mQueueName + "] to registered " + target + ": " + r); deliverToRegisteredReceiverLocked(r, (BroadcastFilter)target, false, i); &#125; addBroadcastToHistoryLocked(r); &#125; 可以看到，无序广播存储在mParallelBroadcasts中，系统会遍历mParallelBroadcasts并将其中的广播发送给它们所有的接收者，具体的发送过程是通过deliverToRegisteredReceiverLocked方法来实现的。deliverToRegisteredReceiverLocked方法负责将一个广播发送给一个特定的接收者，它内部调用了performReceiveLocked方法来完成具体的发送过程:1performReceiveLocked(r.callerApp, r.resultTo,new Intent(r.intent), r.resultCode,r.resultData, r.resultExtras, false, false, r.userId); performReceiveLocked方法的实现如下所示。由于接收广播会调起应用程序，因此app.thread不为null，根据前面的分析我们知道这里的app.thread仍然指ApplicationThread。12345678910111213141516171819202122232425262728293031323334void performReceiveLocked(ProcessRecord app, IIntentReceiver receiver,Intent intent, int resultCode, String data, Bundle extras,boolean ordered, boolean sticky, int sendingUser) throws RemoteException &#123; // Send the intent to the receiver asynchronously using one-way binder calls. if (app != null) &#123; if (app.thread != null) &#123; // If we have an app thread, do the call through that so it is // correctly ordered with other one-way calls. try &#123; app.thread.scheduleRegisteredReceiver(receiver, intent, resultCode, data, extras, ordered, sticky, sendingUser, app.repProcState); // TODO: Uncomment this when (b/28322359) is fixed and we aren't getting // DeadObjectException when the process isn't actually dead. //&#125; catch (DeadObjectException ex) &#123; // Failed to call into the process. It's dying so just let it die and move on. // throw ex; &#125; catch (RemoteException ex) &#123; // Failed to call into the process. It's either dying or wedged. Kill it gently. synchronized (mService) &#123; Slog.w(TAG, "Can't deliver broadcast to " + app.processName + " (pid " + app.pid + "). Crashing it."); app.scheduleCrash("can't deliver broadcast"); &#125; throw ex; &#125; &#125; else &#123; // Application has died. Receiver doesn't exist. throw new RemoteException("app.thread must not be null"); &#125; &#125; else &#123; receiver.performReceive(intent, resultCode, data, extras, ordered, sticky, sendingUser); &#125; &#125; ApplicationThread的scheduleRegisteredReceiver的实现比较简单，它通过InnerReceiver来实现广播的接收:12345678910// This function exists to make sure all receiver dispatching is// correctly ordered, since these are one-way calls and the binder driver// applies transaction ordering per object for such calls.public void scheduleRegisteredReceiver(IIntentReceiver receiver, Intent intent, int resultCode, String dataStr, Bundle extras, boolean ordered, boolean sticky, int sendingUser, int processState) throws RemoteException &#123; updateProcessState(processState, false); receiver.performReceive(intent, resultCode, dataStr, extras, ordered, sticky, sendingUser);&#125; InnerReceiver的performReceive方法会调用LoadedApk.ReceiverDispatcher的performReceive方法，LoadedApk.ReceiverDispatcher的performReceive方法的实现如下所示:123456789101112131415161718192021public void performReceive(Intent intent, int resultCode, String data,Bundle extras, boolean ordered, boolean sticky, int sendingUser) &#123; final Args args = new Args(intent, resultCode, data, extras, ordered, sticky, sendingUser); if (intent == null) &#123; Log.wtf(TAG, "Null intent received"); &#125; else &#123; if (ActivityThread.DEBUG_BROADCAST) &#123; int seq = intent.getIntExtra("seq", -1); Slog.i(ActivityThread.TAG, "Enqueueing broadcast " + intent.getAction() + " seq=" + seq + " to " + mReceiver); &#125; &#125; if (intent == null || !mActivityThread.post(args.getRunnable())) &#123; if (mRegistered &amp;&amp; ordered) &#123; IActivityManager mgr = ActivityManager.getService(); if (ActivityThread.DEBUG_BROADCAST) Slog.i(ActivityThread.TAG, "Finishing sync broadcast to " + mReceiver); args.sendFinished(mgr); &#125; &#125;&#125; 在上面的代码中，会创建一个Args对象并通过mActivityThread的post方法来执行Args中的逻辑，而Args实现了Runnable接口。mActivityThread是一个Handler，它其实就是ActivityThread中的mH，mH的类型是ActivityThread的内部类H。在Args的run方法中有如下几行代码:1234final BroadcastReceiver receiver = mReceiver;final boolean ordered = mOrdered;receiver.setPendingResult(this);receiver.onReceive(mContext, intent); 这个时候BroadcastReceiver的onReceive方法被执行了，也就是说应用已经接收到广播了，同时onReceive方法是在广播接收者的主线程中被调用的。 以上]]></content>
      <tags>
        <tag>Android</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[View绘制过程]]></title>
    <url>%2F2018%2F07%2F29%2FView%E7%BB%98%E5%88%B6%E8%BF%87%E7%A8%8B%2F</url>
    <content type="text"><![CDATA[抄的《Android开发艺术探索》第四章ViewRoot对应于ViewRootImpl类，它是连接WindowManager和DecorView的纽带，View的三大流程均是通过ViewRoot来完成的。在ActivityThread中，当Activity对象被创建完毕后，会将DecorView添加到Window中，同时会创建ViewRootImpl对象，并将ViewRootImpl对象和DecorView建立关联，View的绘制流程是从ViewRoot的performTraversals方法开始的，它经过measure、layout和draw三个过程才能最终将一个View绘制出来，其中measure用来测量View的宽和高，layout用来确定View在父容器中的放置位置，而draw则负责将View绘制在屏幕上。 performTraversals会依次调用performMeasure、performLayout和performDraw三个方法，这三个方法分别完成顶级View的measure、layout和draw这三大流程，其中在performMeasure中会调用measure方法，在measure方法中又会调用onMeasure方法，在onMeasure方法中则会对所有的子元素进行measure过程，这个时候measure流程就从父容器传递到子元素中了，这样就完成了一次measure过程。接着子元素会重复父容器的measure过程，如此反复就完成了整个View树的遍历。同理，performLayout和performDraw的传递流程和performMeasure是类似的，唯一不同的是，performDraw的传递过程是在draw方法中通过dispatchDraw来实现的，不过这并没有本质区别。 measure过程决定了View的宽/高，Measure完成以后，可以通过getMeasuredWidth和getMeasuredHeight方法来获取到View测量后的宽/高，在几乎所有的情况下它都等同于View最终的宽/高，但是特殊情况除外，这点在本章后面会进行说明。Layout过程决定了View的四个顶点的坐标和实际的View的宽/高，完成以后，可以通过getTop、getBottom、getLeft和getRight来拿到View的四个顶点的位置，并可以通过getWidth和getHeight方法来拿到View的最终宽/高。Draw过程则决定了View的显示，只有draw方法完成以后View的内容才能呈现在屏幕上。 DecorView作为顶级View，一般情况下它内部会包含一个竖直方向的LinearLayout，在这个LinearLayout里面有上下两个部分（具体情况和Android版本及主题有关），上面是标题栏，下面是内容栏。在Activity中我们通过setContentView所设置的布局文件其实就是被加到内容栏之中的，而内容栏的id是content，因此可以理解为Activity指定布局的方法不叫setview而叫setContentView，因为我们的布局的确加到了id为content的FrameLayout中。如何得到content呢？可以这样：ViewGroup content= findViewById(R.android.id.content)。如何得到我们设置的View呢？可以这样：content.getChildAt(0)。同时，通过源码我们可以知道，DecorView其实是一个FrameLayout，View层的事件都先经过DecorView，然后才传递给我们的View。 MeasureSpecMeasureSpec在很大程度上决定了一个View的尺寸规格，之所以说是很大程度上是因为这个过程还受父容器的影响，因为父容器影响View的MeasureSpec的创建过程。在测量过程中，系统会将View的LayoutParams根据父容器所施加的规则转换成对应的MeasureSpec，然后再根据这个measureSpec来测量出View的宽/高。这里的宽/高是测量宽/高，不一定等于View的最终宽/高。MeasureSpec代表一个32位int值，高2位代表SpecMode，低30位代表SpecSize，SpecMode是指测量模式，而SpecSize是指在某种测量模式下的规格大小。123456789101112131415161718private static final int MODE_SHIFT = 30;private static final int MODE_MASK = 0x3 &lt;&lt; MODE_SHIFT;public static final int UNSPECIFIED = 0 &lt;&lt; MODE_SHIFT;public static final int EXACTLY = 1 &lt;&lt; MODE_SHIFT;public static final int AT_MOST = 2 &lt;&lt; MODE_SHIFT;public static int makeMeasureSpec(int size,int mode) &#123; if (sUseBrokenMakeMeasureSpec) &#123; return size + mode; &#125; else &#123; return (size &amp; ~MODE_MASK) | (mode &amp; MODE_MASK); &#125;&#125;public static int getMode(int measureSpec) &#123; return (measureSpec &amp; MODE_MASK);&#125;public static int getSize(int measureSpec) &#123; return (measureSpec &amp; ~MODE_MASK);&#125; MeasureSpec通过将SpecMode和SpecSize打包成一个int值来避免过多的对象内存分配，为了方便操作，其提供了打包和解包方法。SpecMode和SpecSize也是一个int值，一组SpecMode和SpecSize可以打包为一个MeasureSpec，而一个MeasureSpec可以通过解包的形式来得出其原始的SpecMode和SpecSize，需要注意的是这里提到的MeasureSpec是指MeasureSpec所代表的int值，而并非MeasureSpec本身。SpecMode有三类，每一类都表示特殊的含义，如下所示。 UNSPECIFIED 父容器不对View有任何限制，要多大给多大，这种情况一般用于系统内部，表示一种测量的状态。 EXACTLY 父容器已经检测出View所需要的精确大小，这个时候View的最终大小就是SpecSize所指定的值。它对应于LayoutParams中的match_parent和具体的数值这两种模式。 AT_MOST 父容器指定了一个可用大小即SpecSize，View的大小不能大于这个值，具体是什么值要看不同View的具体实现。它对应于LayoutParams中的wrap_content。 MeasureSpec和LayoutParams在View测量的时候，系统会将LayoutParams在父容器的约束下转换成对应的MeasureSpec，然后再根据这个MeasureSpec来确定View测量后的宽/高。需要注意的是，MeasureSpec不是唯一由LayoutParams决定的，LayoutParams需要和父容器一起才能决定View的MeasureSpec，从而进一步决定View的宽/高。另外，对于顶级View（即DecorView）和普通View来说，MeasureSpec的转换过程略有不同。对于DecorView，其MeasureSpec由窗口的尺寸和其自身的LayoutParams来共同确定；对于普通View，其MeasureSpec由父容器的MeasureSpec和自身的LayoutParams来共同决定，MeasureSpec一旦确定后，onMeasure中就可以确定View的测量宽/高。对于DecorView来说，在ViewRootImpl中的measureHierarchy方法中有如下一段代码，它展示了DecorView的MeasureSpec的创建过程，其中desiredWindowWidth和desiredWindowHeight是屏幕的尺寸:12345678910111213141516171819202122childWidthMeasureSpec = getRootMeasureSpec(desiredWindowWidth,lp.width);childHeightMeasureSpec = getRootMeasureSpec(desiredWindowHeight,lp.height);performMeasure(childWidthMeasureSpec,childHeightMeasureSpec);private static int getRootMeasureSpec(int windowSize,int rootDimension) &#123; int measureSpec; switch (rootDimension) &#123; case ViewGroup.LayoutParams.MATCH_PARENT: // Window can't resize. Force root view to be windowSize. measureSpec = MeasureSpec.makeMeasureSpec(windowSize,MeasureSpec.EXACTLY); break; case ViewGroup.LayoutParams.WRAP_CONTENT: // Window can resize. Set max size for root view. measureSpec = MeasureSpec.makeMeasureSpec(windowSize,MeasureSpec.AT_MOST); break; default: // Window wants to be an exact size. Force root view to be that size. measureSpec = MeasureSpec.makeMeasureSpec(rootDimension,Measure-Spec.EXACTLY); break; &#125; return measureSpec;&#125; 通过上述代码，DecorView的MeasureSpec的产生过程就很明确了，具体来说其遵守如下规则，根据它的LayoutParams中的宽/高的参数来划分。 LayoutParams.MATCH_PARENT：精确模式，大小就是窗口的大小； LayoutParams.WRAP_CONTENT：最大模式，大小不定，但是不能超过窗口的大小； 固定大小（比如100dp）：精确模式，大小为LayoutParams中指定的大小。对于普通View来说，这里是指我们布局中的View，View的measure过程由ViewGroup传递而来，先看一下ViewGroup的measureChildWithMargins方法：123456protected void measureChildWithMargins(View child,int parentWidthMeasureSpec,int widthUsed,int parentHeightMeasureSpec,int heightUsed) &#123; final MarginLayoutParams lp = (MarginLayoutParams) child.getLayout-Params(); final int childWidthMeasureSpec = getChildMeasureSpec(parentWidthMeasureSpec,mPaddingLeft + mPaddingRight + lp.leftMargin + lp.rightMargin+ widthUsed,lp.width); final int childHeightMeasureSpec = getChildMeasureSpec(parentHeight-MeasureSpec,mPaddingTop + mPaddingBottom + lp.topMargin + lp.bottomMargin+ heightUsed,lp.height); child.measure(childWidthMeasureSpec,childHeightMeasureSpec);&#125; 上述方法会对子元素进行measure，在调用子元素的measure方法之前会先通过getChildMeasureSpec方法来得到子元素的MeasureSpec。从代码来看，很显然，子元素的MeasureSpec的创建与父容器的MeasureSpec和子元素本身的LayoutParams有关，此外还和View的margin及padding有关，具体情况可以看一下ViewGroup的getChildMeasureSpec方法，如下所示:1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162public static int getChildMeasureSpec(int spec,int padding,int child-Dimension) &#123; int specMode = MeasureSpec.getMode(spec); int specSize = MeasureSpec.getSize(spec); int size = Math.max(0,specSize -padding); int resultSize = 0; int resultMode = 0; switch (specMode) &#123; // Parent has imposed an exact size on us case MeasureSpec.EXACTLY: if (childDimension =&gt; 0) &#123; resultSize = childDimension; resultMode = MeasureSpec.EXACTLY; &#125; else if (childDimension == LayoutParams.MATCH_PARENT) &#123; // Child wants to be our size. So be it. resultSize = size; resultMode = MeasureSpec.EXACTLY; &#125; else if (childDimension == LayoutParams.WRAP_CONTENT) &#123; // Child wants to determine its own size. It can't be // bigger than us. resultSize = size; resultMode = MeasureSpec.AT_MOST; &#125; break; // Parent has imposed a maximum size on us case MeasureSpec.AT_MOST: if (childDimension =&gt; 0) &#123; // Child wants a specific size... so be it resultSize = childDimension; resultMode = MeasureSpec.EXACTLY; &#125; else if (childDimension == LayoutParams.MATCH_PARENT) &#123; // Child wants to be our size,but our size is not fixed. // Constrain child to not be bigger than us. resultSize = size; resultMode = MeasureSpec.AT_MOST; &#125; else if (childDimension == LayoutParams.WRAP_CONTENT) &#123; // Child wants to determine its own size. It can't be // bigger than us. resultSize = size; resultMode = MeasureSpec.AT_MOST; &#125; break; // Parent asked to see how big we want to be case MeasureSpec.UNSPECIFIED: if (childDimension =&gt; 0) &#123; // Child wants a specific size... let him have it resultSize = childDimension; resultMode = MeasureSpec.EXACTLY; &#125; else if (childDimension == LayoutParams.MATCH_PARENT) &#123; // Child wants to be our size... find out how big it should // be resultSize = 0; resultMode = MeasureSpec.UNSPECIFIED; &#125; else if (childDimension == LayoutParams.WRAP_CONTENT) &#123; // Child wants to determine its own size.... find out how // big it should be resultSize = 0; resultMode = MeasureSpec.UNSPECIFIED; &#125; break; &#125; return MeasureSpec.makeMeasureSpec(resultSize,resultMode);&#125; 它的主要作用是根据父容器的MeasureSpec同时结合View本身的LayoutParams来确定子元素的MeasureSpec，参数中的padding是指父容器中已占用的空间大小，因此子元素可用的大小为父容器的尺寸减去padding，具体代码如下所示:12int specSize = MeasureSpec.getSize(spec);int size = Math.max(0,specSize -padding); 这里简单说一下，当View采用固定宽/高的时候，不管父容器的MeasureSpec是什么，View的MeasureSpec都是精确模式并且其大小遵循Layoutparams中的大小。当View的宽/高是match_parent时，如果父容器的模式是精准模式，那么View也是精准模式并且其大小是父容器的剩余空间；如果父容器是最大模式，那么View也是最大模式并且其大小不会超过父容器的剩余空间。当View的宽/高是wrap_content时，不管父容器的模式是精准还是最大化，View的模式总是最大化并且大小不能超过父容器的剩余空间。在我们的分析中漏掉了UNSPECIFIED模式，那是因为这个模式主要用于系统内部多次Measure的情形，一般来说，我们不需要关注此模式。 View的工作流程measure过程measure过程要分情况来看，如果只是一个原始的View，那么通过measure方法就完成了其测量过程，如果是一个ViewGroup，除了完成自己的测量过程外，还会遍历去调用所有子元素的measure方法，各个子元素再递归去执行这个流程。 View的measure过程 View的measure过程由其measure方法来完成，measure方法是一个final类型的方法，这意味着子类不能重写此方法，在View的measure方法中会去调用View的onMeasure方法，因此只需要看onMeasure的实现即可：123456789101112131415161718protected void onMeasure(int widthMeasureSpec,int heightMeasureSpec) &#123; setMeasuredDimension(getDefaultSize(getSuggestedMinimumWidth(),widthMeasureSpec),getDefaultSize(getSuggestedMinimumHeight(),heightMeasureSpec));&#125;public static int getDefaultSize(int size,int measureSpec) &#123; int result = size; int specMode = MeasureSpec.getMode(measureSpec); int specSize = MeasureSpec.getSize(measureSpec); switch (specMode) &#123; case MeasureSpec.UNSPECIFIED: result = size; break; case MeasureSpec.AT_MOST: case MeasureSpec.EXACTLY: result = specSize; break; &#125; return result;&#125; 可以看出，getDefaultSize这个方法的逻辑很简单，对于我们来说，我们只需要看AT_MOST和EXACTLY这两种情况。简单地理解，其实getDefaultSize返回的大小就是measureSpec中的specSize，而这个specSize就是View测量后的大小，这里多次提到测量后的大小，是因为View最终的大小是在layout阶段确定的，所以这里必须要加以区分，但是几乎所有情况下View的测量大小和最终大小是相等的。至于UNSPECIFIED这种情况，一般用于系统内部的测量过程，在这种情况下，View的大小为getDefaultSize的第一个参数size，即宽/高分别为getSuggestedMinimumWidth和getSuggestedMinimumHeight这两个方法的返回值，看一下它们的源码:123456protected int getSuggestedMinimumWidth() &#123; return (mBackground == null) ? mMinWidth : max(mMinWidth,mBackground.getMinimumWidth());&#125;protected int getSuggestedMinimumHeight() &#123; return (mBackground == null) ? mMinHeight : max(mMinHeight,mBackground.getMinimumHeight());&#125; 这里只分析getSuggestedMinimumWidth方法的实现，getSuggestedMinimumHeight和它的实现原理是一样的。从getSuggestedMinimumWidth的代码可以看出，如果View没有设置背景，那么View的宽度为mMinWidth，而mMinWidth对应于android:minWidth这个属性所指定的值，因此View的宽度即为android:minWidth属性所指定的值。这个属性如果不指定，那么mMinWidth则默认为0；如果View指定了背景，则View的宽度为max(mMinWidth,mBackground.getMinimumWidth())。mMinWidth的含义我们已经知道了，那么mBackground.getMinimumWidth()是什么呢？我们看一下Drawable的getMinimumWidth方法，如下所示:1234public int getMinimumWidth() &#123; final int intrinsicWidth = getIntrinsicWidth(); return intrinsicWidth &gt; 0 ? intrinsicWidth : 0;&#125; 可以看出，getMinimumWidth返回的就是Drawable的原始宽度，前提是这个Drawable有原始宽度，否则就返回0。这里再总结一下getSuggestedMinimumWidth的逻辑：如果View没有设置背景，那么返回android:minWidth这个属性所指定的值，这个值可以为0；如果View设置了背景，则返回android:minWidth和背景的最小宽度这两者中的最大值，getSuggestedMinimumWidth和getSuggestedMinimumHeight的返回值就是View在UNSPECIFIED情况下的测量宽/高。从getDefaultSize方法的实现来看，View的宽/高由specSize决定，所以我们可以得出如下结论：直接继承View的自定义控件需要重写onMeasure方法并设置wrap_content时的自身大小，否则在布局中使用wrap_content就相当于使用match_parent。从上述代码中我们知道，如果View在布局中使用wrap_content，那么它的specMode是AT_MOST模式，在这种模式下，它的宽/高等于specSize；这种情况下View的specSize是parentSize，而parentSize是父容器中目前可以使用的大小，也就是父容器当前剩余的空间大小。很显然，View的宽/高就等于父容器当前剩余的空间大小，这种效果和在布局中使用match_parent完全一致。如何解决这个问题呢？也很简单，代码如下所示：1234567891011121314protected void onMeasure(int widthMeasureSpec,int heightMeasureSpec) &#123; super.onMeasure(widthMeasureSpec,heightMeasureSpec); int widthSpecMode = MeasureSpec.getMode(widthMeasureSpec); int widthSpecSize = MeasureSpec.getSize(widthMeasureSpec); int heightSpecMode = MeasureSpec.getMode(heightMeasureSpec); int heightSpecSize = MeasureSpec.getSize(heightMeasureSpec); if (widthSpecMode == MeasureSpec.AT_MOST &amp;&amp; heightSpecMode == MeasureSpec.AT_MOST) &#123; setMeasuredDimension(mWidth,mHeight); &#125; else if (widthSpecMode == MeasureSpec.AT_MOST) &#123; setMeasuredDimension(mWidth,heightSpecSize); &#125; else if (heightSpecMode == MeasureSpec.AT_MOST) &#123; setMeasuredDimension(widthSpecSize,mHeight); &#125;&#125; 在上面的代码中，我们只需要给View指定一个默认的内部宽/高（mWidth和mHeight），并在wrap_content时设置此宽/高即可。对于非wrap_content情形，我们沿用系统的测量值即可，至于这个默认的内部宽/高的大小如何指定，这个没有固定的依据，根据需要灵活指定即可。如果查看TextView、ImageView等的源码就可以知道，针对wrap_content情形，它们的onMeasure方法均做了特殊处理。 ViewGroup的measure过程 对于ViewGroup来说，除了完成自己的measure过程以外，还会遍历去调用所有子元素的measure方法，各个子元素再递归去执行这个过程。和View不同的是，ViewGroup是一个抽象类，因此它没有重写View的onMeasure方法，但是它提供了一个叫measureChildren的方法，如下所示。12345678910protected void measureChildren(int widthMeasureSpec,int heightMeasureSpec) &#123; final int size = mChildrenCount; final View[] children = mChildren; for (int i = 0; i &lt; size; ++i) &#123; final View child = children[i]; if ((child.mViewFlags &amp; VISIBILITY_MASK) != GONE) &#123; measureChild(child,widthMeasureSpec,heightMeasureSpec); &#125; &#125;&#125; 从上述代码来看，ViewGroup在measure时，会对每一个子元素进行measure，measureChild这个方法的实现也很好理解，如下所示123456protected void measureChild(View child,int parentWidthMeasureSpec,int parentHeightMeasureSpec) &#123; final LayoutParams lp = child.getLayoutParams(); final int childWidthMeasureSpec = getChildMeasureSpec(parentWidth-MeasureSpec,mPaddingLeft + mPaddingRight,lp.width); final int childHeightMeasureSpec = getChildMeasureSpec(parentHeight-MeasureSpec,mPaddingTop + mPaddingBottom,lp.height); child.measure(childWidthMeasureSpec,childHeightMeasureSpec);&#125; 很显然，measureChild的思想就是取出子元素的LayoutParams，然后再通过getChildMeasureSpec来创建子元素的MeasureSpec，接着将MeasureSpec直接传递给View的measure方法来进行测量。我们知道，ViewGroup并没有定义其测量的具体过程，这是因为ViewGroup是一个抽象类，其测量过程的onMeasure方法需要各个子类去具体实现，比如LinearLayout、RelativeLayout等。 layout过程Layout的作用是ViewGroup用来确定子元素的位置，当ViewGroup的位置被确定后，它在onLayout中会遍历所有的子元素并调用其layout方法，在layout方法中onLayout方法又会被调用。Layout过程和measure过程相比就简单多了，layout方法确定View本身的位置，而onLayout方法则会确定所有子元素的位置，先看View的layout方法，如下所示。12345678910111213141516171819202122232425public void layout(int l,int t,int r,int b) &#123; if ((mPrivateFlags3 &amp; PFLAG3_MEASURE_NEEDED_BEFORE_LAYOUT) != 0) &#123; onMeasure(mOldWidthMeasureSpec,mOldHeightMeasureSpec); mPrivateFlags3 &amp;= ~PFLAG3_MEASURE_NEEDED_BEFORE_LAYOUT; &#125; int oldL = mLeft; int oldT = mTop; int oldB = mBottom; int oldR = mRight; boolean changed = isLayoutModeOptical(mParent) ?setOpticalFrame(l,t,r,b) : setFrame(l,t,r,b); if (changed || (mPrivateFlags &amp; PFLAG_LAYOUT_REQUIRED) == PFLAG_LAYOUT_REQUIRED) &#123; onLayout(changed,l,t,r,b); mPrivateFlags &amp;= ~PFLAG_LAYOUT_REQUIRED; ListenerInfo li = mListenerInfo; if (li != null &amp;&amp; li.mOnLayoutChangeListeners != null) &#123; ArrayList&lt;OnLayoutChangeListener&gt; listenersCopy =(ArrayList&lt;OnLayoutChangeListener&gt;)li.mOnLayout-ChangeListeners.clone(); int numListeners = listenersCopy.size(); for (int i = 0; i &lt; numListeners; ++i) &#123; listenersCopy.get(i).onLayoutChange(this,l,t,r,b,oldL,oldT,oldR,oldB); &#125; &#125; &#125; mPrivateFlags &amp;= ~PFLAG_FORCE_LAYOUT; mPrivateFlags3 |= PFLAG3_IS_LAID_OUT;&#125; layout方法的大致流程如下：首先会通过setFrame方法来设定View的四个顶点的位置，即初始化mLeft、mRight、mTop和mBottom这四个值，View的四个顶点一旦确定，那么View在父容器中的位置也就确定了；接着会调用onLayout方法，这个方法的用途是父容器确定子元素的位置，和onMeasure方法类似，onLayout的具体实现同样和具体的布局有关，所以View和ViewGroup均没有真正实现onLayout方法。接下来，我们可以看一下LinearLayout的onLayout方法，如下所示。1234567protected void onLayout(boolean changed,int l,int t,int r,int b) &#123; if (mOrientation == VERTICAL) &#123; layoutVertical(l,t,r,b); &#125; else &#123; layoutHorizontal(l,t,r,b); &#125;&#125; LinearLayout中onLayout的实现逻辑和onMeasure的实现逻辑类似，这里选择layoutVertical继续讲解，为了更好地理解其逻辑，这里只给出了主要的代码：12345678910111213141516171819202122void layoutVertical(int left,int top,int right,int bottom) &#123; ...... final int count = getVirtualChildCount(); for (int i = 0; i &lt; count; i++) &#123; final View child = getVirtualChildAt(i); if (child == null) &#123; childTop += measureNullChild(i); &#125; else if (child.getVisibility() != GONE) &#123; final int childWidth = child.getMeasuredWidth(); final int childHeight = child.getMeasuredHeight(); final LinearLayout.LayoutParams lp =(LinearLayout.LayoutParams) child.getLayoutParams(); ...... if (hasDividerBeforeChildAt(i)) &#123; childTop += mDividerHeight; &#125; childTop += lp.topMargin; setChildFrame(child,childLeft,childTop + getLocationOffset(child),childWidth,childHeight); childTop += childHeight + lp.bottomMargin + getNextLocation-Offset(child); i += getChildrenSkipCount(child,i); &#125; &#125;&#125; 这里分析一下layoutVertical的代码逻辑，可以看到，此方法会遍历所有子元素并调用setChildFrame方法来为子元素指定对应的位置，其中childTop会逐渐增大，这就意味着后面的子元素会被放置在靠下的位置，这刚好符合竖直方向的LinearLayout的特性。至于setChildFrame，它仅仅是调用子元素的layout方法而已，这样父元素在layout方法中完成自己的定位以后，就通过onLayout方法去调用子元素的layout方法，子元素又会通过自己的layout方法来确定自己的位置，这样一层一层地传递下去就完成了整个View树的layout过程。setChildFrame方法的实现如下所示。123private void setChildFrame(View child,int left,int top,int width,int height) &#123; child.layout(left,top,left + width,top + height);&#125; 我们注意到，setChildFrame中的width和height实际上就是子元素的测量宽/高，从下面的代码可以看出这一点：123final int childWidth = child.getMeasuredWidth();final int childHeight = child.getMeasuredHeight();setChildFrame(child,childLeft,childTop + getLocationOffset(child),childWidth,childHeight); 而在layout方法中会通过setFrame去设置子元素的四个顶点的位置，在setFrame中有如下几句赋值语句，这样一来子元素的位置就确定了：1234mLeft = left;mTop = top;mRight = right;mBottom = bottom; View的测量宽/高和最终/宽高有什么区别？这个问题可以具体为：View的getMeasuredWidth和getWidth这两个方法有什么区别，至于getMeasuredHeight和getHeight的区别和前两者完全一样。为了回答这个问题，首先，我们看一下getwidth和getHeight这两个方法的具体实现：1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859public final int getWidth() &#123; return mRight -mLeft;&#125;public final int getHeight() &#123; return mBottom -mTop;&#125;``` 从`getWidth`和`getHeight`的源码再结合`mLeft`、`mRight`、`mTop`和`mBottom`这四个变量的赋值过程来看，`getWidth`方法的返回值刚好就是`View`的测量宽度，而`getHeight`方法的返回值也刚好就是`View`的测量高度。经过上述分析，现在我们可以回答这个问题了：在`View`的默认实现中，`View`的测量宽/高和最终宽/高是相等的，只不过测量宽/高形成于`View`的`measure`过程，而最终宽/高形成于`View`的`layout`过程，即两者的赋值时机不同，测量宽/高的赋值时机稍微早一些。因此，在日常开发中，我们可以认为`View`的`测量宽/高`就`等于``最终宽/高`，但是的确存在某些特殊情况会导致两者不一致.##### draw过程Draw过程就比较简单了，它的作用是将View绘制到屏幕上面。View的绘制过程遵循如下几步：* 绘制背景background.draw(canvas)。* 绘制自己（onDraw）。* 绘制children（dispatchDraw）。* 绘制装饰（onDrawScrollBars）。这一点通过draw方法的源码可以明显看出来，如下所示。``` java public void draw(Canvas canvas) &#123; final int privateFlags = mPrivateFlags; final boolean dirtyOpaque = (privateFlags &amp; PFLAG_DIRTY_MASK) == PFLAG_DIRTY_OPAQUE &amp;&amp;(mAttachInfo == null || !mAttachInfo.mIgnoreDirtyState); mPrivateFlags = (privateFlags &amp; ~PFLAG_DIRTY_MASK) | PFLAG_DRAWN; /* * Draw traversal performs several drawing steps which must be executed * in the appropriate order: * * 1. Draw the background * 2. If necessary,save the canvas' layers to prepare for fading * 3. Draw view's content * 4. Draw children * 5. If necessary,draw the fading edges and restore layers * 6. Draw decorations (scrollbars for instance) */ // Step 1,draw the background,if needed int saveCount; if (!dirtyOpaque) &#123; drawBackground(canvas); &#125; // skip step 2 &amp; 5 if possible (common case) final int viewFlags = mViewFlags; boolean horizontalEdges = (viewFlags &amp; FADING_EDGE_HORIZONTAL) != 0; boolean verticalEdges = (viewFlags &amp; FADING_EDGE_VERTICAL) != 0; if (!verticalEdges &amp;&amp; !horizontalEdges) &#123; // Step 3,draw the content if (!dirtyOpaque) onDraw(canvas); // Step 4,draw the children dispatchDraw(canvas); // Step 6,draw decorations (scrollbars) onDrawScrollBars(canvas); if (mOverlay != null &amp;&amp; !mOverlay.isEmpty()) &#123; mOverlay.getOverlayView().dispatchDraw(canvas); &#125; // we're done... return; &#125; ...&#125; View绘制过程的传递是通过dispatchDraw来实现的，dispatchDraw会遍历调用所有子元素的draw方法，如此draw事件就一层层地传递了下去。View有一个特殊的方法setWillNotDraw，先看一下它的源码，如下所示。12345678910111213/*** If this view doesn't do any drawing on its own,set this flag to* allow further optimizations. By default,this flag is not set on* View,but could be set on some View subclasses such as ViewGroup.** Typically,if you override &#123;@link #onDraw(android.graphics.Canvas)&#125;* you should clear this flag.** @param willNotDraw whether or not this View draw on its own*/public void setWillNotDraw(boolean willNotDraw) &#123; setFlags(willNotDraw ? WILL_NOT_DRAW : 0,DRAW_MASK);&#125; 从setWillNotDraw这个方法的注释中可以看出，如果一个View不需要绘制任何内容，那么设置这个标记位为true以后，系统会进行相应的优化。默认情况下，View没有启用这个优化标记位，但是ViewGroup会默认启用这个优化标记位。这个标记位对实际开发的意义是：当我们的自定义控件继承于ViewGroup并且本身不具备绘制功能时，就可以开启这个标记位从而便于系统进行后续的优化。当然，当明确知道一个ViewGroup需要通过onDraw来绘制内容时，我们需要显式地关闭WILL_NOT_DRAW这个标记位。 以上]]></content>
      <tags>
        <tag>Android</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[View事件分发]]></title>
    <url>%2F2018%2F07%2F29%2FView%E4%BA%8B%E4%BB%B6%E5%88%86%E5%8F%91%2F</url>
    <content type="text"><![CDATA[抄的《Android开发艺术探索》3.4.1 和 3.4.2 MotionEvent在手指接触屏幕后所产生的一系列事件中，典型的事件类型有如下几种： ACTION_DOWN——手指刚接触屏幕； ACTION_MOVE——手指在屏幕上移动； ACTION_UP——手机从屏幕上松开的一瞬间还有其他的事件可以参考MotionEvent.java类 TouchSlopTouchSlop是系统所能识别出的被认为是滑动的最小距离，换句话说，当手指在屏幕上滑动时，如果两次滑动之间的距离小于这个常量，那么系统就不认为你是在进行滑动操作，这是一个常量，和设备有关，在不同设备上这个值可能是不同的，通过如下方式即可获取这个常量：ViewConfiguration. get(getContext()).getScaledTouchSlop()。当我们在处理滑动时，可以利用这个常量来做一些过滤，比如当两次滑动事件的滑动距离小于这个值，我们就可以认为未达到滑动距离的临界值，因此就可以认为它们不是滑动，这样做可以有更好的用户体验可以在源码中找到这个常量的定义，在frameworks/base/core/res/res/values/config.xml文件中。 所谓点击事件的事件分发，其实就是对MotionEvent事件的分发过程，即当一个MotionEvent产生了以后，系统需要把这个事件传递给一个具体的View，而这个传递的过程就是分发过程。点击事件的分发过程由三个很重要的方法来共同完成：dispatchTouchEvent、onInterceptTouchEvent和onTouchEvent，下面我们先介绍一下这几个方法 public boolean dispatchTouchEvent(MotionEvent ev)用来进行事件的分发。如果事件能够传递给当前View，那么此方法一定会被调用，返回结果受当前View的onTouchEvent和下级View的dispatchTouchEvent方法的影响，表示是否消耗当前事件。 public boolean onInterceptTouchEvent(MotionEvent event)在上述方法内部调用，用来判断是否拦截某个事件，如果当前View拦截了某个事件，那么在同一个事件序列当中，此方法不会被再次调用，返回结果表示是否拦截当前事件。 public boolean onTouchEvent(MotionEvent event)在dispatchTouchEvent方法中调用，用来处理点击事件，返回结果表示是否消耗当前事件，如果不消耗，则在同一个事件序列中，当前View无法再次接收到事件. 123456789public boolean dispatchTouchEvent(MotionEvent ev) &#123; boolean consume = false; if (onInterceptTouchEvent(ev)) &#123; consume = onTouchEvent(ev); &#125; else &#123; consume = child.dispatchTouchEvent(ev); &#125; return consume;&#125; 对于一个根ViewGroup来说，点击事件产生后，首先会传递给它，这时它的dispatchTouchEvent就会被调用，如果这个ViewGroup的onInterceptTouchEvent方法返回true就表示它要拦截当前事件，接着事件就会交给这个ViewGroup处理，即它的onTouchEvent方法就会被调用；如果这个ViewGroup的onInterceptTouchEvent方法返回false就表示它不拦截当前事件，这时当前事件就会继续传递给它的子元素，接着子元素的dispatchTouchEvent方法就会被调用，如此反复直到事件被最终处理。当一个View需要处理事件时，如果它设置了OnTouchListener，那么OnTouchListener中的onTouch方法会被回调。这时事件如何处理还要看onTouch的返回值，如果返回false，则当前View的onTouchEvent方法会被调用；如果返回true，那么onTouchEvent方法将不会被调用。由此可见，给View设置的OnTouchListener，其优先级比onTouchEvent要高。在onTouchEvent方法中，如果当前设置的有OnClickListener，那么它的onClick方法会被调用。可以看出，平时我们常用的OnClickListener，其优先级最低，即处于事件传递的尾端。当一个点击事件产生后，它的传递过程遵循如下顺序：Activity -&gt; Window -&gt; View，即事件总是先传递给Activity，Activity再传递给Window，最后Window再传递给顶级View。顶级View接收到事件后，就会按照事件分发机制去分发事件。考虑一种情况，如果一个View的onTouchEvent返回false，那么它的父容器的onTouchEvent将会被调用，依此类推。如果所有的元素都不处理这个事件，那么这个事件将会最终传递给Activity处理，即Activity的onTouchEvent方法会被调用。 事件传递机制 同一个事件序列是指从手指接触屏幕的那一刻起，到手指离开屏幕的那一刻结束，在这个过程中所产生的一系列事件，这个事件序列以down事件开始，中间含有数量不定的move事件，最终以up事件结束。 正常情况下，一个事件序列只能被一个View拦截且消耗。因为一旦一个元素拦截了某此事件，那么同一个事件序列内的所有事件都会直接交给它处理，因此同一个事件序列中的事件不能分别由两个View同时处理，但是通过特殊手段可以做到，比如一个View将本该自己处理的事件通过onTouchEvent强行传递给其他View处理。 某个View一旦决定拦截，那么这一个事件序列都只能由它来处理（如果事件序列能够传递给它的话），并且它的onInterceptTouchEvent不会再被调用。这条也很好理解，就是说当一个View决定拦截一个事件后，那么系统会把同一个事件序列内的其他方法都直接交给它来处理，因此就不用再调用这个View的onInterceptTouchEvent去询问它是否要拦截了。 某个View一旦开始处理事件，如果它不消耗ACTION_DOWN事件（onTouchEvent返回了false），那么同一事件序列中的其他事件都不会再交给它来处理，并且事件将重新交由它的父元素去处理，即父元素的onTouchEvent会被调用。意思就是事件一旦交给一个View处理，那么它就必须消耗掉，否则同一事件序列中剩下的事件就不再交给它来处理了。 如果View不消耗除ACTION_DOWN以外的其他事件，那么这个点击事件会消失，此时父元素的onTouchEvent并不会被调用，并且当前View可以持续收到后续的事件，最终这些消失的点击事件会传递给Activity处理。 ViewGroup默认不拦截任何事件。Android源码中ViewGroup的onInterceptTouch-Event方法默认返回false。 View没有onInterceptTouchEvent方法，一旦有点击事件传递给它，那么它的onTouchEvent方法就会被调用。 View的onTouchEvent默认都会消耗事件（返回true），除非它是不可点击的（clickable 和longClickable同时为false）。View的longClickable属性默认都为false，clickable属性要分情况，比如Button的clickable属性默认为true，而TextView的clickable属性默认为false。 View的enable属性不影响onTouchEvent的默认返回值。哪怕一个View是disable状态的，只要它的clickable或者longClickable有一个为true，那么它的onTouchEvent就返回true。 onClick会发生的前提是当前View是可点击的，并且它收到了down和up的事件。 事件传递过程是由外向内的，即事件总是先传递给父元素，然后再由父元素分发给子View，通过requestDisallowInterceptTouchEvent方法可以在子元素中干预父元素的事件分发过程，但是ACTION_DOWN事件除外。 事件分发源码 Activity对点击事件的分发过程 点击事件用MotionEvent来表示，当一个点击操作发生时，事件最先传递给当前Activity，由Activity的dispatchTouchEvent来进行事件派发，具体的工作是由Activity内部的Window来完成的。Window会将事件传递给decor view，decor view一般就是当前界面的底层容器（即setContentView所设置的View的父容器），通过Activity.getWindow.getDecorView()可以获得。我们先从Activity的dispatchTouchEvent开始分析。12345678910111213141516171819/** * Called to process touch screen events. You can override this to * intercept all touch screen events before they are dispatched to the * window. Be sure to call this implementation for touch screen events * that should be handled normally. * * @param ev The touch screen event. * * @return boolean Return true if this event was consumed. */ public boolean dispatchTouchEvent(MotionEvent ev) &#123; if (ev.getAction() == MotionEvent.ACTION_DOWN) &#123; onUserInteraction(); &#125; if (getWindow().superDispatchTouchEvent(ev)) &#123; return true; &#125; return onTouchEvent(ev); &#125; 在window类的注释中 12345678910/** * Abstract base class for a top-level window look and behavior policy. An * instance of this class should be used as the top-level view added to the * window manager. It provides standard UI policies such as a background, title * area, default key processing, etc. * * &lt;p&gt;The only existing implementation of this abstract class is * android.view.PhoneWindow, which you should instantiate when needing a * Window. */ 首先事件开始交给Activity所附属的Window进行分发，如果返回true，整个事件循环就结束了，返回false意味着事件没人处理，所有View的onTouchEvent都返回了false，那么Activity的onTouchEvent就会被调用。其中Window是个抽象类，而其中的superDispatchTouchEvent方法也是个抽象方法。在PhoneWindows中1234@Override public boolean superDispatchTouchEvent(MotionEvent event) &#123; return mDecor.superDispatchTouchEvent(event); &#125; 调用了DecorView的superDispatchTouchEvent方法，我们可以看一下DecorView：12345public class DecorView extends FrameLayout implements RootViewSurfaceTaker, WindowCallbacks &#123;public boolean superDispatchTouchEvent(MotionEvent event) &#123; return super.dispatchTouchEvent(event); &#125;&#125; 目前事件传递到了DecorView这里，由于DecorView继承自FrameLayout且是父View，所以最终事件会传递给View。从这里开始，事件已经传递到顶级View了，即在Activity中通过setContentView所设置的View，另外顶级View也叫根View，顶级View一般来说都是ViewGroup。 顶级View对点击事件的分发过程 点击事件达到顶级View（一般是一个ViewGroup）以后，会调用ViewGroup的dispatchTouchEvent方法，然后的逻辑是这样的：如果顶级ViewGroup拦截事件即onInterceptTouchEvent返回true，则事件由ViewGroup处理，这时如果ViewGroup的mOnTouchListener被设置，则onTouch会被调用，否则onTouchEvent会被调用。也就是说，如果都提供的话，onTouch会屏蔽掉onTouchEvent。在onTouchEvent中，如果设置了mOnClickListener，则onClick会被调用。如果顶级ViewGroup不拦截事件，则事件会传递给它所在的点击事件链上的子View，这时子View的dispatchTouchEvent会被调用。到此为止，事件已经从顶级View传递给了下一层View，接下来的传递过程和顶级View是一致的，如此循环，完成整个事件的分发。具体代码可以看一下ViewGroup.dispatchTouchEvent()方法。 View对点击事件的处理 View对点击事件的处理过程稍微简单一些，这里的View不包含ViewGroup。View对点击事件的处理过程就比较简单了，因为View（这里不包含ViewGroup）是一个单独的元素，它没有子元素因此无法向下传递事件，所以它只能自己处理事件。从上面的源码可以看出View对点击事件的处理过程，首先会判断有没有设置OnTouchListener，如果OnTouchListener中的onTouch方法返回true，那么onTouchEvent就不会被调用，可见OnTouchListener的优先级高于onTouchEvent，这样做的好处是方便在外界处理点击事件。接着再分析onTouchEvent的实现。先看当View处于不可用状态下点击事件的处理过程，如下所示。很显然，不可用状态下的View照样会消耗点击事件，尽管它看起来不可用。接着再分析onTouchEvent的实现。先看当View处于不可用状态下点击事件的处理过程，如下所示。很显然，不可用状态下的View照样会消耗点击事件，尽管它看起来不可用。123456789if ((viewFlags &amp; ENABLED_MASK) == DISABLED) &#123; if (action == MotionEvent.ACTION_UP &amp;&amp; (mPrivateFlags &amp; PFLAG_PRESSED) != 0) &#123; setPressed(false); &#125; mPrivateFlags3 &amp;= ~PFLAG3_FINGER_DOWN; // A disabled view that is clickable still consumes the touch // events, it just doesn't respond to them. return clickable; &#125; 接下来如果View设置有代理，还会执行代理的onTouchEvent方法，12345if (mTouchDelegate != null) &#123; if (mTouchDelegate.onTouchEvent(event)) &#123; return true; &#125; &#125; 接下来就是对事件序列的处理12345678if (clickable || (viewFlags &amp; TOOLTIP) == TOOLTIP) &#123; switch (action) &#123; case MotionEvent.ACTION_UP:break; case MotionEvent.ACTION_DOWN:break; case MotionEvent.ACTION_CANCEL:break; case MotionEvent.ACTION_MOVE:break; &#125;&#125; 从上面的代码来看，只要View的CLICKABLE和LONG_CLICKABLE有一个为true，那么它就会消耗这个事件，即onTouchEvent方法返回true，不管它是不是DISABLE状态，然后就是当ACTION_UP事件发生时，会触发performClick方法，如果View设置了OnClickListener，那么performClick方法内部会调用它的onClick方法。View的LONG_CLICKABLE属性默认为false，而CLICKABLE属性是否为false和具体的View有关，确切来说是可点击的View其CLICKABLE为true，不可点击的View其CLICKABLE为false，比如Button是可点击的，TextView是不可点击的。通过setClickable和setLongClickable可以分别改变View的CLICKABLE和LONG_CLICKABLE属性。另外，setOnClickListener会自动将View的CLICKABLE设为true，setOnLongClickListener则会自动将View的LONG_CLICKABLE设为true。 处理滑动冲突了解了点击事件的处理过程，就可以比较好的处理滑动冲突了 父容器拦截处理 击事情都先经过父容器的拦截处理，如果父容器需要此事件就拦截，如果不需要此事件就不拦截。外部拦截法需要重写父容器的onInterceptTouchEvent方法，在内部做相应的拦截即可。12345678910111213141516171819202122232425262728public boolean onInterceptTouchEvent(MotionEvent event) &#123; boolean intercepted = false; int x = (int) event.getX(); int y = (int) event.getY(); switch (event.getAction()) &#123; case MotionEvent.ACTION_DOWN: &#123; intercepted = false; break; &#125; case MotionEvent.ACTION_MOVE: &#123; if (父容器需要当前点击事件) &#123; intercepted = true; &#125; else &#123; intercepted = false; &#125; break; &#125; case MotionEvent.ACTION_UP: &#123; intercepted = false; break; &#125; default: break; &#125; mLastXIntercept = x; mLastYIntercept = y; return intercepted;&#125; 针对不同的滑动冲突，只需要修改父容器需要当前点击事件这个条件即可，其他均不需做修改并且也不能修改。这里对上述代码再描述一下，在onInterceptTouchEvent方法中，首先是ACTION_DOWN这个事件，父容器必须返回false，即不拦截ACTION_DOWN事件，这是因为一旦父容器拦截了ACTION_DOWN，那么后续的ACTION_MOVE和ACTION_UP事件都会直接交由父容器处理，这个时候事件没法再传递给子元素了；其次是ACTION_MOVE事件，这个事件可以根据需要来决定是否拦截，如果父容器需要拦截就返回true，否则返回false；最后是ACTION_UP事件，这里必须要返回false，因为ACTION_UP事件本身没有太多意义。假设事件交由子元素处理，如果父容器在ACTION_UP时返回了true，就会导致子元素无法接收到ACTION_UP事件，这个时候子元素中的onClick事件就无法触发，但是父容器比较特殊，一旦它开始拦截任何一个事件，那么后续的事件都会交给它来处理，而ACTION_UP作为最后一个事件也必定可以传递给父容器，即便父容器的onInterceptTouchEvent方法在ACTION_UP时返回了false。 子元素拦截事件 父容器不拦截任何事件，所有的事件都传递给子元素，如果子元素需要此事件就直接消耗掉，否则就交由父容器进行处理，这种方法和Android中的事件分发机制不一致，需要配合requestDisallowInterceptTouchEvent()方法才能正常工作，使用起来较外部拦截法稍显复杂。1234567891011121314151617181920212223242526public boolean dispatchTouchEvent(MotionEvent event) &#123; int x = (int) event.getX(); int y = (int) event.getY(); switch (event.getAction()) &#123; case MotionEvent.ACTION_DOWN: &#123; parent.requestDisallowInterceptTouchEvent(true); break; &#125; case MotionEvent.ACTION_MOVE: &#123; int deltaX = x -mLastX; int deltaY = y -mLastY; if (父容器需要此类点击事件)) &#123; parent.requestDisallowInterceptTouchEvent(false); &#125; break; &#125; case MotionEvent.ACTION_UP: &#123; break; &#125; default: break; &#125; mLastX = x; mLastY = y; return super.dispatchTouchEvent(event);&#125; 除了子元素需要做处理以外，父元素也要默认拦截除了ACTION_DOWN以外的其他事件，这样当子元素调用parent.requestDisallowInterceptTouchEvent(false)方法时，父元素才能继续拦截所需的事件。因为ACTION_DOWN事件并不受FLAG_DISALLOW_INTERCEPT这个标记位的控制，所以一旦父容器拦截ACTION_DOWN事件，那么所有的事件都无法传递到子元素中去，这样内部拦截就无法起作用了。 以上]]></content>
      <tags>
        <tag>Android</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Activity启动模式，启动过程]]></title>
    <url>%2F2018%2F07%2F26%2FActivity%E5%90%AF%E5%8A%A8%E6%A8%A1%E5%BC%8F%EF%BC%8C%E5%90%AF%E5%8A%A8%E8%BF%87%E7%A8%8B%2F</url>
    <content type="text"><![CDATA[面试总结，关于Activity启动模式、启动过程，Intent匹配规则、App启动流程等 启动模式： standard：标准模式，这也是系统的默认模式。每次启动一个Activity都会重新创建一个新的实例，不管这个实例是否已经存在。 singleTop：栈顶复用模式。在这种模式下，如果新Activity已经位于任务栈的栈顶，那么此Activity不会被重新创建，同时它的onNewIntent方法会被回调，通过此方法的参数我们可以取出当前请求的信息。需要注意的是，这个Activity的onCreate、onStart不会被系统调用，因为它并没有发生改变。如果新Activity的实例已存在但不是位于栈顶，那么新Activity仍然会重新重建。 singleTask：栈内复用模式。这是一种单实例模式，在这种模式下，只要Activity在一个栈中存在，那么多次启动此Activity都不会重新创建实例，和singleTop一样，系统也会回调其onNewIntent。 singleInstance：单实例模式。这是一种加强的singleTask模式，它除了具有singleTask模式的所有特性外，还加强了一点，那就是具有此种模式的Activity只能单独地位于一个任务栈中， 还有一个参数 TaskAffinity,这个参数标识了一个Activity所需要的任务栈的名字，默认情况下，所有Activity所需的任务栈的名字为应用的包名。当然，我们可以为每个Activity都单独指定TaskAffinity属性，这个属性值必须不能和包名相同，否则就相当于没有指定。TaskAffinity属性主要和singleTask启动模式或者allowTaskReparenting属性配对使用，在其他情况下没有意义。还有Activity中能够影响启动模式、运行状态的标记位： FLAG_ACTIVITY_NEW_TASK 这个标记位的作用是为Activity指定“singleTask”启动模式，其效果和在XML中指定该启动模式相同。 FLAG_ACTIVITY_SINGLE_TOP 这个标记位的作用是为Activity指定“singleTop”启动模式，其效果和在XML中指定该启动模式相同。 FLAG_ACTIVITY_CLEAR_TOP 具有此标记位的Activity，当它启动时，在同一个任务栈中所有位于它上面的Activity都要出栈。这个模式一般需要和FLAG_ACTIVITY_NEW_TASK配合使用，在这种情况下，被启动Activity的实例如果已经存在，那么系统会调用它的onNewIntent。如果被启动的Activity采用standard模式启动，那么它连同它之上的Activity都要出栈，系统会创建新的Activity实例并放入栈顶。通过1.2.1节中的分析可以知道，singleTask启动模式默认就具有此标记位的效果。 FLAG_ACTIVITY_EXCLUDE_FROM_RECENTS 具有这个标记的Activity不会出现在历史Activity的列表中，当某些情况下我们不希望用户通过历史列表回到我们的Activity的时候这个标记比较有用。它等同于在XML中指定Activity的属性android:excludeFromRecents=”true”。 Intent匹配规则启动Activity分为两种，显式调用和隐式调用。显式调用需要明确地指定被启动对象的组件信息，包括包名和类名，而隐式调用则不需要明确指定组件信息。原则上一个Intent不应该既是显式调用又是隐式调用，如果二者共存的话以显式调用为主。显式调用很简单，这里主要介绍一下隐式调用。隐式调用需要Intent能够匹配目标组件的IntentFilter中所设置的过滤信息，如果不匹配将无法启动目标Activity。为了匹配过滤列表，需要同时匹配过滤列表中的action、category、data信息，否则匹配失败。一个过滤列表中的action、category和data可以有多个，所有的action、category、data分别构成不同类别，同一类别的信息共同约束当前类别的匹配过程。只有一个Intent同时匹配action类别、category类别、data类别才算完全匹配，只有完全匹配才能成功启动目标Activity。另外一点，一个Activity中可以有多个intent-filter，一个Intent只要能匹配任何一组intent-filter即可成功启动对应的Activity。 action的匹配规则action是一个字符串，系统预定义了一些action，同时我们也可以在应用中定义自己的action。action的匹配规则是Intent中的action必须能够和过滤规则中的action匹配，这里说的匹配是指action的字符串值完全一样。一个过滤规则中可以有多个action，那么只要Intent中的action能够和过滤规则中的任何一个action相同即可匹配成功。需要注意的是，Intent中如果没有指定action，那么匹配失败。另外，action区分大小写，大小写不同字符串相同的action会匹配失败。 category的匹配规则category是一个字符串，系统预定义了一些category，同时我们也可以在应用中定义自己的category。category的匹配规则和action不同，它要求Intent中如果含有category，那么所有的category都必须和过滤规则中的其中一个category相同。换句话说，Intent中如果出现了category，不管有几个category，对于每个category来说，它必须是过滤规则中已经定义了的category。当然，Intent中可以没有category，如果没有category的话，按照上面的描述，这个Intent仍然可以匹配成功。这里要注意下它和action匹配过程的不同，action是要求Intent中必须有一个action且必须能够和过滤规则中的某个action相同，而category要求Intent可以没有category，但是如果你一旦有category，不管有几个，每个都要能够和过滤规则中的任何一个category相同。 data的匹配规则data的匹配规则和action类似，如果过滤规则中定义了data，那么Intent中必须也要定义可匹配的data。在介绍data的匹配规则之前，我们需要先了解一下data的结构，因为data稍微有些复杂1234567&lt;data android:scheme="string" android:host="string" android:port="string" android:path="string" android:pathPattern="string" android:pathPrefix="string" android:mimeType="string" /&gt; data由两部分组成，mimeType和URI。mimeType指媒体类型，比如image/jpeg、audio/mpeg4-generic和video/*等，可以表示图片、文本、视频等不同的媒体格式，而URI中包含的数据就比较多了，下面是URI的结构：&lt;scheme&gt;://&lt;host&gt;:&lt;port&gt;/[&lt;path&gt;|&lt;pathPrefix&gt;|&lt;pathPattern&gt;]有如下过滤规则 &lt;data android:mimeType=&quot;image/*&quot; /&gt;这种规则指定了媒体类型为所有类型的图片，那么Intent中的mimeType属性必须为“image/*”才能匹配，这种情况下虽然过滤规则没有指定URI，但是却有默认值，URI的默认值为content和file。也就是说，虽然没有指定URI，但是Intent中的URI部分的schema必须为content或者file才能匹配，这点是需要尤其注意的。为了匹配上面中规则，我们可以写出如下示例intent.setDataAndType(Uri.parse(&quot;file://abc&quot;),&quot;image/png&quot;)。另外，如果要为Intent指定完整的data，必须要调用setDataAndType方法，不能先调用setData再调用setType，因为这两个方法彼此会清除对方的值。最后，当我们通过隐式方式启动一个Activity的时候，可以做一下判断，看是否有Activity能够匹配我们的隐式Intent，如果不做判断就有可能出现上述的错误了。判断方法有两种：采用PackageManager的resolveActivity方法或者Intent的resolveActivity方法，如果它们找不到匹配的Activity就会返回null，我们通过判断返回值就可以规避上述错误了。另外，PackageManager还提供了queryIntentActivities方法，这个方法和resolveActivity方法不同的是：它不是返回最佳匹配的Activity信息而是返回所有成功匹配的Activity信息。12public abstract List&lt;ResolveInfo&gt; queryIntentActivities(Intent intent,int flags);public abstract ResolveInfo resolveActivity(Intent intent,int flags); 上述两个方法的第一个参数比较好理解，第二个参数需要注意，我们要使用MATCH_DEFAULT_ONLY这个标记位，这个标记位的含义是仅仅匹配那些在intent-filter中声明了&lt;category android:name=&quot;android.intent.category.DEFAULT&quot;/&gt;这个category的Activity。使用这个标记位的意义在于，只要上述两个方法不返回null，那么startActivity一定可以成功。如果不用这个标记位，就可以把intent-filter中category不含DEFAULT的那些Activity给匹配出来，从而导致startActivity可能失败。因为不含有DEFAULT这个category的Activity是无法接收隐式Intent的。 App启动过程 点击桌面App图标，Launch进程采用Binder IPC向system_server进程发起startActivity请求 system_server收到请求后，向zygote进程发送创建进程请求。 Zygote进程fork出新的子进程，即App进程。 App进程通过Binder IPC向system_server进程发起attachApplication请求 system_server进程在收到请求后，进行一系列的准备工作，再通过Binder IPC向App进程发送scheduleLaunchActivity请求。 App进程的binder线程(ApplicationThread)在收到请求后，通过handler向主线程发送LAUNCH_ACTIVITY消息； 主线程在收到Message后，通过发射机制创建目标Activity，并回调Activity.onCreate()等方法； 到此，App便正式启动，开始进入Activity生命周期。 涉及到的类 Activity startActivity方法的真正实现在Activity中。 Instrumentation 每一个应用程序只有一个Instrumentation对象，每个Activity内都有一个对该对象的引用。Instrumentation可以理解为应用进程的管家，ActivityThread要创建或暂停某个Activity时，都需要通过Instrumentation来进行具体的操作,用来辅助Activity完成启动Activity的过程。 ActivityThread（包含ApplicationThread + ApplicationThreadNative + IApplicationThread）：真正启动Activity的实现都在这里,应用的入口类，系统通过调用main函数，开启消息循环队列。ActivityThread所在线程被称为应用的主线程（UI线程）。与ActivityManagerServices配合，一起完成Activity的管理工作。 ActivityManagerService 简称AMS，服务端对象。AMS是Android中最核心的服务之一，主要负责系统中四大组件的启动、切换、调度及应用进程的管理和调度等工作，其职责与操作系统中的进程管理和调度模块相类似，因此它在Android中非常重要，它本身也是一个Binder的实现类。 ActivityManagerProxy AMS服务在当前进程的代理类，负责与AMS通信。 ApplicationThread 用来实现ActivityManagerService与ActivityThread之间的交互。在ActivityManagerService需要管理相关Application中的Activity的生命周期时，通过ApplicationThread的代理对象与ActivityThread通讯。 ApplicationThreadProxy 是ApplicationThread在服务器端的代理，负责和客户端的ApplicationThread通讯。AMS就是通过该代理与ActivityThread进行通信的。 ActivityStack Activity在AMS的栈管理，用来记录已经启动的Activity的先后关系，状态信息等。通过ActivityStack决定是否需要启动新的进程。 ActivityRecord ActivityStack的管理对象，每个Activity在AMS对应一个ActivityRecord，来记录Activity的状态以及其他的管理信息。其实就是服务器端的Activity对象的映像。 TaskRecord AMS抽象出来的一个“任务”的概念，是记录ActivityRecord的栈，一个“Task”包含若干个ActivityRecord。AMS用TaskRecord确保Activity启动和退出的顺序。如果你清楚Activity的4种launchMode，那么对这个概念应该不陌生。 基本概念 zygoteAndroid是基于Linux系统的，而在Linux中，所有的进程都是由init进程直接或者是间接fork出来的，zygote进程也不例外。至于init进程怎么来的，可以搜一下Android系统启动过程。在Android系统里面，zygote是一个进程的名字。Android是基于Linux System的，当你的手机开机的时候，Linux的内核加载完成之后就会启动一个叫“init“的进程。在Linux System里面，所有的进程都是由init进程fork出来的，我们的zygote进程也不例外。我们都知道，每一个App其实都是 一个单独的虚拟机 一个单独的进程所以当系统里面的第一个zygote进程运行之后，在这之后再开启App，就相当于开启一个新的进程。而为了实现资源共用和更快的启动速度，Android系统开启新进程的方式，是通过fork第一个zygote进程实现的。所以说，除了第一个zygote进程，其他应用所在的进程都是zygote的子进程， SystemServer它也是个进程，而且是由zygote进程fork出来的。系统里面重要的服务都是在这个进程里面开启的，比如ActivityManagerService、PackageManagerService、WindowManagerService 等等。在zygote开启的时候，会调用ZygoteInit.main()进行初始化： 1234567891011/** * Startup class for the zygote process. * * Pre-initializes some classes, and then waits for commands on a UNIX domain * socket. Based on these commands, forks off child processes that inherit * the initial state of the VM. * * Please see &#123;@link ZygoteConnection.Arguments&#125; for documentation on the * client protocol. * */ 从注释上也可以看出这个类主要是为了初始化某些参数。比如1234567891011121314151617181920212223242526272829303132333435static void preload(TimingsTraceLog bootTimingsTraceLog) &#123; Log.d(TAG, "begin preload"); bootTimingsTraceLog.traceBegin("BeginIcuCachePinning"); beginIcuCachePinning(); bootTimingsTraceLog.traceEnd(); // BeginIcuCachePinning bootTimingsTraceLog.traceBegin("PreloadClasses"); preloadClasses(); bootTimingsTraceLog.traceEnd(); // PreloadClasses bootTimingsTraceLog.traceBegin("PreloadResources"); preloadResources(); bootTimingsTraceLog.traceEnd(); // PreloadResources Trace.traceBegin(Trace.TRACE_TAG_DALVIK, "PreloadAppProcessHALs"); nativePreloadAppProcessHALs(); Trace.traceEnd(Trace.TRACE_TAG_DALVIK); Trace.traceBegin(Trace.TRACE_TAG_DALVIK, "PreloadOpenGL"); preloadOpenGL(); Trace.traceEnd(Trace.TRACE_TAG_DALVIK); preloadSharedLibraries(); preloadTextResources(); // Ask the WebViewFactory to do any initialization that must run in the zygote process, // for memory sharing purposes. WebViewFactory.prepareWebViewInZygote(); endIcuCachePinning(); warmUpJcaProviders(); Log.d(TAG, "end preload"); sPreloadComplete = true; &#125; public static void lazyPreload() &#123; Preconditions.checkState(!sPreloadComplete); Log.i(TAG, "Lazily preloading resources."); preload(new TimingsTraceLog("ZygoteInitTiming_lazy", Trace.TRACE_TAG_DALVIK)); &#125; 还有一些关键的方法preloadSharedLibraries()、preloadOpenGL()、preloadTextResources()、preloadClasses()、preloadResources()、preloadDrawables()、preloadColorStateLists() 等.还有一个startSystemServer()方法。 ActivityManagerService简称AMS,服务端对象，负责系统中所有Activity生命周期。它的初始化时机很明确，就是在SystemServer进程开启的时候，就会初始化ActivityManagerService。具体情况可以看一下SystemServer.java类。经过上面这些步骤，我们的ActivityManagerService对象已经创建好了，并且完成了成员变量初始化。而且在这之前，调用createSystemContext()创建系统上下文的时候，也已经完成了mSystemContext和ActivityThread的创建。注意，这是系统进程开启时的流程，在这之后，会开启系统的Launcher程序，完成系统界面的加载与显示。 为什么说AMS是服务端对象其实服务器客户端的概念不仅仅存在于Web开发中，在Android的框架设计中，使用的也是这一种模式。服务器端指的就是所有App共用的系统服务，比如我们这里提到的ActivityManagerService，和前面提到的PackageManagerService、WindowManagerService等等，这些基础的系统服务是被所有的App公用的，当某个App想实现某个操作的时候，要告诉这些系统服务，比如你想打开一个App，那么我们知道了包名和MainActivity类名之后就可以打开 12345Intent intent = new Intent(Intent.ACTION_MAIN); intent.addCategory(Intent.CATEGORY_LAUNCHER);ComponentName cn = new ComponentName(packageName, className);intent.setComponent(cn); startActivity(intent); 但是，我们的App通过调用startActivity()并不能直接打开另外一个App，这个方法会通过一系列的调用，最后还是告诉AMS说：“我要打开这个App，我知道他的住址和名字，你帮我打开吧！”所以是AMS来通知zygote进程来fork一个新进程，来开启我们的目标App的。这就像是浏览器想要打开一个超链接一样，浏览器把网页地址发送给服务器，然后还是服务器把需要的资源文件发送给客户端的。 知道了Android Framework的客户端服务器架构之后，我们还需要了解一件事情，那就是我们的App和AMS(SystemServer进程)还有zygote进程分属于三个独立的进程，他们之间如何通信呢？App与AMS通过Binder进行IPC通信，AMS(SystemServer进程)与zygote通过Socket进行IPC通信。那么AMS有什么用呢？在前面我们知道了，如果想打开一个App的话，需要AMS去通知zygote进程，除此之外，其实所有的Activity的开启、暂停、关闭都需要AMS来控制，所以我们说，AMS负责系统中所有Activity的生命周期。在Android系统中，任何一个Activity的启动都是由AMS和应用程序进程（主要是ActivityThread）相互配合来完成的。AMS服务统一调度系统中所有进程的Activity启动，而每个Activity的启动过程则由其所属的进程具体来完成。 Launcher当我们点击手机桌面上的图标的时候，App就由Launcher开始启动了。Launcher本质上也是一个应用程序，和我们的App一样，也是继承自Activity，系统源码可以在这里看 http://androidxref.com/8.0.0_r4/xref/packages/apps/Launcher3/src/com/android/launcher3/Launcher.java123456View createShortcut(int layoutResId, ViewGroup parent, ShortcutInfo info) &#123; BubbleTextView favorite = (BubbleTextView) mInflater.inflate(layoutResId, parent, false); favorite.applyFromShortcutInfo(info, mIconCache); favorite.setOnClickListener(this); return favorite;&#125; 创建图标并设置点击监听1234567891011121314151617181920212223242526272829303132333435363738394041424344/** * * Launches the intent referred by the clicked shortcut. * @param v The view representing the clicked shortcut. */ public void onClick(View v) &#123; // Make sure that rogue clicks don't get through while allapps is launching, or after the // view has detached (it's possible for this to happen if the view is removed mid touch). if (v.getWindowToken() == null) &#123; return; &#125; if (!mWorkspace.isFinishedSwitchingState()) &#123; return; &#125; Object tag = v.getTag(); if (tag instanceof ShortcutInfo) &#123; // Open shortcut final Intent intent = ((ShortcutInfo) tag).intent; int[] pos = new int[2]; v.getLocationOnScreen(pos); intent.setSourceBounds(new Rect(pos[0], pos[1], pos[0] + v.getWidth(), pos[1] + v.getHeight())); boolean success = startActivitySafely(v, intent, tag); if (success &amp;&amp; v instanceof BubbleTextView) &#123; mWaitingForResume = (BubbleTextView) v; mWaitingForResume.setStayPressed(true); &#125; &#125; else if (tag instanceof FolderInfo) &#123; if (v instanceof FolderIcon) &#123; FolderIcon fi = (FolderIcon) v; handleFolderClick(fi); &#125; &#125; else if (v == mAllAppsButton) &#123; if (isAllAppsVisible()) &#123; showWorkspace(true); &#125; else &#123; onClickAllAppsButton(v); &#125; &#125; &#125; 从上面可以看到，在桌面上点击快捷图标的时候，会调用1startActivitySafely(v, intent, tag); 具体代码就不抄了，看一下上面的链接中的源码就好，在该方法中调用了startActivity(v, intent, tag)，这里会调用Activity.startActivity(intent, opts.toBundle())，这个方法熟悉吗？这就是我们经常用到的Activity.startActivity(Intent)的重载函数。而且由于设置了1intent.addFlags(Intent.FLAG_ACTIVITY_NEW_TASK); 所以这个Activity会添加到一个新的Task栈中，而且，startActivity()调用的其实是startActivityForResult()这个方法。所以现在明确了，Launcher中开启一个App，其实和我们在Activity中直接startActivity()基本一样，都是调用了Activity.startActivityForResult()。 Instrumentation每个Activity都持有Instrumentation对象的一个引用，但是整个进程只会存在一个Instrumentation对象。当startActivityForResult()调用之后，实际上还是调用了mInstrumentation.execStartActivity().下面是mInstrumetation.execStartActivity()的实现12345678910111213141516171819202122232425262728293031323334353637public ActivityResult execStartActivity( Context who, IBinder contextThread, IBinder token, Activity target, Intent intent, int requestCode, Bundle options) &#123; IApplicationThread whoThread = (IApplicationThread) contextThread; Uri referrer = target != null ? target.onProvideReferrer() : null; if (referrer != null) &#123; intent.putExtra(Intent.EXTRA_REFERRER, referrer); &#125; if (mActivityMonitors != null) &#123; synchronized (mSync) &#123; final int N = mActivityMonitors.size(); for (int i=0; i&lt;N; i++) &#123; final ActivityMonitor am = mActivityMonitors.get(i); if (am.match(who, null, intent)) &#123; am.mHits++; if (am.isBlocking()) &#123; return requestCode &gt;= 0 ? am.getResult() : null; &#125; break; &#125; &#125; &#125; &#125; try &#123; intent.migrateExtraStreamToClipData(); intent.prepareToLeaveProcess(); int result = ActivityManagerNative.getDefault() .startActivity(whoThread, who.getBasePackageName(), intent, intent.resolveTypeIfNeeded(who.getContentResolver()), token, target != null ? target.mEmbeddedID : null, requestCode, 0, null, options); checkStartActivityResult(result, intent); &#125; catch (RemoteException e) &#123; throw new RuntimeException("Failure from system", e); &#125; return null; &#125; 这里的 ActivityManagerNative.getDefault 返回ActivityManagerService的远程接口，即 ActivityManagerProxy 接口，有人可能会问了为什么会是ActivityManagerProxy，这就涉及到Binder通信了，这里不再展开。通过Binder驱动程序， ActivityManagerProxy 与AMS服务通信，则实现了跨进程到System进程。 12345678910111213141516171819202122232425262728293031323334353637/** * Retrieve the system's default/global activity manager. */ static public IActivityManager getDefault() &#123; return gDefault.get(); &#125; private static final Singleton&lt;IActivityManager&gt; gDefault = new Singleton&lt;IActivityManager&gt;() &#123; protected IActivityManager create() &#123; IBinder b = ServiceManager.getService("activity"); if (false) &#123; Log.v("ActivityManager", "default service binder = " + b); &#125; IActivityManager am = asInterface(b); if (false) &#123; Log.v("ActivityManager", "default service = " + am); &#125; return am; &#125; &#125;; /** * Cast a Binder object into an activity manager interface, generating * a proxy if needed. */ static public IActivityManager asInterface(IBinder obj) &#123; if (obj == null) &#123; return null; &#125; IActivityManager in = (IActivityManager)obj.queryLocalInterface(descriptor); if (in != null) &#123; return in; &#125; return new ActivityManagerProxy(obj); &#125; AMS响应Launcher进程请求至此，点击桌面图标调用startActivity()，终于把数据和要开启Activity的请求发送到了AMS了,AMS收到startActivity的请求之后，会按照如下的方法链进行调用：123456789101112131415161718192021@Override public final int startActivity(IApplicationThread caller, String callingPackage, Intent intent, String resolvedType, IBinder resultTo, String resultWho, int requestCode, int startFlags, ProfilerInfo profilerInfo, Bundle options) &#123; return startActivityAsUser(caller, callingPackage, intent, resolvedType, resultTo, resultWho, requestCode, startFlags, profilerInfo, options, UserHandle.getCallingUserId()); &#125; @Override public final int startActivityAsUser(IApplicationThread caller, String callingPackage, Intent intent, String resolvedType, IBinder resultTo, String resultWho, int requestCode, int startFlags, ProfilerInfo profilerInfo, Bundle options, int userId) &#123; enforceNotIsolatedCaller("startActivity"); userId = handleIncomingUser(Binder.getCallingPid(), Binder.getCallingUid(), userId, false, ALLOW_FULL_ONLY, "startActivity", null); // TODO: Switch to user app stacks here. return mStackSupervisor.startActivityMayWait(caller, -1, callingPackage, intent, resolvedType, null, null, resultTo, resultWho, requestCode, startFlags, profilerInfo, null, null, options, false, userId, null, null); &#125; 这里又出现了一个mStackSupervisor，定义是这么说的12/** Run all ActivityStacks through this */ ActivityStackSupervisor mStackSupervisor; 在mStackSupervisor.startActivityMayWait()方法中又调用了startActivityLocked()方法，接着调用了startActivityUncheckedLocked()方法，在这个方法中一大堆眼花缭乱的判断，最终调用了targetStack.startActivityLocked(r, newTask, doResume, keepCurTransition, options)方法，然后调用了mStackSupervisor.resumeTopActivitiesLocked(this, r, options)方法，然后调用result = targetStack.resumeTopActivityLocked(target, targetOptions)方法，调用result = resumeTopActivityInnerLocked(prev, options)方法，在这个方法里，prev.app为记录启动Lancher进程的ProcessRecord，prev.app.thread为Lancher进程的远程调用接口IApplicationThead，所以可以调用prev.app.thread.schedulePauseActivity，到Lancher进程暂停指定Activity。至此，AMS对Launcher的请求已经响应，这是我们发现又通过Binder通信回调至Launcher进程 Launcher进程挂起Launcher，再次通知AMS看一下怎么挂起Launcher的,在ActivityThread中：123456789101112131415161718192021222324252627private void handlePauseActivity(IBinder token, boolean finished, boolean userLeaving, int configChanges, boolean dontReport) &#123; ActivityClientRecord r = mActivities.get(token); if (r != null) &#123; //Slog.v(TAG, "userLeaving=" + userLeaving + " handling pause of " + r); if (userLeaving) &#123; performUserLeavingActivity(r); &#125; r.activity.mConfigChangeFlags |= configChanges; performPauseActivity(token, finished, r.isPreHoneycomb()); // Make sure any pending writes are now committed. if (r.isPreHoneycomb()) &#123; QueuedWork.waitToFinish(); &#125; // Tell the activity manager we have paused. if (!dontReport) &#123; try &#123; ActivityManagerNative.getDefault().activityPaused(token); &#125; catch (RemoteException ex) &#123; &#125; &#125; mSomeActivitiesChanged = true; &#125; &#125; 这部分Launcher的ActivityThread处理页面Paused并且再次通过ActivityManagerProxy通知AMS。 AMS创建新的进程创建新进程的时候，AMS会保存一个ProcessRecord信息，如果应用程序中的AndroidManifest.xml配置文件中，我们没有指定Application标签的process属性，系统就会默认使用package的名称。每一个应用程序都有自己的uid，因此，这里uid + process的组合就可以为每一个应用程序创建一个ProcessRecord。在ActivityManagerService中，1234567891011121314151617181920212223private final void startProcessLocked(ProcessRecord app, String hostingType, String hostingNameStr, String abiOverride, String entryPoint, String[] entryPointArgs) &#123; long startTime = SystemClock.elapsedRealtime(); ...... // Start the process. It will either succeed and return a result containing // the PID of the new process, or else throw a RuntimeException. boolean isActivityProcess = (entryPoint == null); if (entryPoint == null) entryPoint = "android.app.ActivityThread"; Trace.traceBegin(Trace.TRACE_TAG_ACTIVITY_MANAGER, "Start proc: " + app.processName); checkTime(startTime, "startProcess: asking zygote to start proc"); Process.ProcessStartResult startResult = Process.start(entryPoint, app.processName, uid, uid, gids, debugFlags, mountExternal, app.info.targetSdkVersion, app.info.seinfo, requiredAbi, instructionSet, app.info.dataDir, entryPointArgs); checkTime(startTime, "startProcess: returned from zygote!"); Trace.traceEnd(Trace.TRACE_TAG_ACTIVITY_MANAGER); if (app.isolated) &#123; mBatteryStatsService.addIsolatedUid(app.uid, app.info.uid); &#125; mBatteryStatsService.noteProcessStart(app.processName, app.info.uid); checkTime(startTime, "startProcess: done updating battery stats"); 这里主要是调用Process.start接口来创建一个新的进程，新的进程会导入android.app.ActivityThread类，并且执行它的main函数，这就是每一个应用程序都有一个ActivityThread实例来对应的原因。 应用进程初始化来看Activity的main函数，这里绑定了主线程的Looper，并进入消息循环，大家应该知道，整个Android系统是消息驱动的，这也是为什么主线程默认绑定Looper的原因：123456789101112131415161718192021222324252627282930313233343536373839404142public static void main(String[] args) &#123; Trace.traceBegin(Trace.TRACE_TAG_ACTIVITY_MANAGER, "ActivityThreadMain"); SamplingProfilerIntegration.start(); // CloseGuard defaults to true and can be quite spammy. We // disable it here, but selectively enable it later (via // StrictMode) on debug builds, but using DropBox, not logs. CloseGuard.setEnabled(false); Environment.initForCurrentUser(); // Set the reporter for event logging in libcore EventLogger.setReporter(new EventLoggingReporter()); AndroidKeyStoreProvider.install(); // Make sure TrustedCertificateStore looks in the right place for CA certificates final File configDir = Environment.getUserConfigDirectory(UserHandle.myUserId()); TrustedCertificateStore.setDefaultUserDirectory(configDir); Process.setArgV0("&lt;pre-initialized&gt;"); Looper.prepareMainLooper(); ActivityThread thread = new ActivityThread(); thread.attach(false); if (sMainThreadHandler == null) &#123; sMainThreadHandler = thread.getHandler(); &#125; if (false) &#123; Looper.myLooper().setMessageLogging(new LogPrinter(Log.DEBUG, "ActivityThread")); &#125; // End of event ActivityThreadMain. Trace.traceEnd(Trace.TRACE_TAG_ACTIVITY_MANAGER); Looper.loop(); throw new RuntimeException("Main thread loop unexpectedly exited"); &#125; attach函数最终调用了ActivityManagerService的远程接口ActivityManagerProxy的attachApplication函数，传入的参数是mAppThread，这是一个ApplicationThread类型的Binder对象，它的作用是AMS与应用进程进行进程间通信的。将进程和指定的Application绑定起来。这个是通过上节的ActivityThread对象中调用bindApplication()方法完成的。该方法发送一个BIND_APPLICATION的消息到消息队列中, 最终通过handleBindApplication()方法处理该消息. 然后调用makeApplication()方法来加载App的classes到内存中。 在AMS中注册应用进程，启动栈顶页面mMainStack.topRunningActivityLocked(null)从堆栈顶端取出要启动的Activity，并在realStartActivityLockedhan函数中通过ApplicationThreadProxy调回App进程启动页面。在ActivityStackSupervisor中123456789final boolean realStartActivityLocked(ActivityRecord r, ProcessRecord app, boolean andResume, boolean checkConfig) throws RemoteException &#123; app.thread.scheduleLaunchActivity(new Intent(r.intent), r.appToken, System.identityHashCode(r), r.info, new Configuration(mService.mConfiguration), new Configuration(stack.mOverrideConfig), r.compat, r.launchedFromPackage, task.voiceInteractor, app.repProcState, r.icicle, r.persistentState, results, newIntents, !andResume, mService.isNextTransitionForward(), profilerInfo); &#125; 它会调用application线程对象中的scheduleLaunchActivity()发送一个LAUNCH_ACTIVITY消息到消息队列中, 通过 handleLaunchActivity()来处理该消息。在 handleLaunchActivity()通过performLaunchActiivty()方法回调Activity的onCreate()方法和onStart()方法，然后通过handleResumeActivity()方法，回调Activity的onResume()方法，而后会通知AMS该MainActivity已经处于resume状态最终显示Activity界面。至此，整个启动流程告一段落。 最后： 一个App的程序入口到底是什么？是ActivityThread.main()。 整个App的主线程的消息循环是在哪里创建的？是在ActivityThread初始化的时候，就已经创建消息循环了，所以在主线程里面创建Handler不需要指定Looper，而如果在其他线程使用Handler，则需要单独使用Looper.prepare()和Looper.loop()创建消息循环。可以看ActivityThread的main方法 Application是在什么时候创建的？onCreate()什么时候调用的？也是在ActivityThread.main()的时候，就是在thread.attach(false)的时候。 1234567891011121314151617if (!system) &#123; ViewRootImpl.addFirstDrawHandler(new Runnable() &#123; @Override public void run() &#123; ensureJitEnabled(); &#125; &#125;); android.ddm.DdmHandleAppName.setAppName("&lt;pre-initialized&gt;", UserHandle.myUserId()); RuntimeInit.setApplicationObject(mAppThread.asBinder()); final IActivityManager mgr = ActivityManagerNative.getDefault(); try &#123; mgr.attachApplication(mAppThread); &#125; catch (RemoteException ex) &#123; // Ignore &#125;&#125; 这里需要关注的就是mgr.attachApplication(mAppThread)，这个就会通过Binder调用到AMS里面对应的方法:123456789@Overridepublic final void attachApplication(IApplicationThread thread) &#123; synchronized (this) &#123; int callingPid = Binder.getCallingPid(); final long origId = Binder.clearCallingIdentity(); attachApplicationLocked(thread, callingPid); Binder.restoreCallingIdentity(origId); &#125;&#125; 然后调用的就是private final boolean attachApplicationLocked(IApplicationThread thread,int pid)方法，thread是IApplicationThread，实际上就是ApplicationThread在服务端的代理类ApplicationThreadProxy，然后又通过IPC就会调用到ApplicationThread的对应方法。这个方法里面又调用了sendMessage()，里面有函数的编号H.BIND_APPLICATION，然后这个Messge会被H这个Handler处理:12345678910private class H extends Handler &#123; public static final int BIND_APPLICATION = 110; case BIND_APPLICATION: Trace.traceBegin(Trace.TRACE_TAG_ACTIVITY_MANAGER, "bindApplication"); AppBindData data = (AppBindData)msg.obj; handleBindApplication(data); Trace.traceEnd(Trace.TRACE_TAG_ACTIVITY_MANAGER); break;&#125; 然后在handleBindApplication(data)方法中12345678910111213141516171819202122232425262728293031 try &#123; java.lang.ClassLoader cl = instrContext.getClassLoader(); mInstrumentation = (Instrumentation)cl.loadClass(data.instrumentationName.getClassName()).newInstance();&#125; catch (Exception e) &#123; throw new RuntimeException("Unable to instantiate instrumentation "+ data.instrumentationName + ": " + e.toString(), e); ...... // Do this after providers, since instrumentation tests generally start their // test thread at this point, and we don't want that racing. try &#123; mInstrumentation.onCreate(data.instrumentationArgs); &#125; catch (Exception e) &#123; throw new RuntimeException( "Exception thrown in onCreate() of " + data.instrumentationName + ": " + e.toString(), e); &#125; try &#123; mInstrumentation.callApplicationOnCreate(app); &#125; catch (Exception e) &#123; if (!mInstrumentation.onException(app, e)) &#123; throw new RuntimeException( "Unable to create application " + app.getClass().getName() + ": " + e.toString(), e); &#125; &#125; &#125; finally &#123; StrictMode.setThreadPolicy(savedPolicy); &#125;&#125; 不同的版本代码不尽相同，但是基本逻辑不会变。参考、抄袭的链接如下：https://blog.csdn.net/bfboys/article/details/52564531https://www.jianshu.com/p/a72c5ccbd150https://www.jianshu.com/p/6037f6fda285https://www.jianshu.com/p/a72c5ccbd150 以上]]></content>
      <tags>
        <tag>Android</tag>
        <tag>面试</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Android多进程三]]></title>
    <url>%2F2018%2F07%2F23%2FAndroid%E5%A4%9A%E8%BF%9B%E7%A8%8B%E4%B8%89%2F</url>
    <content type="text"><![CDATA[Android中中IPC方式有很多，比如使用Bundle，使用文件共享，使用Messenger，使用AIDL，使用ContentProvider，使用Socket等。前两种方式比较简单，自己玩。下面主要是抄的《Android开发艺术探索》2.4.4章节，看过书的就不用看了。上一篇主要抄了Messenger来进行进程间通信的方法，可以发现Messenger是以串行的方式处理客户端发来的消息，如果大量的消息同时发送到服务端，服务端仍然只能一个个处理，如果有大量的并发请求，那么用Messenger就不太合适了。同时，Messenger的作用主要是为了传递消息，很多时候我们可能需要跨进程调用服务端的方法，这种情形用Messenger就无法做到了，但是我们可以使用AIDL来实现跨进程的方法调用。AIDL也是Messenger的底层实现，因此Messenger本质上也是AIDL，只不过系统为我们做了封装从而方便上层的调用而已。在上一节中，我们介绍了Binder的概念，大家对Binder也有了一定的了解，在Binder的基础上我们可以更加容易地理解AIDL。这里先介绍使用AIDL来进行进程间通信的流程，分为服务端和客户端两个方面。 服务端服务端首先要创建一个Service用来监听客户端的连接请求，然后创建一个AIDL文件，将暴露给客户端的接口在这个AIDL文件中声明，最后在Service中实现这个AIDL接口即可。 客户端客户端所要做事情就稍微简单一些，首先需要绑定服务端的Service，绑定成功后，将服务端返回的Binder对象转成AIDL接口所属的类型，接着就可以调用AIDL中的方法了。 具体实现方式AIDL接口的创建收看看AIDL接口的创建，如下所示创建了一个后缀为AIDL的文件，在里面声明了一个接口和两个方法。创建AIDL文件的方式可以看这个Android多进程(一) 123456789101112131415// IBookManager.aidlpackage com.huangyuanlove.testandroid;// Declare any non-default types here with import statementsimport com.huangyuanlove.testandroid.Book;interface IBookManager &#123; /** * Demonstrates some basic types that you can use as parameters * and return values in AIDL. */ void basicTypes(int anInt, long aLong, boolean aBoolean, float aFloat, double aDouble, String aString); List&lt;Book&gt; getBookList(); void addBook(in Book book);&#125; 在AIDL文件中，并不是所有的数据类型都是可以使用的，只支持如下几种类型： 基本数据类型（int、long、char、boolean、double等）； String和CharSequence； List：只支持ArrayList，里面每个元素都必须能够被AIDL支持； Map：只支持HashMap，里面的每个元素都必须被AIDL支持，包括key和value； Parcelable：所有实现了Parcelable接口的对象； AIDL：所有的AIDL接口本身也可以在AIDL文件中使用。 以上6种数据类型就是AIDL所支持的所有类型，其中自定义的Parcelable对象和AIDL对象必须要显式import进来，不管它们是否和当前的AIDL文件位于同一个包内。比如IBookManager.aidl这个文件，里面用到了Book这个类，这个类实现了Parcelable接口并且和IBookManager.aidl位于同一个包中，但是遵守AIDL的规范，我们仍然需要显式地import进来：com.huangyuanlove.testandroid.Book。另外一个需要注意的地方是，如果AIDL文件中用到了自定义的Parcelable对象，那么必须新建一个和它同名的AIDL文件，并在其中声明它为Parcelable类型。在上面的IBookManager.aidl中，我们用到了Book这个类，所以，我们必须要创建Book.aidl，然后在里面添加如下内容：12package com.huangyuanlove.testandroid;parcelable Book; 远程服务端Service的实现上面讲述了如何定义AIDL接口，接下来实现这个接口。先创建一个service，代码如下：123456789101112131415161718192021222324252627282930313233343536373839404142434445package com.huangyuanlove.testandroid;import android.app.Service;import android.content.Intent;import android.os.Binder;import android.os.IBinder;import android.os.RemoteException;import android.support.annotation.Nullable;import java.util.List;import java.util.concurrent.CopyOnWriteArrayList;public class BookManagerService extends Service &#123; private CopyOnWriteArrayList&lt;Book&gt; mBookList = new CopyOnWriteArrayList&lt;&gt;(); private Binder mBinder = new IBookManager.Stub() &#123; @Override public void basicTypes(int anInt, long aLong, boolean aBoolean, float aFloat, double aDouble, String aString) throws RemoteException &#123; &#125; @Override public List&lt;Book&gt; getBookList() throws RemoteException &#123; return mBookList; &#125; @Override public void addBook(Book book) throws RemoteException &#123; mBookList.add(book); &#125; &#125;; @Override public void onCreate() &#123; super.onCreate(); mBookList.add(new Book(1,"Android")); mBookList.add(new Book(2,"IOS")); &#125; @Nullable @Override public IBinder onBind(Intent intent) &#123; return mBinder; &#125;&#125; 上面是一个服务端Service的典型实现，首先在onCreate中初始化添加了两本图书的信息，然后创建了一个Binder对象并在onBind中返回它，这个对象继承IBookManager.Stub并实现了它内部的AIDL方法，注意这里采用了CopyOnWriteArrayList，这个CopyOnWriteArrayList支持并发读/写。在前面我们提到，AIDL方法是在服务端的Binder线程池中执行的，因此当多个客户端同时连接的时候，会存在多个线程同时访问的情形，所以我们要在AIDL方法中处理线程同步，而我们这里直接使用CopyOnWriteArrayList来进行自动的线程同步。AIDL中所支持的是抽象的List，而List只是一个接口，因此虽然服务端返回的是CopyOnWriteArrayList，但是在Binder中会按照List的规范去访问数据并最终形成一个新的ArrayList传递给客户端。所以，我们在服务端采用CopyOnWriteArrayList是完全可以的。和此类似的还有ConcurrentHashMap，然后我们需要在XML中注册这个Service:12&lt;service android:name=".BookManagerService" android:process=":remote"/&gt; 客户端的实现客户端的实现就比较简单了，首先要绑定远程服务，绑定成功后将服务端返回的Binder对象转换成AIDL接口，然后就可以通过这个接口去调用服务端的远程方法了，代码如下所示：1234567891011121314151617181920212223242526272829303132333435363738public class MainActivity extends AppCompatActivity &#123; private ServiceConnection mConnection = new ServiceConnection() &#123; @Override public void onServiceConnected(ComponentName name, IBinder service) &#123; IBookManager bookManager= IBookManager.Stub.asInterface(service); try &#123; List&lt;Book&gt; list = bookManager.getBookList(); Log.d("xuan","bookManager.getBookList()--&gt;" + list.size()); bookManager.addBook(new Book(3,"java")); List&lt;Book&gt; newList = bookManager.getBookList(); Log.d("xuan","bookManager.getBookList()--&gt;" + newList.size()); &#125;catch (RemoteException e)&#123; e.printStackTrace(); &#125; &#125; @Override public void onServiceDisconnected(ComponentName name) &#123; &#125; &#125;; @Override protected void onCreate(Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); setContentView(R.layout.activity_main); Intent intent = new Intent(this,BookManagerService.class); bindService(intent,mConnection, Context.BIND_AUTO_CREATE); &#125; @Override protected void onDestroy() &#123; unbindService(mConnection); super.onDestroy(); &#125;&#125; 绑定成功以后，会通过bookManager去调用getBookList方法，然后打印出所获取的图书信息。需要注意的是，服务端的方法有可能需要很久才能执行完毕，这个时候下面的代码就会导致ANR，这一点是需要注意的，后面会再介绍这种情况，接着再调用一下另外一个接口addBook，我们在客户端给服务端添加一本书，然后再获取一次。现在我们考虑一种情况，假设有一种需求：用户不想时不时地去查询图书列表了，太累了，于是，他去问图书馆，“当有新书时能不能把书的信息告诉我呢？”。这就是一种典型的观察者模式。首先，我们需要提供一个AIDL接口，每个用户都需要实现这个接口并且向图书馆申请新书的提醒功能，当然用户也可以随时取消这种提醒。之所以选择AIDL接口而不是普通接口，是因为AIDL中无法使用普通接口。这里我们创建一个IOnNewBookArrivedListener.aidl文件，我们所期望的情况是：当服务端有新书到来时，就会通知每一个已经申请提醒功能的用户。从程序上来说就是调用所有IOnNewBookArrivedListener对象中的onNewBookArrived方法，并把新书的对象通过参数传递给客户端，内容如下所示：1234567891011121314// IOnNewBookArrivedListener.aidlpackage com.huangyuanlove.testandroid;// Declare any non-default types here with import statementsimport com.huangyuanlove.testandroid.Book;interface IOnNewBookArrivedListener &#123; /** * Demonstrates some basic types that you can use as parameters * and return values in AIDL. */ void basicTypes(int anInt, long aLong, boolean aBoolean, float aFloat, double aDouble, String aString); void onNewBookArrived(in Book newBook);&#125; AIDL中除了基本数据类型，其他类型的参数必须标上方向：in、out或者inout，in表示输入型参数，out表示输出型参数，inout表示输入输出型参数，至于它们具体的区别，官网是这么说的： All non-primitive parameters require a directional tag indicating which way the data goes . Either in , out , or inout . Primitives are in by default , and connot be otherwise . 所有的非基本参数都需要一个定向tag来指出数据的流向，不管是 in , out , 还是 inout 。基本参数的定向tag默认是并且只能是 in 。 我们要根据实际需要去指定参数类型，不能一概使用out或者inout，因为这在底层实现是有开销的。最后，AIDL接口中只支持方法，不支持声明静态常量，这一点区别于传统的接口。除了要新增加一个AIDL接口，还需要在原有的接口中添加两个新方法，代码如下：123456789101112package com.huangyuanlove.testandroid;import com.huangyuanlove.testandroid.Book;import com.huangyuanlove.testandroid.IOnNewBookArrivedListener;interface IBookManager &#123; void basicTypes(int anInt, long aLong, boolean aBoolean, float aFloat, double aDouble, String aString); List&lt;Book&gt; getBookList(); void addBook(in Book book); void registerListener(IOnNewBookArrivedListener listener); void unRegisterListener(IOnNewBookArrivedListener listener);&#125; 接着，服务端中的Service的实现也需要修改一下，主要是Service中的IBookManager.Stub的实现，需要实现新增加的两个方法(IDE没有提示的话可以make一下)。同时，在BookManagerService中还开启了一个线程，每隔5s就向书库中增加一本新书并通知所有感兴趣的用户，整个代码如下所示：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899public class BookManagerService extends Service &#123; private AtomicBoolean mIsServiceDestroyed = new AtomicBoolean(false); private CopyOnWriteArrayList&lt;Book&gt; mBookList = new CopyOnWriteArrayList&lt;&gt;(); private CopyOnWriteArrayList&lt;IOnNewBookArrivedListener&gt; mListenerList = new CopyOnWriteArrayList&lt;&gt;(); private Binder mBinder = new IBookManager.Stub() &#123; @Override public void basicTypes(int anInt, long aLong, boolean aBoolean, float aFloat, double aDouble, String aString) throws RemoteException &#123; &#125; @Override public List&lt;Book&gt; getBookList() throws RemoteException &#123; return mBookList; &#125; @Override public void addBook(Book book) throws RemoteException &#123; mBookList.add(book); &#125; @Override public void registerListener(IOnNewBookArrivedListener listener) throws RemoteException &#123; if (!mListenerList.contains(listener)) &#123; mListenerList.add(listener); &#125; else &#123; Log.d("xuan", "already exists."); &#125; Log.d("xuan", "registerListener,size:" + mListenerList.size()); &#125; @Override public void unRegisterListener(IOnNewBookArrivedListener listener) throws RemoteException &#123; if (mListenerList.contains(listener)) &#123; mListenerList.remove(listener); Log.d("xuan", "unregister listener succeed."); &#125; else &#123; Log.d("xuan", "not found,can not unregister."); &#125; Log.d("xuan", "unregisterListener,current size:" + mListenerList.size()); &#125; &#125;; @Override public void onCreate() &#123; super.onCreate(); mBookList.add(new Book(1, "Android")); mBookList.add(new Book(2, "IOS")); new Thread(new ServiceWorker()).start(); &#125; @Nullable @Override public IBinder onBind(Intent intent) &#123; return mBinder; &#125; @Override public void onDestroy() &#123; mIsServiceDestroyed.set(true); super.onDestroy(); &#125; private void onNewBookArrived(Book book) throws RemoteException &#123; mBookList.add(book); Log.d("xuan", "onNewBookArrived,notify listeners:" + mListenerList. size()); for (int i = 0; i &lt; mListenerList.size(); i++) &#123; IOnNewBookArrivedListener listener = mListenerList.get(i); Log.d("xuan", "onNewBookArrived,notify listener:" + listener); listener.onNewBookArrived(book); &#125; &#125; private class ServiceWorker implements Runnable &#123; @Override public void run() &#123; while (!mIsServiceDestroyed.get()) &#123; try &#123; Thread.sleep(5000); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; int bookId = mBookList.size() + 1; Book newBook = new Book(bookId, "new book#" + bookId); try &#123; onNewBookArrived(newBook); &#125; catch (RemoteException e) &#123; e.printStackTrace(); &#125; &#125; &#125; &#125;&#125; 最后还需要修改一下客户端的代码，主要有两方面：首先客户端要注册IOnNewBookArrivedListener到远程服务端，这样当有新书时服务端才能通知当前客户端，同时我们要在Activity退出时解除这个注册；另一方面，当有新书时，服务端会回调客户端的IOnNewBookArrivedListener对象中的onNewBookArrived方法，但是这个方法是在客户端的Binder线程池中执行的，因此，为了便于进行UI操作，我们需要有一个Handler可以将其切换到客户端的主线程中去执行，代码如下：12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879public class MainActivity extends AppCompatActivity &#123; private static final int MESSAGE_NEW_BOOK_ARRIVED = 1; private IBookManager mRemoteBookManager; private Handler mHandler = new Handler() &#123; @Override public void handleMessage(Message msg) &#123; switch (msg.what) &#123; case MESSAGE_NEW_BOOK_ARRIVED: Log.d("MainActivity","receive new book :" + msg.obj); break; default: super.handleMessage(msg); &#125; &#125; &#125;; private ServiceConnection mConnection = new ServiceConnection() &#123; @Override public void onServiceConnected(ComponentName name, IBinder service) &#123; IBookManager bookManager= IBookManager.Stub.asInterface(service); try &#123; mRemoteBookManager = bookManager; List&lt;Book&gt; list = bookManager.getBookList(); Log.d("MainActivity","bookManager.getBookList()--&gt;" + list.size() +"&gt;&gt; " + list.toString()); bookManager.addBook(new Book(3,"java")); List&lt;Book&gt; newList = bookManager.getBookList(); Log.d("MainActivity","bookManager.getBookList()--&gt;" + newList.size()+"&gt;&gt; " + newList.toString()); bookManager.registerListener(mOnNewBookArrivedListener); &#125;catch (RemoteException e)&#123; e.printStackTrace(); &#125; &#125; @Override public void onServiceDisconnected(ComponentName name) &#123; mRemoteBookManager = null; Log.e("MainActivity","binder died."); &#125; &#125;; private IOnNewBookArrivedListener mOnNewBookArrivedListener = new IOnNewBookArrivedListener.Stub() &#123; @Override public void basicTypes(int anInt, long aLong, boolean aBoolean, float aFloat, double aDouble, String aString) throws RemoteException &#123; &#125; @Override public void onNewBookArrived(Book newBook) throws RemoteException &#123; mHandler.obtainMessage(MESSAGE_NEW_BOOK_ARRIVED,newBook) .sendToTarget(); &#125; &#125;; @Override protected void onCreate(Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); setContentView(R.layout.activity_main); Intent intent = new Intent(this,BookManagerService.class); bindService(intent,mConnection, Context.BIND_AUTO_CREATE); &#125; @Override protected void onDestroy() &#123; if (mRemoteBookManager != null &amp;&amp; mRemoteBookManager.asBinder().isBinderAlive()) &#123; try &#123; Log.d("MainActivity","unregister listener:" + mOnNewBookArrivedListener); mRemoteBookManager.unRegisterListener(mOnNewBookArrivedListener); &#125; catch (RemoteException e) &#123; e.printStackTrace(); &#125; &#125; unbindService(mConnection); super.onDestroy(); &#125;&#125; 从上面的代码可以看出，当BookManagerActivity关闭时，我们会在onDestroy中去解除已经注册到服务端的listener，这就相当于我们不想再接收图书馆的新书提醒了，所以我们可以随时取消这个提醒服务。按back键退出BookManagerActivity,下面是打印出的log1207-23 14:56:55.493 16905-16918/com.huangyuanlove.testandroid:remote D/BookManagerService: not found,can not unregister.07-23 14:56:57.185 16905-16918/com.huangyuanlove.testandroid:remote D/BookManagerService: unregisterListener,current size:1 从上面的log可以看出，程序没有像我们所预期的那样执行。在解注册的过程中，服务端竟然无法找到我们之前注册的那个listener，其实，这是必然的，这种解注册的处理方式在日常开发过程中时常使用到，但是放到多进程中却无法奏效，因为Binder会把客户端传递过来的对象重新转化并生成一个新的对象。虽然我们在注册和解注册过程中使用的是同一个客户端对象，但是通过Binder传递到服务端后，却会产生两个全新的对象。别忘了对象是不能跨进程直接传输的，对象的跨进程传输本质上都是反序列化的过程，这就是为什么AIDL中的自定义对象都必须要实现Parcelable接口的原因。可以使用RemoteCallbackList。RemoteCallbackList是系统专门提供的用于删除跨进程listener的接口。 RemoteCallbackList是一个泛型， 支持管理任意的AIDL接口， 这点从它的声明就可以看出，因为所有的AIDL接口都继承自IInterface接口 public class RemoteCallbackList 它的工作原理很简单， 在它的内部有一个Map结构专门用来保存所有的AIDL回调，这个Map的key是IBinder类型， value是Callback类型， 如下所示: ArrayMap mCallbacks = new ArrayMap(); 其中Callback中封装了真正的远程listener。 当客户端注册listener的时候，它会把这个listener的信息存入mCallbacks中， 其中key和value分别通过下面的方式获得： IBinder key= listener.asBinder()Callback value = new Callback(listener,cookie) 虽然说多次跨进程传输客户端的同一个对象会在服务端生成不同的对象，但是这些新生成的对象有一个共同点，那就是它们底层的Binder对象是同一个， 利用这个特性，就可以实现上面我们无法实现的功能。当客户端解注册的时候，我们只要遍历服务端所有的listener， 找出那个和解注册listener具有相同Binder对象的服务端listener并把它删掉即可，这就是RemoteCallbackList为我们做的事情。同时RemoteCallbackList还有一个很有用的功能， 那就是当客户端进程终止后，它能够自动移除客户端所注册的listener。另外，RemoteCallbackList内部自动实现了线程同步的功能，所以我们使用它来注册和解注册时，不需要做额外的线程同步工作。RemoteCallbackList使用起来很简单，我们要对BookManagerService做一些修改，首先要创建一个RemoteCallbackList对象来替代之前的CopyOnWriteArrayList，如下所示:1private RemoteCallbackList&lt;IOnNewBookArrivedListener&gt; mListenerList = new RemoteCallbackList&lt;IOnNewBookArrivedListener&gt;(); 然后修改registerListener和unregisterListener这两个接口的实现， 如下所示:12345678@Overridepublic void registerListener(IOnNewBookArrivedIistener listener) throws RemoteException &#123; mListenerList.register(listener);&#125;@Overridepublic void unRegisterListener(IOnNewBookArrivedIistener listener) throws RemoteException &#123; mListenerList.unregister(listener);&#125; 接着要修改onNewBookArrived方法，当有新书时，我们就要通知所有已注册的listener，如下所示:1234567891011private void onNewBookArrived(Book book) throws RemoteException &#123; books.add(book); final int N =mListenerList.beginBroadcast(); for(int i = 0 ; i &lt; N;i++)&#123; IOnNewBookArrivedIistener iOnNewBookArrivedIistener = mListenerList.getBroadcastItem(i); if(iOnNewBookArrivedIistener!=null)&#123; iOnNewBookArrivedIistener.onNewBookArrived(book); &#125; &#125; mListenerList.finishBroadcast(); &#125; 使用RemoteCallbackList，有一点需要注意，我们无法像操作List一样去操作它，尽管它的名字中也带个List，但是它并不是一个List。遍历RemoteCallbackList，必须要按照下面的方式进行，其中beginBroadcast和beginBroadcast必须要配对使用，哪怕我们仅仅是想要获取RemoteCallbackList中的元素个数，这是必须要注意的地方。另外还有几点需要说明一下： 客户端调用远程服务的方法，被调用的方法运行在服务端的Binder线程池中，同时客户端线程会被挂起，这个时候如果服务端方法执行比较耗时，就会导致客户端线程长时间地阻塞在这里，而如果这个客户端线程是UI线程的话，就会导致客户端ANR。因此，如果我们明确知道某个远程方法是耗时的，那么就要避免在客户端的UI线程中去访问远程方法。由于客户端的onServiceConnected和onServiceDisconnected方法都运行在UI线程中，所以也不可以在它们里面直接调用服务端的耗时方法，这点要尤其注意。 由于服务端的方法本身就运行在服务端的Binder线程池中，所以服务端方法本身就可以执行大量耗时操作，这个时候切记不要在服务端方法中开线程去进行异步任务，除非你明确知道自己在干什么，否则不建议这么做。 同理，当远程服务端需要调用客户端的listener中的方法时，被调用的方法也运行在Binder线程池中，只不过是客户端的线程池。所以，我们同样不可以在服务端中调用客户端的耗时方法。比如针对BookManagerService的onNewBookArrived方法。在它内部调用了客户端的IOnNewBookArrivedListener中的onNewBookArrived方法，如果客户端的这个onNewBookArrived方法比较耗时的话，那么请确保BookManagerService中的onNewBookArrived运行在非UI线程中，否则将导致服务端无法响应。 权限验证，第一种方法，我们可以在onBind中进行验证，验证不通过就直接返回null，这样验证失败的客户端直接无法绑定服务，至于验证方式可以有多种， 比如使用permission验证。第二种方法，我们可以在服务端的onTransact方法中进行权限验证，如果验证失败就直接返回false，这样服务端就不会终止执行AIDL中的方法从而达到保护服务端的效果。 以上]]></content>
      <tags>
        <tag>Android</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Android多进程-二]]></title>
    <url>%2F2018%2F06%2F22%2FAndroid%E5%A4%9A%E8%BF%9B%E7%A8%8B-%E4%BA%8C%2F</url>
    <content type="text"><![CDATA[Android中中IPC方式有很多，比如使用Bundle，使用文件共享，使用Messenger，使用AIDL，使用ContentProvider，使用Socket等。前两种方式比较简单，自己玩。下面主要是抄的《Android开发艺术探索》2.4.3章节，看过书的就不用看了。Messenger可以翻译为信使，顾名思义，通过它可以在不同进程中传递Message对象,在Message中放入我们需要传递的数据，就可以轻松地实现数据的进程间传递了。Messenger是一种轻量级的IPC方案，它的底层实现是AIDL，为什么这么说呢，我们大致看一下Messenger这个类的构造方法就明白了。下面是Messenger的两个构造方法，从构造方法的实现上我们可以明显看出AIDL的痕迹，不管是IMessenger还是Stub.asInterface,这种使用方法都表明它的底层是AIDL。123456public Messenger (Handler target) &#123; mTarget = target.getIMessenger();&#125;public Messenger ( IBinder target) &#123; mTarget = IMessenger.Stub.asInterface(target);&#125; Messenger的使用方法很简单，它对AIDL做了封装，使得我们可以更简便地进行进程间通信。同时，由于它一次处理一个请求，因此在服务端我们不用考虑线程同步的问题，这是因为服务端中不存在并发执行的情形。实现一个Messenger有如下几个步骤，分为服务端和客户端。 服务端进程首先，我们需要在服务端创建–个Service来处理客户端的连接请求，同时创建一个Handler并通过它来创建一个Messenger对 象，然后在Service的onBind中返回这个Messenger对象底层的Binder即可。 客户端进程客户端进程中，首先要绑定服务端的Service,绑定成功后用服务端返回的IBinder对象创建一个Messenger,通过这个Messenger就可以向服务端发送消息了，发消息类型为Message对象。如果需要服务端能够回应客户端，就和服务端一-样，我们还需要创建一个Handler并创建一个 新的Messenger,并把这个Messenger对象通过Message的replyTo参数传递给服务端，服务端通过这个replyTo参数就可以回应客户端。 首先看服务端的代码，这是服务端的典型代码，可以看到MessengerHandler用来处理客户端发送的消息，并从消息中取出客户端发来的文本信息。而mMessenger是一个Messenger对象，它和MessengerHandler相关联，并在onBind方法中返回它里面的Binder对象，可以看出，这里Messenger的作用是将客户端发送的消息传递给MessengerHandler处理。 123456789101112131415161718192021222324public class MessengerService extends Service &#123; private static class MessengerHandler extends Handler&#123; @Override public void handleMessage(Message msg) &#123; switch (msg.what)&#123; case 10001: Log.e("xuan","收到客户端"+msg.getData().getString("msg")); break; default: super.handleMessage(msg); &#125; &#125; &#125; private final Messenger messenger = new Messenger(new MessengerHandler()); @Nullable @Override public IBinder onBind(Intent intent) &#123; return messenger.getBinder(); &#125;&#125; 然后注册service,让其在单独的进程中运行123&lt;serviceandroid: name=".messenger.MessengerService"android: process=":remote"&gt; 在客户端,首先需要绑定远程进程的MessengerService,绑定成功后，根据服务端返回的binder对象创建Messenger对象并使用此对象向服务端发送消息。下面的代码在Bundle中向服务端发送了一句话，在，上面的服务端代码中会打印出这句话。 1234567891011121314151617181920212223242526272829303132333435363738394041public class MessengerActivity extends AppCompatActivity &#123; private Messenger mService; private ServiceConnection connection = new ServiceConnection() &#123; @Override public void onServiceConnected(ComponentName name, IBinder service) &#123; mService = new Messenger(service); Message msg = Message.obtain(null,10001); Bundle data = new Bundle(); data.putString("msg","hi 来自客户端的问候"); msg.setData(data); try &#123; mService.send(msg); &#125; catch (RemoteException e) &#123; e.printStackTrace(); &#125; &#125; @Override public void onServiceDisconnected(ComponentName name) &#123; &#125; &#125;; @Override protected void onCreate(Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); setContentView(R.layout.activity_messenger2); Intent intent = new Intent(this, MessengerService.class); bindService(intent,connection, Context.BIND_AUTO_CREATE); &#125; @Override protected void onDestroy() &#123; super.onDestroy(); unbindService(connection); &#125;&#125; 通过上面的例子可以看出，在Messenger中进行数据传递必须将数据放入Message中，而Messenger和Message都实现了Parcelable接口，因此可以跨进程传输。简单来说,Message中所支持的数据类型就是Messenger所支持的传输类型。实际上，通过Messenger来传输Message, Message中 能使用的载体只有what、arg1、 arg2、 Bundle 以及replyTo。Message中的另一个字段object在同一-个进程中是很实用的，但是在进程间通信的时候，在Android2.2以前object字段不支持跨进程传输，即便是2.2以后，也仅仅是系统提供的实现了Parcelable接口的对象才能通过它来传输。这就意味着我们自定义的Parcelable对象是无法通过object字段来传输的，读者可以试一下。非系统的Parcelable对象的确无法通过object字段来传输，这也导致了object字段的实用性大大降低，所幸我们还有Bundle,Bundle中可以支持大量的数据类型。上面的例子演示了如何在服务端接收客户端中发送的消息，但是有时候我们还需要能回应客户端，下面就介绍如何实现这种效果。还是采用上面的例子，但是稍微做一下修改，每当客户端发来一条消息，服务端就会自动回复一条“嗯，你的消息我已经收到，稍后会回复你。”，这很类似邮箱的自动回复功能。 首先看服务端的修改，服务端只需要修改MessengerHandler,当收到消息后，会立即回复一条消息给客户端。 12345678910111213141516171819202122232425262728293031public class MessengerService extends Service &#123; private static class MessengerHandler extends Handler&#123; @Override public void handleMessage(Message msg) &#123; switch (msg.what)&#123; case 10001: Log.e("huangyuan","收到客户端"+msg.getData().getString("msg")); Messenger clientMessenger = msg.replyTo; Message message = Message.obtain(null,10001); Bundle bundle = new Bundle(); bundle.putString("msg","服务端回应"); message.setData(bundle); try &#123; clientMessenger.send(message); &#125; catch (RemoteException e) &#123; e.printStackTrace(); &#125; break; default: super.handleMessage(msg); &#125; &#125; &#125; private final Messenger messenger = new Messenger(new MessengerHandler()); @Nullable @Override public IBinder onBind(Intent intent) &#123; return messenger.getBinder(); &#125;&#125; 为了接收服务端的消息，客户端也需要准备一个接收消息的Messenger和Handler:12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152public class MessengerActivity extends AppCompatActivity &#123; private Messenger mService; private Messenger getReplyMessenger = new Messenger(new MessengerHandler()); private ServiceConnection connection = new ServiceConnection() &#123; @Override public void onServiceConnected(ComponentName name, IBinder service) &#123; mService = new Messenger(service); Message msg = Message.obtain(null,10001); Bundle data = new Bundle(); data.putString("msg","hi 来自客户端的问候"); msg.setData(data); msg.replyTo = getReplyMessenger; try &#123; mService.send(msg); &#125; catch (RemoteException e) &#123; e.printStackTrace(); &#125; &#125; @Override public void onServiceDisconnected(ComponentName name) &#123; &#125; &#125;; private static class MessengerHandler extends Handler&#123; @Override public void handleMessage(Message msg) &#123; switch (msg.what)&#123; case 10001: Log.e("huangyuan","收到服务端的回复--&gt;"+ msg.getData().get("msg")); break; default: super.handleMessage(msg); &#125; &#125; &#125; @Override protected void onCreate(Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); setContentView(R.layout.activity_messenger2); Intent intent = new Intent(this, MessengerService.class); bindService(intent,connection, Context.BIND_AUTO_CREATE); &#125; @Override protected void onDestroy() &#123; super.onDestroy(); unbindService(connection); &#125;&#125; 关键的一点在于当客户端发送消息的时候，需要把接收服务端回复的Messenger通过Message的replyTo参数传递给服务端：1msg.replyTo = getReplyMessenger; 以上]]></content>
      <tags>
        <tag>Android</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Android多进程(一)]]></title>
    <url>%2F2018%2F06%2F21%2FAndroid%E5%A4%9A%E8%BF%9B%E7%A8%8B-%E4%B8%80%2F</url>
    <content type="text"><![CDATA[Reference：《Android开发艺术探索》，作者：任玉刚多进程基础以及一些名词 IPC进程间通信或者跨进程通信，全称：Inter-Process Communication。在操作系统中，线程是CPU调度的最小单元，同时线程是一种有限的系统资源。而进程一般指一个执行单元。一个进程可以包含做个线程。最简单的情况下，一个进程中可以只有一个线程，即主线程，在Android中，主线程也叫UI线程。IPC不是Android中所独有的，任何一个操作系统都需要有相应的IPC机制，比如windows上可以通过剪贴板、管道和邮槽等来进行进程间通信；linux上可以通过命名管道、共享内容、信号量等来进行进程间通信。Android是基于Linux内核的移动操作系统，它的进程间通信方式没有完全继承自linux，在Android中可以通过Binder轻松实现进程间通信。除了Binder，Android还支持Socket。 开启多进程 指定process属性 正常情况下，在Android中多进程是指一个应用中存在多个进程的情况，因此先忽略多个应用多进程的情况。首先在Android中使用多进程只有一种方式：在AndroidMenifest文件中指定android:process属性，除此之外还有一种非常规的方式，通过JNI在native层fork一个新的进程。也就是说我们无法给一个线程或者一个实体类指定其运行时所在的进程。 12345678&lt;activity android:name=".ui.ActivityOne" android:process=":remote" /&gt;&lt;activity android:name=".ui.ActivityTwo" android:process="com.huangyuanlove.xuan" /&gt;&lt;activity android:name=".ui.ActivityThree" /&gt; 假如当前应用包名为com.huangyuanlove.ipc，当ActivityOne启动时，系统会为它创建一个单独的进程，进程名为com.huangyuanlove.ipc:remote，当ActivityTwo启动时，系统也会为它创建一个进程，进程名为：com.huangyuanlove.xuan，当然ActivityThree是运行在默认进程中，默认进程是包名。 :name 和 全限定名的区别 “:”的含义是在当前进程名的前面附加上包名(ActivityOne)，全限定名并不会附加包名。 以”:”开头的进程属于当前应用的私有进程，其他应用的组件不可以和它跑在同一个进程中，其他不以”:”开头的进程属于全局进程，其他应用通过ShareUID方式可以和它跑在同一个进程中。 ​ Android会为每一个应用分配一个UID，具有相同UID的应用才能共享数据，需要注意的是，两个应用通过ShareUID跑在同一个进程中是有要求的，需要这两个应用有相同的ShareUID并且签名相同才可以。这种情况下，他们可以互相访问对方的私有数据，还可以共享内存数据，或者说它们看起来就像是一个应用的两个部分。 带来的问题 静态成员和单例模式凉凉 线程同步锁机制凉凉 SharedPreferences可靠性凉凉 Application会创建多次 因为开启多进程之后，就不再是同一个内存区域，所以带来第一个问题，第二个问题也是同样，不在同一个内存区域，无论是对象锁还是全局锁可靠性基本就凉了。第三个问题和多进程写sp一样，第四个问题也是显而易见的，系统在创建新进程的时候会同时分配独立的虚拟机，所以这个过程就是启动一个应用的过程。 Parcelable 和 Serializable这个自己玩 Binder直观的讲，Binder是Android中的一个类，它继承了IBinder接口。从IPC角度来说，Binder是Android中的一种跨进程通信方式，从Android Framework角度来说，Binder是ServiceManager连接各种Manager(ActivityManager、WindowManager，等等)和相应ManagerService的桥梁；从Android应用层来说，Binder是客户端和服务端进行通信的媒介。 创建AIDL示例 创建一个Book类，实现Parcelable接口。 12345678910111213141516171819202122232425262728293031323334353637public class Book implements Parcelable &#123; private int bookId; private String bookName; public Book(int bookId, String bookName) &#123; this.bookId = bookId; this.bookName = bookName; &#125; @Override public int describeContents() &#123; return 0; &#125; @Override public void writeToParcel(Parcel dest, int flags) &#123; dest.writeInt(this.bookId); dest.writeString(this.bookName); &#125; protected Book(Parcel in) &#123; this.bookId = in.readInt(); this.bookName = in.readString(); &#125; public static final Creator&lt;Book&gt; CREATOR = new Creator&lt;Book&gt;() &#123; @Override public Book createFromParcel(Parcel source) &#123; return new Book(source); &#125; @Override public Book[] newArray(int size) &#123; return new Book[size]; &#125; &#125;;&#125; 创建IBookManager.aidl文件，需要注意的是，在AndroidStudio中，右键创建aidl文件时候，IDE会自动创建一个和java平级的aidl文件夹，我们创建的aidl文件就在这里面。 Book.aidl 12package com.example.huangyuan.testandroid;parcelable Book; Book.aidl是Book.java类在AIDL中的声明。 IBookManager.aidl 12345678910111213141516// IBookManager.aidlpackage com.example.huangyuan.testandroid;import com.example.huangyuan.testandroid.Book;// Declare any non-default types here with import statementsinterface IBookManager &#123; /** * Demonstrates some basic types that you can use as parameters * and return values in AIDL. */ void basicTypes(int anInt, long aLong, boolean aBoolean, float aFloat, double aDouble, String aString); List&lt;Book&gt; getBookList(); void addBook(in Book book);&#125; 其中 basicTypes是IDE自动生成的，我们自己添加 getBookList() 和 addBook 两个方法尽管Book类和IBookManager的包名相同，但是在IBookManager中仍要导入Book类。下面看一下IDE生成的IBookManager.java类，该类在app/build/generated/source/aidl/debug/packageName包下。123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182/* * This file is auto-generated. DO NOT MODIFY. * Original file: /Users/huangyuan/AndroidStudioProjects/TestAndroid/app/src/main/aidl/com/example/huangyuan/testandroid/IBookManager.aidl */package com.example.huangyuan.testandroid;// Declare any non-default types here with import statementspublic interface IBookManager extends android.os.IInterface &#123; /** * Local-side IPC implementation stub class. */ public static abstract class Stub extends android.os.Binder implements com.example.huangyuan.testandroid.IBookManager &#123; private static final java.lang.String DESCRIPTOR = "com.example.huangyuan.testandroid.IBookManager"; /** * Construct the stub at attach it to the interface. */ public Stub() &#123; this.attachInterface(this, DESCRIPTOR); &#125; /** * Cast an IBinder object into an com.example.huangyuan.testandroid.IBookManager interface, * generating a proxy if needed. */ public static com.example.huangyuan.testandroid.IBookManager asInterface(android.os.IBinder obj) &#123; if ((obj == null)) &#123; return null; &#125; android.os.IInterface iin = obj.queryLocalInterface(DESCRIPTOR); if (((iin != null) &amp;&amp; (iin instanceof com.example.huangyuan.testandroid.IBookManager))) &#123; return ((com.example.huangyuan.testandroid.IBookManager) iin); &#125; return new com.example.huangyuan.testandroid.IBookManager.Stub.Proxy(obj); &#125; @Override public android.os.IBinder asBinder() &#123; return this; &#125; @Override public boolean onTransact(int code, android.os.Parcel data, android.os.Parcel reply, int flags) throws android.os.RemoteException &#123; switch (code) &#123; case INTERFACE_TRANSACTION: &#123; reply.writeString(DESCRIPTOR); return true; &#125; case TRANSACTION_basicTypes: &#123; data.enforceInterface(DESCRIPTOR); int _arg0; _arg0 = data.readInt(); long _arg1; _arg1 = data.readLong(); boolean _arg2; _arg2 = (0 != data.readInt()); float _arg3; _arg3 = data.readFloat(); double _arg4; _arg4 = data.readDouble(); java.lang.String _arg5; _arg5 = data.readString(); this.basicTypes(_arg0, _arg1, _arg2, _arg3, _arg4, _arg5); reply.writeNoException(); return true; &#125; case TRANSACTION_getBookList: &#123; data.enforceInterface(DESCRIPTOR); java.util.List&lt;com.example.huangyuan.testandroid.Book&gt; _result = this.getBookList(); reply.writeNoException(); reply.writeTypedList(_result); return true; &#125; case TRANSACTION_addBook: &#123; data.enforceInterface(DESCRIPTOR); com.example.huangyuan.testandroid.Book _arg0; if ((0 != data.readInt())) &#123; _arg0 = com.example.huangyuan.testandroid.Book.CREATOR.createFromParcel(data); &#125; else &#123; _arg0 = null; &#125; this.addBook(_arg0); reply.writeNoException(); return true; &#125; &#125; return super.onTransact(code, data, reply, flags); &#125; private static class Proxy implements com.example.huangyuan.testandroid.IBookManager &#123; private android.os.IBinder mRemote; Proxy(android.os.IBinder remote) &#123; mRemote = remote; &#125; @Override public android.os.IBinder asBinder() &#123; return mRemote; &#125; public java.lang.String getInterfaceDescriptor() &#123; return DESCRIPTOR; &#125; /** * Demonstrates some basic types that you can use as parameters * and return values in AIDL. */ @Override public void basicTypes(int anInt, long aLong, boolean aBoolean, float aFloat, double aDouble, java.lang.String aString) throws android.os.RemoteException &#123; android.os.Parcel _data = android.os.Parcel.obtain(); android.os.Parcel _reply = android.os.Parcel.obtain(); try &#123; _data.writeInterfaceToken(DESCRIPTOR); _data.writeInt(anInt); _data.writeLong(aLong); _data.writeInt(((aBoolean) ? (1) : (0))); _data.writeFloat(aFloat); _data.writeDouble(aDouble); _data.writeString(aString); mRemote.transact(Stub.TRANSACTION_basicTypes, _data, _reply, 0); _reply.readException(); &#125; finally &#123; _reply.recycle(); _data.recycle(); &#125; &#125; @Override public java.util.List&lt;com.example.huangyuan.testandroid.Book&gt; getBookList() throws android.os.RemoteException &#123; android.os.Parcel _data = android.os.Parcel.obtain(); android.os.Parcel _reply = android.os.Parcel.obtain(); java.util.List&lt;com.example.huangyuan.testandroid.Book&gt; _result; try &#123; _data.writeInterfaceToken(DESCRIPTOR); mRemote.transact(Stub.TRANSACTION_getBookList, _data, _reply, 0); _reply.readException(); _result = _reply.createTypedArrayList(com.example.huangyuan.testandroid.Book.CREATOR); &#125; finally &#123; _reply.recycle(); _data.recycle(); &#125; return _result; &#125; @Override public void addBook(com.example.huangyuan.testandroid.Book book) throws android.os.RemoteException &#123; android.os.Parcel _data = android.os.Parcel.obtain(); android.os.Parcel _reply = android.os.Parcel.obtain(); try &#123; _data.writeInterfaceToken(DESCRIPTOR); if ((book != null)) &#123; _data.writeInt(1); book.writeToParcel(_data, 0); &#125; else &#123; _data.writeInt(0); &#125; mRemote.transact(Stub.TRANSACTION_addBook, _data, _reply, 0); _reply.readException(); &#125; finally &#123; _reply.recycle(); _data.recycle(); &#125; &#125; &#125; static final int TRANSACTION_basicTypes = (android.os.IBinder.FIRST_CALL_TRANSACTION + 0); static final int TRANSACTION_getBookList = (android.os.IBinder.FIRST_CALL_TRANSACTION + 1); static final int TRANSACTION_addBook = (android.os.IBinder.FIRST_CALL_TRANSACTION + 2); &#125; /** * Demonstrates some basic types that you can use as parameters * and return values in AIDL. */ public void basicTypes(int anInt, long aLong, boolean aBoolean, float aFloat, double aDouble, java.lang.String aString) throws android.os.RemoteException; public java.util.List&lt;com.example.huangyuan.testandroid.Book&gt; getBookList() throws android.os.RemoteException; public void addBook(com.example.huangyuan.testandroid.Book book) throws android.os.RemoteException;&#125; 结构比较简单，最外面是IBookManager接口，其中声明了一个抽象内部类Stub，在该类中，声明了一个Proxy代理类。还声明了三个静态变量来标志aidl文件中的三个方法。这个Stub就是一个Binder类，当客户端和服务端都位于同一个进程时，方法调用不会走跨进程的transact过程，而当两者位于不同进程时，方法调用需要走transact过程，这个逻辑由内部Proxy类来完成。最后，声明了aidl文件中的三个方法。下面详细介绍： DESCRIPTOR Binder的唯一标示，一般用当前Binder的类名标示 asInterface(android.os.IBinder obj) 用于将服务端的BInder对象转换成客户端所需的AIDL借口类型的对象，这种转换过程是区分进程的，如果客户端和服务端位于同一进程，那么此方法返回的就是服务端的Stub对象本身，否则返回的是系统封装后的Stub.proxy对象。 asBinder 用于返回当前Binder对象 onTransact 这个方法运行在服务端中的Binder线程池中，当客户端发起跨进程请求时，远程请求会通过系统底层封装后交由此方法来处理。该方法的原型为public Boolean onTransact(int code,android.os. Parcel data,android.os.Parcel reply,int flags)。服务端通过code可以确定客户端所请求的目标方法是什么，接着从data中取出目标方法所需的参数(如果目标方法有参数的话)，然后执行目标方法。当目标方法执行完毕后，就向reply中写入返回值(如果目标方法有返回值的话)，onTransact方 法的执行过程就是这样的。需要注意的是，如果此方法返回false,那么客户端的请求会失败，因此我们可以利用这个特性来做权限验证，毕竟我们也不希望随便-一个进程都能远程调用我们的服务。 Proxy#getBookList 这个方法运行在客户端，当客户端远程调用此方法时，它的内部实现是这样的:首先创建该方法所需要的输入型Parcel对象data、 输出型Parcel对象 reply和返回值对象List;然后把该方法的参数信息写入_data中(如果有参数的话);接着调用transact方法来发起RPC (远程过程调用)请求，同时当前线程挂起;然后服务端的onTransact方法会被调用，直到RPC过程返回后，当前线程继续执行，并从_reply中 取出RPC过程的返回结果;最后返回_reply中的数据。 Proxy#addBook 这个方法运行在客户端，它的执行过程和getBookList是一样的，addBook没有返回值，所以它不需要从_replay中取出返回值。 接下来，我们介绍Binder的两个很重要的方法linkToDeath和unlinkToDeath。我们知道，Binder运行在服务端进程，如果服务端进程由于某种原因异常终止，这个时候我们到服务端的Binder连接断裂(称之为Binder死亡)，会导致我们的远程调用失败。更为关键的是，如果我们不知道Binder连接已经断裂，那么客户端的功能就会受到影响。为了解决这个问题，Binder中提供 了两个配对的方法linkToDeath和unlinkToDeath,通过linkToDeath我们可以给Binder设置- - 个死亡代理，当Binder死亡时， 我们就会收到通知，这个时候我们就可以重新发起连接请求从而恢复连接。那么到底如何给Binder设置死亡代理呢?也很简单。首先，声明一个DeathRecipient对象。DeathRecipient是一个接口，其内部只有一个方法binderDied,我们需要实现这个方法，当Binder死亡的时 候，系统就会回调binderDied方法，然后我们就可以移出之前绑定的binder代理并重新绑定远程服务:12345678910private IBinder .DeathRecipient mDeathRecipient = new IBinder.DeathRecipient() &#123; @Override public void binderDied() &#123; if ( mBookManager ==null) return; mBookManager.asBinder().unlinkToDeath(mDeathRecipient 0); mBookManager = null; &#125;); 其次，在客户端绑定远程服务成功后，给binder设置死亡代理。12mService = IMessageBoxManager.Stub.asInterface(binder);binder.linkToDeath(mDeathRecipient,0); 其中linkToDeath的第二个参数是个标记位，我们直接设为0即可。经过上面两个步骤，就给我们的Binder设置了死亡代理，当Binder死 亡的时候我们就可以收到通知了。另外，通过Binder的 方法isBinderAlive也可以判断Binder是否死亡。 这一篇全部都是抄的《Android开发艺术探索》第2.3.3Binder 章节上的内容，毕竟一直带着书也不现实 以上]]></content>
      <tags>
        <tag>Android</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Android7.0 MultiWindow]]></title>
    <url>%2F2018%2F06%2F11%2FAndroid7-0%E5%88%86%E5%B1%8F%E5%AE%9E%E7%8E%B0%2F</url>
    <content type="text"><![CDATA[Android7.0推出了多窗口(分屏)模式，允许一个屏幕下显示两个应用，可以一边追剧一边看电子书，不过在小一点的手机屏幕上看起来可能有点鸡肋。但是在TV端(这个屏幕就比较大了，一般都是40寸起步)中，画中画模式可以让我们同时进行多个任务了。 开启分屏只要你编译使用sdk版本大于等于7.0就可以支持分屏了：compileSdkVersion 25，如果想要禁用分屏，只需要在AndroidManifest.xml添加属性：android:resizeableActivity=”false”，这个属性使用于application和Activity标签。7.0中默认是true。除了分屏模式之外，还有自由模式(Freeform,常见于桌面设备，类似于windows的应用窗口，可以拖拽边缘改变大小)。 生命周期开启多窗口模式不会更改Activity的生命周期，在多窗口模式中，在指定时间只有最近与用户交互过的 Activity 为活动状态。 该 Activity 将被视为顶级 Activity。 所有其他 Activity 虽然可见，但均处于暂停状态。 但是，这些已暂停但可见的 Activity 在系统中享有比不可见 Activity 更高的优先级。 如果用户与其中一个暂停的 Activity 交互，该 Activity 将恢复，而之前的顶级 Activity 将暂停。 例如：在上图中，我先打开了上面的Activity，然后又打开了下面Gmail的Activity，这时下面的Activity处于可交互(顶级Activity)状态，上面的Activity虽然课件，但是处于暂停状态，这时按下back键是对下面Activity进行操作。当点击上面的Activity时，上面的Activity处于可交互状态，下面的Activity处于暂停状态。PS：在多窗口模式中，用户仍可以看到处于暂停状态的应用。 应用在暂停状态下可能仍需要继续其操作。 例如，处于暂停模式但可见的视频播放应用应继续显示视频。 因此，我们建议播放视频的 Activity 不要暂停其 onPause() 处理程序中的视频。 应暂停 onStop() 中的视频，并恢复 onStart() 中的视频播放。 用户使用多窗口模式显示应用时，系统将通知 Activity 发生配置变更。 该变更与系统通知应用设备从纵向模式切换到横向模式时的 Activity 生命周期影响基本相同，但设备不仅仅是交换尺寸，而是会变更尺寸。您的 Activity 可以自行处理配置变更，或允许系统销毁 Activity，并以新的尺寸重新创建该 Activity。给Activity加上如下配置可以保证切换成多屏模式或者画中画模式时Activity不会销毁重建。android:configChanges=”screenSize|smallestScreenSize|screenLayout|orientation” 针对多窗口模式配置应用如果应用支持 Android N，您可以对应用的 Activity 是否支持多窗口显示以及显示方式进行配置。 您可以在清单文件中设置属性，以控制大小和布局。 根 Activity 的属性设置适用于其任务栈中的所有 Activity。 例如，如果根 Activity 中 android:resizeableActivity 设定为 true，则任务栈中的所有 Activity 都将可以调整大小。如果使用低于 Android N 版本的 SDK 构建多向应用，则用户在多窗口模式中使用应用时，系统将强制调整应用大小。 系统将显示对话框，提醒用户应用可能会发生异常。 系统不会调整定向应用的大小；如果用户尝试在多窗口模式下打开定向应用，应用将全屏显示。 android:resizeableActivity 在清单的 &lt;activity&gt; 或 &lt;application&gt; 节点中设置该属性，启用或禁用多窗口显示： 1android:resizeableActivity=["true" | "false"] 如果该属性设置为 true，Activity 将能以分屏和自由形状模式启动。 如果此属性设置为 false，Activity 将不支持多窗口模式。 如果该值为 false，且用户尝试在多窗口模式下启动 Activity，该 Activity 将全屏显示。如果应用面向 Android N，但未对该属性指定值，则该属性的值默认设为 true。 android:supportsPictureInPicture 在清单文件的 &lt;activity&gt; 节点中设置该属性，指明 Activity 是否支持画中画显示。 如果 android:resizeableActivity 为 false，将忽略该属性。1android:supportsPictureInPicture=["true" | "false"] 布局属性对于 Android N，&lt;layout&gt; 清单元素支持以下几种属性，这些属性影响 Activity 在多窗口模式中的行为： android:defaultWidth以自由形状模式启动时 Activity 的默认宽度。android:defaultHeight以自由形状模式启动时 Activity 的默认高度。android:gravity以自由形状模式启动时 Activity 的初始位置。请参阅 Gravity 参考资料，了解合适的值设置。android:minimalHeight、android:minimalWidth分屏和自由形状模式中 Activity 的最小高度和最小宽度。 如果用户在分屏模式中移动分界线，使 Activity 尺寸低于指定的最小值，系统会将 Activity 裁剪为用户请求的尺寸。例如，以下节点显示了如何指定 Activity 在自由形状模式中显示时 Activity 的默认大小、位置和最小尺寸： 1234567&lt;activity android:name=".MyActivity"&gt; &lt;layout android:defaultHeight="500dp" android:defaultWidth="600dp" android:gravity="top|end" android:minimalHeight="450dp" android:minimalWidth="300dp" /&gt;&lt;/activity&gt; 在多窗口模式中运行应用 多窗口模式中被禁用的功能 在设备处于多窗口模式中时，某些功能会被禁用或忽略，因为这些功能对与其他 Activity 或应用共享设备屏幕的 Activity 而言没有意义。 此类功能包括： 某些系统 UI 自定义选项将被禁用；例如，在非全屏模式中，应用无法隐藏状态栏。 系统将忽略对 android:screenOrientation 属性所作的更改。 多窗口变更通知和查询 Activity.isInMultiWindowMode()调用该方法以确认 Activity 是否处于多窗口模式。 Activity.isInPictureInPictureMode()调用该方法以确认 Activity 是否处于画中画模式。 画中画模式是多窗口模式的特例。 如果 myActivity.isInPictureInPictureMode() 返回 true，myActivity.isInMultiWindowMode() 也返回 true。 Activity.onMultiWindowModeChanged()Activity 进入或退出多窗口模式时系统将调用此方法。 在 Activity 进入多窗口模式时，系统向该方法传递 true 值，在退出多窗口模式时，则传递 false 值。 Activity.onPictureInPictureModeChanged()Activity 进入或退出画中画模式时系统将调用此方法。 在 Activity 进入画中画模式时，系统向该方法传递 true 值，在退出画中画模式时，则传递 false 值。 每个方法还有 Fragment 版本，例如 Fragment.isInMultiWindowMode()。 进入画中画模式如需在画中画模式中启动 Activity，请调用新方法 Activity.enterPictureInPictureMode()。 如果设备不支持画中画模式，则此方法无效。 如需了解详细信息，请参阅画中画文档。https://developer.android.com/guide/topics/ui/picture-in-picture 在多窗口模式中启动新 Activity如果只是简单的开启Activity，和在非多窗口模式下是一致的。如果想要在当前Activity的旁边启动Activity，可以添加FLAG_ACTIVITY_LAUNCH_ADJACENT标志位(官方文档说是Intent.FLAG_ACTIVITY_LAUNCH_TO_ADJACENT,但在实际操作中这个标志位不存在)，传递此标志将请求以下行为： 如果设备处于分屏模式，系统会尝试在启动系统的 Activity 旁创建新 Activity，这样两个 Activity 将共享屏幕。 系统并不一定能实现此操作，但如果可以，系统将使两个 Activity 处于相邻的位置。 如果设备不处于分屏模式，则该标志无效。如果设备处于自由形状模式，则在启动新 Activity 时，用户可通过调用 ActivityOptions.setLaunchBounds() 指定新 Activity 的尺寸和屏幕位置。 如果设备不处于多窗口模式，则该方法无效。PS:如果在任务栈中启动 Activity，该 Activity 将替换屏幕上的 Activity，并继承其所有的多窗口属性。 如果要在多窗口模式中以单独的窗口启动新 Activity，则必须在新的任务栈中启动此 Activity。 支持拖放用户可以在两个 Activity 共享屏幕的同时在这两个 Activity 之间拖放数据 （在此之前，用户只能在一个 Activity 内部拖放数据）。 android.view.DropPermissions令牌对象，负责指定对接收拖放数据的应用授予的权限。 View.startDragAndDrop()View.startDrag() 的新别名。要启用跨 Activity 拖放，请传递新标志 View.DRAG_FLAG_GLOBAL。 如需对接收拖放数据的 Activity 授予 URI 权限，可根据情况传递新标志 View.DRAG_FLAG_GLOBAL_URI_READ 或 View.DRAG_FLAG_GLOBAL_URI_WRITE。 View.cancelDragAndDrop()取消当前正在进行的拖动操作。只能由发起拖动操作的应用调用。 View.updateDragShadow()替换当前正在进行的拖动操作的拖动阴影。只能由发起拖动操作的应用调用。 Activity.requestDropPermissions()请求使用 DragEvent 中包含的 ClipData 传递的内容 URI 的权限。 代码 在当前Activity旁边开启新界面 如下图所示，上面的界面是MainActivity，下面的Activity是在MainActivity中点击获取实时天气开启的界面在MainActivity中 12345678findViewById(R.id.get_weather).setOnClickListener(new View.OnClickListener() &#123; @Override public void onClick(View v) &#123; Intent intent = new Intent(MainActivity.this,Main2Activity.class); intent.addFlags(Intent.FLAG_ACTIVITY_LAUNCH_ADJACENT | Intent.FLAG_ACTIVITY_NEW_TASK); startActivity(intent); &#125;&#125;); 为什么需要 FLAG_ACTIVITY_NEW_TASK:官方解释 在同一个Activity返回栈中，打开一个新的Activity时，这个Activity将会继承上一个Activity所有和分屏模式有关的属性。如果你想要在一个独立的窗口以分屏模式打开一个新的Activity，那么必须新建一个Activity返回栈。 拖拽 首先在多窗口模式下打开新界面，如上面的代码所示。在MainActivity中发起拖拽12345678910111213141516171819202122final Button dragedButton = findViewById(R.id.drag_to_another);//拖拽按钮 dragedButton.setTag("this is a test"); dragedButton.setOnTouchListener(new View.OnTouchListener() &#123; @Override public boolean onTouch(View v, MotionEvent event) &#123; if(event.getAction() == MotionEvent.ACTION_DOWN)&#123; ClipData.Item item = new ClipData.Item((CharSequence) dragedButton.getTag()); String[] mimeTypes = &#123;ClipDescription.MIMETYPE_TEXT_PLAIN&#125;; ClipData dragData = new ClipData(v.getTag().toString(), mimeTypes, item); View.DragShadowBuilder shadow = new View.DragShadowBuilder(dragedButton); /** startDragAndDrop是Android N SDK中的新方法，替代了以前的startDrag，flag需要设置为DRAG_FLAG_GLOBAL */ v.startDragAndDrop(dragData, shadow, null, View.DRAG_FLAG_GLOBAL); return true; &#125; else &#123; return false; &#125; &#125; &#125;); 在第二个界面中接收拖拽结果123456789101112131415161718192021222324252627282930313233343536373839final TextView textView = findViewById(R.id.show_drag_view_tag); textView.setText("拖拽到这里"); textView.setOnDragListener(new View.OnDragListener() &#123; @Override public boolean onDrag(View view, DragEvent dragEvent) &#123; switch (dragEvent.getAction()) &#123; case DragEvent.ACTION_DRAG_STARTED: Log.d(TAG, "Action is DragEvent.ACTION_DRAG_STARTED"); break; case DragEvent.ACTION_DRAG_ENTERED: Log.d(TAG, "Action is DragEvent.ACTION_DRAG_ENTERED"); break; case DragEvent.ACTION_DRAG_EXITED: Log.d(TAG, "Action is DragEvent.ACTION_DRAG_EXITED"); break; case DragEvent.ACTION_DRAG_LOCATION: break; case DragEvent.ACTION_DRAG_ENDED: Log.d(TAG, "Action is DragEvent.ACTION_DRAG_ENDED"); break; case DragEvent.ACTION_DROP: Log.d(TAG, "ACTION_DROP event"); /** 3.在这里显示接收到的结果 */ textView.setText(dragEvent.getClipData().getItemAt(0).getText()); break; default: break; &#125; return true; &#125; &#125;); &#125; 将MainActivity中的拖拽按钮拖放的第二个界面中拖拽到这里view上之后关于startDragAndDrop，官方参考文档在这里startDragAndDrophttps://developer.android.com/reference/android/view/View?hl=zh-cn#startDrag 以上]]></content>
      <tags>
        <tag>Android</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[面试总结]]></title>
    <url>%2F2018%2F06%2F03%2F%E9%9D%A2%E8%AF%95%E6%80%BB%E7%BB%93%2F</url>
    <content type="text"><![CDATA[最近的面试过程中遇到的面试题，涉及的方面比较广泛，大致分成了一下几个方面：操作系统、Java、Android、计算机网络、其他(kotlin、react、安全之类的)。 操作系统相关：进程和线程的区别 进程是资源的分配和调度的一个独立单元，而线程是CPU调度的基本单元 同一个进程中可以包括多个线程，并且线程共享整个进程的资源（寄存器、堆栈、上下文），一个进行至少包括一个线程。 进程的创建调用fork或者vfork，而线程的创建调用pthread_create，进程结束后它拥有的所有线程都将销毁，而线程的结束不会影响同个进程中的其他线程的结束 线程是轻两级的进程，它的创建和销毁所需要的时间比进程小很多，所有操作系统中的执行功能都是创建线程去完成的 线程中执行时一般都要进行同步和互斥，因为他们共享同一进程的所有资源 线程有自己的私有属性TCB，线程id，寄存器、硬件上下文，而进程也有自己的私有属性进程控制块PCB，这些私有属性是不被共享的，用来标示一个进程或一个线程的标志 线程调度算法 SCHED_OTHER：普通任务调度策略。 SCHED_FIFO：实时任务调度策略，先到先服务。一旦占用cpu则一直运行，直到有更高优先级任务到达或自己放弃。 SCHED_RR：实时任务调度策略，时间片轮转。当任务的时间片用完，系统将重新分配时间片，并置于就绪队列尾。放在队列尾具体涉及到N多内容，自行搜索 内存页面置换算法为提高内存利用率，解决内存供不应求的问题，更加合理的使用内存，人们创造了分页式内存抽象。同时有一个虚拟内存的概念，是指将内存中暂时不需要的部分写入硬盘，看上去硬盘扩展了内存的容量，所以叫做“虚拟”内存。使用虚拟内存，应用程序可以使用比实际物理内存更大的内存空间。可以认为这个更大的内存空间就在硬盘上，只有将某一部分需要被用到时，才被写入真实内存；当它暂时不再被用到时，又被写回硬盘。分页式内存管理将物理内存分为等大的小块，每块大小通常为1K、2K、4K等，称为页帧；逻辑内存（使用虚拟内存技术扩大的内存，可认为其位于硬盘上）也被分为等大的小块，称为页；且页和页帧的大小一定是一样的，它是写入真实内存和写回硬盘最小单位。 Optimal算法（最优算法） 从内存中移除永远都不再需要的页面或者说是未来最长时间内不再被访问的页面，如果这样的页面存在，则选择最长时间不需要访问的页面。采用最佳置换算法，可以保证较低的页面更新频率。从理论上讲，由于无法预知哪一个页面是未来最长时间内不再被访问的，因而该算法无法实现，但是可用来衡量其他算法。 FIFO（First-In First-Out，先进先出）算法 该算法总是淘汰最早进入内存的页面，即选择在内存中停留时间最久的页面予以淘汰。 这个算法的实现简单，只需要将进程已调入内存中的页面，按照先后顺序连接成一个队列，设置一个替换指针，总是指向最老的页面。 但是该算法与进程实际的规律并不相适应，因为在进程中，有些页面经常被访问，比如：含有全局变量、常用函数、例程等的页面，FIFO不能保证这些页面不会被淘汰。 正是由于没有考虑页面的重要性的问题，FIFO算法很容易将重要的页换出内存。 Second Chance（第二次机会）算法 为了避免FIFO算法将重要的页换出内存，Second Chance算法提供了一些改进。Second Chance算法在将页面换出内存前检查其使用位，如果其使用位为1，证明此页最近有被使用，猜测它还可能被使用，于是不把它置换出内存，但是把其使用位置为0，随后检查下一个页面，直到发现某页的使用位为0，将此页置换出内存。 LRU（Least Recent Used, 最近最少使用）算法 在之前的FIFO算法中，依据的是各个页面调入内存的时间，这并不能反映页面的真实使用情况。而LRU（Latest Recently Used）是根据页面调入内存之后的使用情况。由于无法预测页面未来的情况，所以只能利用“最近的过去”来作为预测未来的方法，LRU选择的是最近最久未使用的页面予以淘汰。 该算法赋予每个页面一个访问字段，用来记录一个页面从上次被访问以来所经历的时间t，当需要淘汰一个页面的时候，选择现有页面中t的值最大的页面进行淘汰。 LRU是一种优秀的页面置换算法，但是需要硬件的支持，为了了解一个进程在内存中各个页面各有多少时间未被进程访问，以及如何快速地知道哪一个页面是最近最久未使用的页面，需要 寄存器+栈 来支持。 java相关：synchronized 和Lock的区别 以及实现原理 教科书式的应试回答： 主要相同点：Lock能完成synchronized所实现的所有功能 主要不同点：Lock有比synchronized更精确的线程语义和更好的性能。synchronized会自动释放锁，而Lock一定要求程序员手工释放，并且必须在finally从句中释放。 类别 synchronized synchronized 存在层次 Java的关键字，在jvm层面上 是一个类 锁的释放 1、以获取锁的线程执行完同步代码，释放锁 2、线程执行发生异常，jvm会让线程释放锁 在finally中必须释放锁，不然容易造成线程死锁 锁的获取 假设A线程获得锁，B线程等待。如果A线程阻塞，B线程会一直等待 分情况而定，Lock有多个锁获取的方式，具体下面会说道，大致就是可以尝试获得锁，线程可以不用一直等待 锁状态 无法判断 可以判断 锁类型 可重入 不可中断 非公平 可重入 可判断 可公平（两者皆可） 性能 少量同步 大量同步 关于同步类(java.util.concurrent包下)的介绍可以看这个 http://blog.huangyuanlove.com/2018/03/20/Java%E5%B9%B6%E5%8F%91%E5%A4%9A%E7%BA%BF%E7%A8%8B%E5%90%8C%E6%AD%A5/#more关于Lock的底层实现可以看这篇：https://blog.csdn.net/Luxia_24/article/details/52403033关于synchronized可以看这篇 https://blog.csdn.net/u012403290/article/details/64910926?locationNum=11&amp;fps=1 Map、Set、List区别这个自己翻一下源码看一下就好Map-&gt; HashMap(存入数据的过程，hash冲突了怎么办),TreeMap,LinkedHashMapSet-&gt; 使用Map实现的，set中存放的数据对应map中的key，value是内部的一个object字段list-&gt; ArrayList(数组),LinkedList(链表)区别，优缺点 Java虚拟机这个主要是问内存区域，垃圾回收算法，可以参考这里：JVM-内存分配与回收策略 http://blog.huangyuanlove.com/2017/04/07/JVM-%E5%86%85%E5%AD%98%E5%88%86%E9%85%8D%E4%B8%8E%E5%9B%9E%E6%94%B6%E7%AD%96%E7%95%A5/JVM-垃圾收集算法与实现 http://blog.huangyuanlove.com/2017/03/30/JVM-%E5%9E%83%E5%9C%BE%E6%94%B6%E9%9B%86%E7%AE%97%E6%B3%95/JVM垃圾回收-对象已死？ http://blog.huangyuanlove.com/2017/03/29/JVM%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6-%E5%AF%B9%E8%B1%A1%E5%B7%B2%E6%AD%BB%EF%BC%9F/JVM内存区域 http://blog.huangyuanlove.com/2017/03/27/JVM%E5%86%85%E5%AD%98%E5%8C%BA%E5%9F%9F/ 捕获子线程异常123456789101112new Thread().setUncaughtExceptionHandler(new Thread.UncaughtExceptionHandler() &#123; @Override public void uncaughtException(Thread t, Throwable e) &#123; &#125; &#125;);Thread.setDefaultUncaughtExceptionHandler(new Thread.UncaughtExceptionHandler() &#123; @Override public void uncaughtException(Thread t, Throwable e) &#123; &#125; &#125;); 如果一个线程没有显式的设置它的UncaughtExceptionHandler，JVM就会检查该线程所在的线程组是否设置了UncaughtExceptionHandler，如果已经设置，就是用该UncaughtExceptionHandler；否则查看是否在Thread层面通过静态方法setDefaultUncaughtExceptionHandler()设置了UncaughtExceptionHandler，如果已经设置就是用该UncaughtExceptionHandler；如果上述都没有找到，JVM会在对应的console中打印异常的堆栈信息。具体情况可以看一下Java并发编程的艺术 线程池这是个大坑，看源码吧ThreadPoolExecutor.java，还有就是常见线程池的比较。 单例模式 线程安全单例的模式的N种写法，像什么double check、懒汉模式、静态内部类，还有就是枚举方式。这里会引出来volatile关键字，然后就是线程安全的问题。 Android相关：多进程写sp的问题还是线程安全的问题，因为SP不支持两个进程同事去执行写操作，否则会导致一定几率的数据丢失，这是因为SP底层通过读写xml文件来实现的，并发写显然是有问题的 sp底层实现读写xml文件 Activity和Fragment生命周期,生命周期函数是谁调用的声明周期函数是由ActivityThread调度的，具体逻辑封装在Instrumentation类里面。具体读一下这两个类就好。 Activity启动模式，启动过程单独开了一篇博客http://blog.huangyuanlove.com/2018/07/26/Activity%E5%90%AF%E5%8A%A8%E6%A8%A1%E5%BC%8F%EF%BC%8C%E5%90%AF%E5%8A%A8%E8%BF%87%E7%A8%8B/#more View点击事件分发流程View事件分发：http://blog.huangyuanlove.com/2018/07/29/View事件分发/#more View绘制过程View绘制过程：http://blog.huangyuanlove.com//2018/07/29/View绘制过程/#more HandlerAndroid的消息机制: http://blog.huangyuanlove.com/2017/03/23/Android%E7%9A%84%E6%B6%88%E6%81%AF%E6%9C%BA%E5%88%B6/#more 省电优化不打扰系统休眠（不监听电量变化等，三方的可以hook oop hook住oncreat）不做不必要的动作（界面后台要停止动画） 广播的底层实现（binder）Android 广播 ：http://blog.huangyuanlove.com/2018/07/31/Android%E5%B9%BF%E6%92%AD/ 计算机网络相关：websocket为什么能保持长连接http、tcp/udp、tcp怎么解决拥塞、滑动窗口、udp这个可以看谢希仁的《计算机网络》第六版，tcp:http://blog.huangyuanlove.com/2017/07/03/TCP%E5%8D%8F%E8%AE%AE%E7%9A%84%E7%AE%80%E5%8D%95%E7%90%86%E8%A7%A3/#more 这里简单的记录了一下比较重要的东西。 其他：加固原理 加的什么壳kt var val区别 when中的 is in]]></content>
      <tags>
        <tag>Android</tag>
        <tag>面试</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[项目重构记录]]></title>
    <url>%2F2018%2F05%2F24%2F%E9%A1%B9%E7%9B%AE%E9%87%8D%E6%9E%84%E8%AE%B0%E5%BD%95%2F</url>
    <content type="text"><![CDATA[总结一下在新公司一个月来学到的东西吧。公司的项目采用Native+RN进行开发，前两周简单的了解了一下项目结构，写了一些自动打包的脚本。后两周大致学习了一下RN，然后就是调整项目结构，做重构。 一些简单的记录， 需要注意的地方 主工程module下的插件是 apply plugin: ‘com.android.application’ library中的插件是 apply plugin: ‘com.android.library’ 在library module中，生成的R文件中的变量没有被final修饰，所以在switch case中需要改一下写法，比如改成if else。 ButterKnife中注解@bind中要求参数是final类型，所以在library中这个注解也不好用，作者给出了解决方案。 library module中不能有applicationId。 改动记录涉及到源代码的部分没有公开。 将原项目中所有library依赖移动到BaseApp文件夹下,统一由一个git子模块引用。，所以需要在工程根目录下的setting.gradle中修改include路径 include ‘:base’ 改为 include ‘:BaseApp:base’ library中依赖的其他library也需要做修改(路径前添加:BaseApp )，如RiskControlSdk中dependencies中 12releaseCompile project(path: 'BaseComponents', configuration: 'release')debugCompile project(path: ':BaseComponents', configuration: 'debug') 改为 12releaseCompile project(path: ':BaseApp:BaseComponents', configuration: 'release')debugCompile project(path: ':BaseApp:BaseComponents', configuration: 'debug') 原app module(现base)中用到butterknife，在@bind注解要求参数是final类型，但是在library项目中，生成的R文件中的id不是final。butterknife作者给出类解决办法:升级butterknife到8.8.1，在library中的build.gradle添加apply plugin: &#39;com.jakewharton.butterknife&#39;插件，用于生成R2文件，将原来的R.id.xxx改为R2.id.xxx。同理，在switch case中用R.id的地方也要做相应修改。参考 https://github.com/JakeWharton/butterknife 将gradle依赖、某些appkey在根目录下的config.gradle中配置在项目根目录下新建config.gradle文件，用来存放公共配置，如 1234567891011121314151617181920212223242526272829303132ext &#123; url = "https://test.test.com" UMENG_APPKEY = "*****" UMENG_MESSAGE_SECRET = "*******" WEIXIN_APP_ID = "******" WEIXIN_APP_SECRET = "********" android = [ compileSdkVersion: 25, buildToolsVersion: "25.0.2", applicationId : "xxxxx", minSdkVersion : 16, targetSdkVersion : 22, versionCode : 120, versionName : "1.2.0", ] dependencies = [ "appcompat-v7" : "com.android.support:appcompat-v7:25.0.0", "support-v4" : 'com.android.support:support-v4:25.0.0', "support-v13" : 'com.android.support:support-v13:23.4.0', "support-annotations" : 'com.android.support:support-annotations:23.4.0', "butterknife" : "com.jakewharton:butterknife:8.8.1", "xutils" : 'org.xutils:xutils:3.5.0', "junit" : 'junit:junit:4.12', "react-native" : "com.facebook.react:react-native:0.49.5", "subsampling-scale-image-view": 'com.davemorrissey.labs:subsampling-scale-image-view:3.5.0', "eventbus" : 'de.greenrobot:eventbus:2.4.0', "okio" : 'com.squareup.okio:okio:1.8.0', "universal-image-loader" : 'com.nostra13.universalimageloader:universal-image-loader:1.9.5', "multidex" : 'com.android.support:multidex:1.0.1', "nohttp":'com.yanzhenjie.nohttp:nohttp:1.1.4', ]&#125; 使用时注意事项： 现在library中的所有appkey(三方)相关的，都由工程根目录下的配置文件config.gradle提供，然后添加到该module的BuildConfig.java文件中，代码中从BuildConfig.java文件中引用 在config.gradle文件中添加一个三方key值123ext&#123; UMENG_APPKEY = "************"&#125; 在module中的build.grale引用1def UMENG_APPKEY = rootProject.ext.UMENG_APPKEY 加入到该module的BuildConfig.java文件 123defaultConfig&#123; buildConfigField "String", "umeng_analytics_key", "\"" + UMENG_APPKEY + "\"" &#125; 代码中引用1BuildConfig.umeng_analytics_key 这里需要注意的是，import该文件的时候，是从该module的manifest.xml中的跟标签的package属性所指向的包名导入的，如 123&lt;manifest xmlns:android="http://schemas.android.com/apk/res/android" package="com.huangyuanlove.test"&gt;&lt;/manifest&gt; 则BuildConfig.java文件的导入路径为 import com.huangyuanlove.test; 所有使用gradle依赖的三方全部放在根目录的config.gradle文件夹下，其他module引用时可参考下面的配置。如 需要添加一个新的依赖，在根目录下的 config.gradle文件中 12345ext&#123; dependencies=[ "newDependency":"dependency", ]&#125; 在其他module中引用 1234def dependency = rootProject.ext.dependenciesdependencies &#123; compile dependency["newDependency"]&#125;]]></content>
      <tags>
        <tag>Android</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[网站免费升级https]]></title>
    <url>%2F2018%2F04%2F01%2F%E7%BD%91%E7%AB%99%E5%85%8D%E8%B4%B9%E5%8D%87%E7%BA%A7https%2F</url>
    <content type="text"><![CDATA[昨天跟着酷壳网左耳朵耗子的文章把自己在亚马逊主机上的网站变成https的安全访问了，证书不是自签名的，也不是花钱购买的。据说https的网站在搜索引擎中的rank值会比http的更高一些。升级完成后的浏览器截图如下：下面是这次升级的记录。为网站开启https安装证书非常简单，我用的是 Let’s Encrypt 这个免费的解决方案。 打开https://certbot.eff.org/这个网页 在Software 和 System选项里面选择你所使用的软件、系统，我用的nginx+ubuntu16.04 然后会跳转到一个新的网页，照着做就是了。就以nginx+ubuntu16.04为例：12345$ sudo apt-get update$ sudo apt-get install software-properties-common$ sudo add-apt-repository ppa:certbot/certbot$ sudo apt-get update$ sudo apt-get install python-certbot-nginx 安装成功后执行 $ sudo certbot --nginx让你输入你的邮箱，然后是同意用户协议，然后是是否公开你的邮箱。 接着会列出来nginx下所有配置的服务名称，输入你想要开启https的服务名称所对应的编号，如果想为多个服务开启https，中间以空格分隔。然后nginx重新加载一个配置或者重启一下。我个人服务器上的nginx配置的server_name是tomcat.huangyuanlove.com,域名是在万网买的，然后在万网控制台添加一个A解析，把tomcat.huangyuanlove.com指向服务器的ip即可。但是 Let’s Encrypt 的证书90天就过期了。所以还需要加上自动更新，使用crontab -e命令假如如下的定时作业(每个月强制更新一下)120 0 1 * * /usr/bin/certbot renew --force-renewal5 0 1 * * /usr/sbin/service nginx restart 需要注意的是，如果网站中有使用http的地方都要改成https,要不然一些资源文件如图片、js、css等非https的请求连接都会被ban掉。 关于ubuntu安装和配置nginx，我也是在官网找的教程，网址在这里https://www.nginx.com/resources/wiki/start/index.html,就知道你们不想看，安装命令如下：12sudo apt-get updatesudo apt-get install nginx 安装完成后，nginx配置文件在/etc/nginx/nginx.conf,在http标签中添加server：123456789101112131415161718server&#123; listen 80; server_name localhost; location / &#123; root html; index index.html index.htm; &#125; error_page 500 502 503 504 /50x.html; location = /50x.html&#123; root html; &#125;&#125;server&#123; server_name tomcat.huangyuanlove.com; location / &#123; proxy_pass http://xxx.xxx.xxx/; &#125;&#125; 给自己的添加https证书后，Certbot会修改你的nginx中的server配置，修改的内容如下：12345listen 443 ssl https2; # managed by Certbot ssl_certificate /etc/letsencrypt/live/tomcat.huangyuanlove.com/fullchain.pem; # managed by Certbot ssl_certificate_key /etc/letsencrypt/live/tomcat.huangyuanlove.com/privkey.pem; # managed by Certbot include /etc/letsencrypt/options-ssl-nginx.conf; # managed by Certbot ssl_dhparam /etc/letsencrypt/ssl-dhparams.pem; # managed by Certbot 12345678server&#123; if ($host = tomcat.huangyuanlove.com) &#123; return 301 https://$host$request_uri; &#125; # managed by Certbot listen 80; server_name tomcat.huangyuanlove.com; return 404; # managed by Certbot&#125; 基本上就是这样了，没有别的了。 以上，嗯，对了，12306你什么时候按照这个教程做一下你的证书？]]></content>
      <tags>
        <tag>乱七八糟</tag>
        <tag>网站https</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java并发多线程同步]]></title>
    <url>%2F2018%2F03%2F20%2FJava%E5%B9%B6%E5%8F%91%E5%A4%9A%E7%BA%BF%E7%A8%8B%E5%90%8C%E6%AD%A5%2F</url>
    <content type="text"><![CDATA[最近遇到了多线程并发同步问题，找到了java.util.concurrent包下的CountDownLatch、CyclicBarrier、Semaphore这三个类。CountDownLatch可以实现类似计数器的功能，例如线程A需要等待B、C、D三个线程执行完成之后才可以执行。CyclicBarrier可以实现让一组(多个)线程等待至某个状态之后再全部同时执行，当所有线程都被释放以后，CyclicBarrier可以被重用。Semaphore可以控制同时访问的线程个数，通过acquire()获取一个许可，如果没有就等待，而release()释放一个许可。 CountDownLatchCountDownLatch类只有一个构造方法：1234public CountDownLatch(int count) &#123; if (count &lt; 0) throw new IllegalArgumentException("count &lt; 0"); this.sync = new Sync(count); &#125; 这里的count是一个计数值，表示要等待多少任务，每次调用该对象示例的countDown()方法，该值都会减1，当count为0时表示没有需要等待的任务。常用的方法如下：123public void await() throws InterruptedException &#123; &#125;; //调用await()方法的线程会被挂起，它会等待直到count值为0才继续执行public boolean await(long timeout, TimeUnit unit) throws InterruptedException &#123; &#125;; //和await()类似，只不过等待一定的时间后count值还没变为0的话就会继续执行public void countDown() &#123; &#125;; //将count值减1 示例如下：1234567891011121314151617181920212223242526272829303132333435public static void testCountDownLatch() &#123; final CountDownLatch latch = new CountDownLatch(2); new Thread("one") &#123; public void run() &#123; try &#123; System.out.println("子线程" + Thread.currentThread().getName() + "正在执行"); Thread.sleep(3000); System.out.println("子线程" + Thread.currentThread().getName() + "执行完毕"); latch.countDown(); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; &#125;; &#125;.start(); new Thread("two") &#123; public void run() &#123; try &#123; System.out.println("子线程" + Thread.currentThread().getName() + "正在执行"); Thread.sleep(3000); System.out.println("子线程" + Thread.currentThread().getName() + "执行完毕"); latch.countDown(); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; &#125;; &#125;.start(); try &#123; System.out.println("等待2个线程执行完成"); latch.await(); System.out.println("子线程已经执行完毕"); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125;&#125; CyclicBarrier该类有两个构造方法12public CyclicBarrier(int parties, Runnable barrierAction)public CyclicBarrier(int parties) 参数parties是指让多少个线程或者任务等待至barrier状态，参数barrierAction是当这些线程都到达barrier状态后会执行的内容。该类里面有两个比较重要的方法：12public int await() throws InterruptedException, BrokenBarrierException &#123; &#125;;public int await(long timeout, TimeUnit unit)throws InterruptedException,BrokenBarrierException,TimeoutException &#123; &#125;; 无参的方法比较常用，用来挂起当前线程，直到所有线程都达到barrier状态再同时执行后续任务。有参的方法是让线程等待一定时间，如果线程还没有达到barrier状态，就让到达barrier状态的线程执行后续任务。示例如下：12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849static void testCyclicBarrier() &#123;// CyclicBarrier barrier = new CyclicBarrier(5); CyclicBarrier barrier = new CyclicBarrier(5,new Runnable() &#123; @Override public void run() &#123; System.out.println("所有线程执行完毕，随机挑选一个线程来执行打印"); System.out.println("挑选的线程为" + Thread.currentThread().getName()); &#125; &#125;); for (int i = 0; i &lt; 5; i++) &#123; new Writer(barrier, "thread:" + i).start(); &#125;&#125;static class Writer extends Thread &#123; private CyclicBarrier cyclicBarrier; public Writer(CyclicBarrier cyclicBarrier, String threadName) &#123; this.cyclicBarrier = cyclicBarrier; if (threadName != null) &#123; this.setName(threadName); &#125; &#125; @Override public void run() &#123; try &#123; System.out.println("线程" + Thread.currentThread().getName() + "正在作业中"); Thread.sleep(5000); System.out.println("线程" + Thread.currentThread().getName() + "作业完成"); cyclicBarrier.await(); System.out.println("所有线程作业完毕，线程" + Thread.currentThread().getName() + "继续理其他任务"); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; catch (BrokenBarrierException e) &#123; e.printStackTrace(); &#125; &#125;&#125; 值得注意的是，CyclicBarrier是可以重用的。 Semaphore该类提供了两个构造器：123456public Semaphore(int permits) &#123; //参数permits表示许可数目，即同时可以允许多少线程进行访问 sync = new NonfairSync(permits);&#125;public Semaphore(int permits, boolean fair) &#123; //这个多了一个参数fair表示是否是公平的，即等待时间越久的越先获取许可 sync = (fair)? new FairSync(permits) : new NonfairSync(permits);&#125; 下面是该类中比较重要的几个方法，首先是acquire()、release()：1234public void acquire() throws InterruptedException &#123; &#125; //获取一个许可public void acquire(int permits) throws InterruptedException &#123; &#125; //获取permits个许可public void release() &#123; &#125; //释放一个许可public void release(int permits) &#123; &#125; //释放permits个许可 acquire()用来获取一个许可，若无许可能够获得，则会一直等待，直到获得许可。release()用来释放许可。注意，在释放许可之前，必须先获获得许可。这4个方法都会被阻塞，如果想立即得到执行结果，可以使用下面几个方法：1234public boolean tryAcquire() &#123; &#125;; //尝试获取一个许可，若获取成功，则立即返回true，若获取失败，则立即返回falsepublic boolean tryAcquire(long timeout, TimeUnit unit) throws InterruptedException &#123; &#125;; //尝试获取一个许可，若在指定的时间内获取成功，则立即返回true，否则则立即返回falsepublic boolean tryAcquire(int permits) &#123; &#125;; //尝试获取permits个许可，若获取成功，则立即返回true，若获取失败，则立即返回falsepublic boolean tryAcquire(int permits, long timeout, TimeUnit unit) throws InterruptedException &#123; &#125;; //尝试获取permits个许可，若在指定的时间内获取成功，则立即返回true，否则则立即返回false 另外还可以通过availablePermits()方法得到可用的许可数目。假如5个线程要使用3个资源，示例如下：12345678910111213141516171819202122232425262728293031static void testSemaphore() &#123; int N = 5; //线程数 Semaphore semaphore = new Semaphore(3); //资源数目 for(int i=0;i&lt;N;i++) new Worker("线程" +i,semaphore).start(); &#125; static class Worker extends Thread &#123; private Semaphore semaphore; public Worker(String name, Semaphore semaphore) &#123; super(); this.setName(name); this.semaphore = semaphore; &#125; @Override public void run() &#123; try &#123; semaphore.acquire(); System.out.println("线程：" + Thread.currentThread().getName() + "占用一个资源"); Thread.sleep(3000); System.out.println("线程：" + Thread.currentThread().getName() + "释放一个资源"); semaphore.release(); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; &#125; &#125; CountDownLatch和CyclicBarrier都能够实现线程之间的等待，只不过它们侧重点不同：CountDownLatch一般用于某个线程等待若干个其他线程执行完任务之后，它才执行；而CyclicBarrier一般用于一组线程互相等待至某个状态，然后这一组线程再同时执行；另外，CountDownLatch是不能够重用的，而CyclicBarrier是可以重用的。Semaphore其实和锁有点类似，它一般用于控制对某组资源的访问权限。 以上]]></content>
      <tags>
        <tag>java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Tinker初探]]></title>
    <url>%2F2018%2F03%2F10%2FTinker%E5%88%9D%E6%8E%A2%2F</url>
    <content type="text"><![CDATA[前两天想试一下热修复的功能，对比各大平台的热修复功能，看到tinker的文档介绍，最终决定先拿Tinker试一下。 Tinker QZone AndFix Robust 类替换 yes yes no no So替换 yes no no no 资源替换 yes yes no no 全平台支持 yes yes no yes 即时生效 no no yes yes 性能损耗 较小 较大 较小 较小 补丁包大小 较小 较大 一般 一般 开发透明 yes yes no no 复杂度 较低 较低 复杂 复杂 Rom体积 Dalvik较大 较小 较小 较小 成功率 较高 较高 一般 最高 Tinker热补丁方案不仅支持类、So 以及资源的替换，它还是2.X－7.X的全平台支持。利用Tinker我们不仅可以用做 bugfix,甚至可以替代功能的发布。Tinker 已运行在微信的数亿 Android 设备上，那么为什么你不使用 Tinker 呢？ 不得不说，我真的低估了跟着腾讯文档走的难度。 注册 TinkerPatch 平台因为需要下发补丁，直接使用TinkerPatch平台就好，在这里注册http://www.tinkerpatch.com/Index/reg,注册完成后创建一个应用，拿到appKey然后添加一个APP版本 SDK接入测试成功的工程全部文件在这里https://github.com/huangyuanlove/TestTinker,包含构建成功之后的apk文件以及一些辅助文件。 添加Gradle插件依赖AndroidStudio创建一个工程，定义使用的SDK版本，我是放在了gradle.properties 这个文件中， TINKER_VERSION=1.9.2TINKERPATCH_VERSION=1.2.2 然后在工程的build.gradle文件中添加插件依赖 classpath “com.tinkerpatch.sdk:tinkerpatch-gradle-plugin:${TINKERPATCH_VERSION}” 然后添加一些其他配置，整个文件内容如下1234567891011121314151617181920212223242526272829303132buildscript &#123; repositories &#123; google() jcenter() &#125; dependencies &#123; classpath 'com.android.tools.build:gradle:3.0.1' classpath "com.tinkerpatch.sdk:tinkerpatch-gradle-plugin:$&#123;TINKERPATCH_VERSION&#125;" &#125;&#125;if (JavaVersion.current().isJava8Compatible()) &#123; allprojects &#123; tasks.withType(Javadoc) &#123; options.addStringOption('Xdoclint:none', '-quiet') &#125; &#125;&#125;subprojects &#123; tasks.withType(JavaCompile) &#123; sourceCompatibility = JavaVersion.VERSION_1_7 targetCompatibility = JavaVersion.VERSION_1_7 &#125;&#125;allprojects &#123; repositories &#123; google() jcenter() &#125;&#125;task clean(type: Delete) &#123; delete rootProject.buildDir&#125; 集成 TinkerPatch SDK在app/build.gradle里面添加依赖 annotationProcessor(&quot;com.tinkerpatch.tinker:tinker-android-anno:${TINKER_VERSION}&quot;) { changing = true } compileOnly(&quot;com.tinkerpatch.tinker:tinker-android-anno:${TINKER_VERSION}&quot;) { changing = true } implementation(&quot;com.tinkerpatch.sdk:tinkerpatch-android-sdk:${TINKERPATCH_VERSION}&quot;) { changing = true } 为了配置方便，我们把TinkerPatchSupport相关的配置放在一个单独的gradle文件中，在app下创建一个tinkerpatch.gradle，我们需要在app/build.grale文件中引用 apply from: ‘tinkerpatch.gradle’ 配置 tinkerpatchSupport 参数编辑 app/tinkerpatch.gralde文件1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192939495apply plugin: 'tinkerpatch-support'/** * TODO: 请按自己的需求修改为适应自己工程的参数 */def bakPath = file("$&#123;buildDir&#125;/bakApk/")def baseInfo = "app-1.0.0-0309-21-30-56" //构建差异文件时使用def variantName = "debug"/** * 对于插件各参数的详细解析请参考 * http://tinkerpatch.com/Docs/SDK */tinkerpatchSupport &#123; /** 可以在debug的时候关闭 tinkerPatch **/ /** 当disable tinker的时候需要添加multiDexKeepProguard和proguardFiles, 这些配置文件本身由tinkerPatch的插件自动添加，当你disable后需要手动添加 你可以copy本示例中的proguardRules.pro和tinkerMultidexKeep.pro, 需要你手动修改'tinker.sample.android.app'本示例的包名为你自己的包名, com.xxx前缀的包名不用修改 **/ tinkerEnable = true reflectApplication = false /** * 是否开启加固模式，只能在APK将要进行加固时使用，否则会patch失败。 * 如果只在某个渠道使用了加固，可使用多flavors配置 **/ protectedApp = false /** * 实验功能 * 补丁是否支持新增 Activity (新增Activity的exported属性必须为false) **/ supportComponent = true autoBackupApkPath = "$&#123;bakPath&#125;" appKey = "2b662623551153ee" /** 注意: 若发布新的全量包, appVersion一定要更新 **/ appVersion = "1.0.0" def pathPrefix = "$&#123;bakPath&#125;/$&#123;baseInfo&#125;/$&#123;variantName&#125;/" def name = "$&#123;project.name&#125;-$&#123;variantName&#125;" baseApkFile = "$&#123;pathPrefix&#125;/$&#123;name&#125;.apk" baseProguardMappingFile = "$&#123;pathPrefix&#125;/$&#123;name&#125;-mapping.txt" baseResourceRFile = "$&#123;pathPrefix&#125;/$&#123;name&#125;-R.txt" /** * 若有编译多flavors需求, 可以参照： https://github.com/TinkerPatch/tinkerpatch-flavors-sample * 注意: 除非你不同的flavor代码是不一样的,不然建议采用zip comment或者文件方式生成渠道信息（相关工具：walle 或者 packer-ng） **/&#125;/** * 用于用户在代码中判断tinkerPatch是否被使能 */android &#123; defaultConfig &#123; buildConfigField "boolean", "TINKER_ENABLE", "$&#123;tinkerpatchSupport.tinkerEnable&#125;" &#125;&#125;/** * 一般来说,我们无需对下面的参数做任何的修改 * 对于各参数的详细介绍请参考: * https://github.com/Tencent/tinker/wiki/Tinker-%E6%8E%A5%E5%85%A5%E6%8C%87%E5%8D%97 */tinkerPatch &#123; ignoreWarning = false useSign = true dex &#123; dexMode = "jar" pattern = ["classes*.dex"] loader = [] &#125; lib &#123; pattern = ["lib/*/*.so"] &#125; res &#123; pattern = ["res/*", "r/*", "assets/*", "resources.arsc", "AndroidManifest.xml"] ignoreChange = [] largeModSize = 100 &#125; packageConfig &#123; &#125; sevenZip &#123; zipArtifact = "com.tencent.mm:SevenZip:1.1.10" &#125; buildConfig &#123; keepDexApply = false &#125;&#125; 每个参数的含义如下 参数 默认值 描述 tinkerEnable true 是否开启 tinkerpatchSupport 插件功能 appKey “” 在 TinkerPatch 平台 申请的 appkey appVersion “” 在 TinkerPatch 平台 输入的版本号,注意，我们使用 appVersion 作为 TinkerId, 我们需要保证每个发布出去的基础安装包的 appVersion 都不一样。 reflectApplication false 是否反射 Application 实现一键接入；一般来说，接入 Tinker 我们需要改造我们 的 Application, 若这里为 true， 即我们无需对应用做任何改造即可接入。 autoBackupApkPath “” 将每次编译产生的 apk/mapping.txt/R.txt 归档存储的位置 baseApkFile “” 基准包的文件路径, 对应 tinker 插件中的 oldApk 参数;编译补丁包时，必需指定基准版本的 apk，默认值为空，则表示不是进行补丁包的编译。 baseProguardMappingFile “” 基准包的 Proguard mapping.txt 文件路径, 对应 tinker 插件 applyMapping 参数；在编译新的 apk 时候，我们希望通过保持基准 apk 的 proguard 混淆方式，从而减少补丁包的大小。这是强烈推荐的，编译补丁包时，我们推荐输入基准 apk 生成的 mapping.txt 文件。 baseResourceRFile “” 基准包的资源 R.txt 文件路径, 对应 tinker 插件 applyResourceMapping 参数；在编译新的apk时候，我们希望通基准 apk 的 R.txt 文件来保持 Resource Id 的分配，这样不仅可以减少补丁包的大小，同时也避免由于 Resource Id 改变导致 remote view 异常。 protectedApp false 是否开启支持加固，注意：只有在使用加固时才能开启此开关 supportComponent false 是否开启支持在补丁包中动态增加Activity 注意：新增Activity的Exported属性必须为false backupFileNameFormat ‘\${appName}-\${variantName}’ 格式化命名备份文件 这里请使用单引号 初始化 TinkerPatch SDK这里推荐使用改造之后的ApplicationLike，对应tinkerpatch.gradle文件中的reflectApplication = false,这里给出了完整的ApplicationLike类，可以在这里查看https://github.com/huangyuanlove/TestTinker/blob/master/app/src/main/java/com/huangyuan/testtinker/SampleApplicationLike.java其中对于类的注解中的 application 的值，就是我们应用的Application类，需要在AndroidManifest.xml中的application标签中配置123@DefaultLifeCycle(application = "com.huangyuanlove.testtinker.SampleApplication", flags = ShareConstants.TINKER_ENABLE_ALL, loadVerifyFlag = false)` 注意：初始化的代码建议紧跟 super.onCreate(),并且所有进程都需要初始化，已达到所有进程都可以被 patch 的目的如果你确定只想在主进程中初始化 tinkerPatch，那也请至少在 :patch 进程中初始化，否则会有造成 :patch 进程crash，无法使补丁生效我们在实际应用过程中，可以在登陆等关键地方去调用TinkerPatch.with().fetchPatchUpdate(true)来检测有没有新的补丁包，若有，则去下载。下载完成补丁包后，sdk会自动去合成新的安装包，并且在息屏的时候自动重启主线程去加载新的文件，或者调用ShareTinkerInternals.killAllOtherProcess(getApplicationContext()); android.os.Process.killProcess(android.os.Process.myPid());来完成杀死主线程的目的。 使用步骤首先构建基础包，模拟用户当前使用的版本。在gradle中找到下图所示的 assembleRelease或者assembleDebugtask，需要注意的是，如果构建基础包使用的是debug,那么在构建patch包的时候也要选择debug，还有就是尽量把app/tinkerpatch.gradle中定义的variantName改成一致的。基础包构建成功后，会在app/build/bakApk文件夹下生成对应的文件，找到和你构建时间一致的包。现在修改代码或者布局文件(模拟修复bug),修改清单文件AndroidManifest.xml中的versionName和versionCode。修改app/tinkerpatch.gradle文件，将其中定义的baseInfo修改为上面提到的路径。这时候不需要修改该文件中的appVersion。在gradle中找到tinker任务包，找到tinkerPatchDebug或者tinkerPatchRelease，构建差异包(补丁文件)。构建成功后会在app/build/outputs/apk/tinkerPatch文件夹中 现在我们已经成功构建的差异包patch-signed-7zip.apk,现在只需要将差异包上传到tinker-patch平台就可以了。 在tinker-patch平台发布差异包我们登陆tinker-patch平台，找到在刚开始创建的项目，在该项目里面添加一个App版本，注意这里的App版本号要和tinkerpatch.gradle里面定义的appVersion一致，在官方文档中也提到过这一点： 每一个 APP 版本对应一个已经发布的 base apk, 这里我们可以使用 APP 版本作为 TinkerID。我们需要保证每个发布的 APK 都采用不用的 APP 版本。 创建好app版本之后，点击发布新补丁，选择补丁文件patch-signed-7zip.apk,填写一下备注就好了，这里有四种补丁的下发方式开发预览 、全量下发 、条件下发 、灰度下发、具体差异可以点击去查看。同时我们也可以在平台对应的软件版本中的实时监控里面看到补丁的下载以及合成应用次数。 以上]]></content>
      <tags>
        <tag>Android</tag>
        <tag>热修复</tag>
        <tag>tinker</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LaTeX笔记-六(数学公式)]]></title>
    <url>%2F2018%2F02%2F27%2FLaTeX%E7%AC%94%E8%AE%B0-%E5%85%AD%2F</url>
    <content type="text"><![CDATA[TeX有两种数学公式，一种是夹杂在行文段落中的公式，如$\int f(x) \text{d}x=1$,一般称为行内(inline)数学公式，或正文(in-text)数学公式;另一种就是像下面这样单独占据郑航居中展示出来，称为显示数学公式$$\sum_{i=0}^N \int_a^bg(t,i)\text{d}$$ 在TeX中，行内公式一般在前后单个美元符号\$…\$表示，显示公式用连续的两个美元符号\$\$…\$\$表示 基础在数学模式下，符号会使用单独的字体，字母通常是倾斜的意大利体，数字和符号则是自立体，仔细看的话，数学符号之间的距离也与一般的水平模式不同：$a + b = b + a$,如$ 1 + 2 = 2 + 1$正常模式a + b = b + a，如 1 + 2 = 2 + 1因此，在排版数学公式时，即使是没有任何特殊符号的算式$1+1$也要进入数学模式，使用\$1+1\$而不是普通文字的1+1c除了使用单个美元符号，在LaTeX中还额外定义了命令格式与环境格式的方式输入行内公式，即使用命令\(和\)环境括起来一个行内数学公式，如$a+b$也可以写成\(a+b\)或是\begin{math}a+b\end{math}。这两种形式提供了更好的错误检查，并且可以更明确地看出公式的开始于结束，也不容易混淆。同样的，LaTeX中也定义了命令形式和环境形式的输入方法，即使用\[和\]命令或是displaymath环境括起一个显示数学公式，例如：\[a+b=b+a\],虽然并非必须，但最好在源代码中就把单独占据一行的显示公式放在单独的行内，使代码更清晰，推荐使用的方式是\[...\]，$$...$$会产生不良的间距，缺少错误检查，并且不能正确处理fleqn等文档选项，应该避免使用，而displaymath环境可能显得冗长。LaTeX还提供了带自动编号的数学公式，可以用equation环境表示，公式后还可以带引用的标签，例如：123\begin&#123;equation&#125; a+b=b+a \label&#123;eq:commutative&#125;\end&#123;equation&#125; 上标与下标上标和下标是两种最常见的数学结构，它们的形式也很朴素：上标一般在原符号的右上方，下标一般在原符号的右下方，有时也在正上方和正下方，例如： $$\sum_{i=1}^{n}\max_a10^na_i\int_Da^2_i$$ 在TeX中，上标用特殊字符^表示，下标用特殊字符_表示。在数学模式中，符号^和_的用法差不多相当于带一个参数的命令，如\$10^n\$可以得到 $10^n$ ,而\$a_i\$可以得到 $a_i$ 当上标和下标多余一个字符时，需要使用分组确定上下标范围，如\$A_{ij}=2^{i+j}\$得到$A_{ij}=2^{i+j}$上标和下标可以同时使用，也可以嵌套使用。同时使用上标和下标，上下标的先后次序并不重要，二者互不影响，嵌套使用上下标时，则外层一定要使用分组。数学公式中空格是不起实际作用的，适当的空格可以将代码分隔得好看一些。数学公式中单引号是一种特殊的上标，表示用符号\prime(即’)做上标，可以与下标混用，也可以连续使用，但不能与上标直接混用，如：12$a=a'$,$b_0'=b_0''$,$&#123;c'&#125;^2=(c')^2$ 得到$a=a’$,$b_0’=b_0’’$,${c’}^2=(c’)^2$ 上下画线与花括号\overline 和 \underline命令可用来在公式的上方和下方划横线，overbrace 和 underbrace命令可以在公式上方和下方带上花括号如： 代码 结果 $\overleftarrow{a+b}$ $\overleftarrow{a+b}$ $\overrightarrow{a+b}$ $\overrightarrow{a+b}$ $\overleftrightarrow{a+b}$ $\overleftrightarrow{a+b}$ $\underleftarrow{a-b}$ $\underleftarrow{a-b}$ $\underrightarrow{a-b}$ $\underrightarrow{a-b}$ $\underleftrightarrow{a-b}$ $\underleftrightarrow{a-b}$ $\vec x = \overrightarrow{AB}$ $\vec x = \overrightarrow{AB}$ $\overbrace{a+b+c} = \underbrace{1+2+3}$ $\overbrace{a+b+c} = \underbrace{1+2+3}$ 还可以使用上下标在花括号上做标注1$$ (\overbrace&#123;a_0,a_1,...,a_n&#125;^&#123;\text&#123;共 $n+1$ 项&#125;&#125;) = (\underbrace&#123;0,0,...,0&#125;_n,1) $$ $$ (\overbrace{a_0,a_1,…,a_n}^{\text{共 $n+1$ 项}}) = (\underbrace{0,0,…,0}_n,1) $$ 分式在LaTeX中分式用\frace&lt;分子&gt;&lt;分母&gt;得到，如：$$ \frac 12 + \frac 1a = \frac{2+a}{2a} $$ $ \frac 12 + \frac 1a = \frac{2+a}{2a} $在行内公式和显示公式中，分式的大小是不同的。行内分式中分子分母都用较小的字号排版，以免超出文本行的高度。连分式是一种特殊的分式，amsmath提供的\cfrac专用于输入连分式。这个命令可以带一个可选的参数l、c、r，表示左、中、右，默认是居中，如：$$ \cfrac{1}{1+\cfrac{2}{1+\cfrac{3}{1+x}}} = \cfrac[r]{1}{1+\cfrac{2}{1+\cfrac[l]{3}{1+x}}} $$得到 ,markdown对这个支持不是很好，结果用图片代替了。还有一些类似分数分成上下两半,如二项式系数$\binom nk$，amsmath提供了\binom来输入二项式系数，其用法与\frac类似:1`$$ (a+b)^2 = \binom &#123;20&#125;&#123;02&#125; a^2 + \binom 21 ab + \binom 22 b^2 $$` $$ (a+b)^2 = \binom {20}{02} a^2 + \binom 21 ab + \binom 22 b^2 $$ 根式根式在LaTeX用单参数的命令\sqrt得到，同时可以带一个可选参数，表示开方得次数，如：$\sqrt 4 = \sqrt[3]{8} = 2$ 得到 $\sqrt 4 = \sqrt[3]{8} = 2$嵌套使用根式或与其他数学结构结合也很常见：1$$ \sqrt[n]&#123;\frac&#123;x^2 + \sqrt 2&#125;&#123;x+y&#125;&#125;$$ $$ \sqrt[n]{\frac{x^2 + \sqrt 2}{x+y}}$$如果开方得次数不是简单的整数，或者被开方得内容过长，通常改用等价的指数形式：1$$ (x^p+y^q)^&#123;\frac&#123;1&#125;&#123;1/p+1/q&#125;&#125;$$ $$ (x^p+y^q)^{\frac{1}{1/p+1/q}}$$有时可能对开方次数的排版位置不满意，可以用amsmath提供的\uproot和\leftroot命令调整，命令参数是整数，移动的单位是很小的一段距离，如：1$$ \sqrt[\uproot&#123;16&#125;\leftroot&#123;-2&#125;n] &#123;\frac&#123;x^2 + \sqrt 2&#125;&#123;x+y&#125;&#125; $$ 矩阵在基本的LaTeX中，矩阵是用PlainTeX一样的命令\matrix和\pmatrix,各类矩阵环境的区别在于外面的括号不同： 环境 代码 结果 matrix $$\begin{matrix} 1&amp;0&amp;0\\ 0&amp;1&amp;0\\ 0&amp;0&amp;1\\ \end{matrix}$$ $$\begin{matrix} 1&amp;0&amp;0\ 0&amp;1&amp;0\ 0&amp;0&amp;1\ \end{matrix}$$ bmatrix $$\begin{bmatrix} 1&amp;0&amp;0\\ 0&amp;1&amp;0\\ 0&amp;0&amp;1\\ \end{bmatrix}$$ $$\begin{bmatrix} 1&amp;0&amp;0\ 0&amp;1&amp;0\ 0&amp;0&amp;1\ \end{bmatrix}$$ vmatrix $$\begin{vmatrix} 1&amp;0&amp;0\\ 0&amp;1&amp;0\\ 0&amp;0&amp;1\\ \end{vmatrix}$$ $$\begin{vmatrix} 1&amp;0&amp;0\ 0&amp;1&amp;0\ 0&amp;0&amp;1\ \end{vmatrix}$$ pmatrix $$\begin{pmatrix} 1&amp;0&amp;0\\ 0&amp;1&amp;0\\ 0&amp;0&amp;1\\ \end{pmatrix}$$ $$\begin{pmatrix} 1&amp;0&amp;0\ 0&amp;1&amp;0\ 0&amp;0&amp;1\ \end{pmatrix}$$ Bmatrix $$\begin{Bmatrix} 1&amp;0&amp;0\\ 0&amp;1&amp;0\\ 0&amp;0&amp;1\\ \end{Bmatrix}$$ $$\begin{Bmatrix} 1&amp;0&amp;0\ 0&amp;1&amp;0\ 0&amp;0&amp;1\ \end{Bmatrix}$$ Vmatrix $$\begin{Vmatrix} 1&amp;0&amp;0\\ 0&amp;1&amp;0\\ 0&amp;0&amp;1\\ \end{Vmatrix}$$ $$\begin{Vmatrix} 1&amp;0&amp;0\ 0&amp;1&amp;0\ 0&amp;0&amp;1\ \end{Vmatrix}$$ 在矩阵环境中，不同的列用符号&amp;分隔，行用\\分隔，矩阵中每列元素居中对齐，例如： 12345$$\begin&#123;pmatrix&#125; a_&#123;11&#125; &amp; a_&#123;12&#125; &amp; a_&#123;13&#125; \\ 0 &amp; a_&#123;22&#125; &amp; a_&#123;23&#125; \\ 0 &amp; 0 &amp; a_&#123;33&#125; \\ \end&#123;pmatrix&#125;$$ 在矩阵中经常使用各种省略号即\dots、\vdots、\ddots、\iddots,amsmath还提供了可以跨多列的省略号\hdotsfor{&lt;列数&gt;}，在行公式中，有时需要使用很小的矩阵，这可以由amsmath提供的smallmatrix环境得到. 以上]]></content>
      <tags>
        <tag>LaTeX</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LaTeX笔记-五(自动化工具)]]></title>
    <url>%2F2018%2F02%2F27%2FLaTeX%E7%AC%94%E8%AE%B0-%E4%BA%94%2F</url>
    <content type="text"><![CDATA[记录一下某些自动化的工具，比如添加超链接(hyperref)、索引(makeindex)等 电子文档与超链接hyperref宏包可算是LaTeX最为复杂的宏包之一，它提供了大量的选项和命令，完成各种设置和功能，这里主要记录以PDF格式输出时，hyperref有关标签和超链接的一些最基本的功能和设置。hyperref最基本的用法非常简单，就是直接调用此宏包：1\usepackage&#123;hyperef&#125; 如果使用ctex宏包或文档类，则可以加hyperef选项，这样啊ctex宏包会自动根据编码和编译方式选择合适的选项，避免出现乱码：1\documentclass[hyperref,UTF8]&#123;ctexart&#125; 引入hyperref后再编译文档时，会根据章节结构，自动生成目录结构的PDF文档标签。同时，正文中的目录和所有交叉引用，都会自动成为超链接，可以用鼠标点击跳转到引用位置。要得到正确的PDF标签，也应至少表一两遍文档。除了直接加在\usepackage，也可以使用\hypersetup命令单独设置。hyperref的选项大多使用&lt;选项&gt;=&lt;值&gt;的方式设置，如果是布尔类型的真假值选项(true或false),通常可以省略为真的值，常见选项如下： 选项 类型 默认值 说明 colorlinks 布尔 false 超链接用彩色显示 bookmarks 布尔 true 生成PDF目录书签 bookmarksopen 布尔 false 在PDF阅读器中自动打开书签 bookmarksnumbered 布尔 false 目录书签带编号 pdfborder 数 数 数 0 0 1 当colorlink为假时，超链接由彩色边框包围(不会被打印)。默认值表示1pt宽的边框，可以设置为0 0 0 表示没有边框。 pdfpagemode 文本 在PDF阅读器中的页面显示方式，常用值是FullScreen，表示全屏显示 pdfstartview 文本 Fit 在PDF阅读器中的页面缩放大小，默认值Fit表示“适合页面”；常用取值有适合宽度FitH，适合高度FitV pdftitle 文本 文档标题，会在PDF文档属性中显示 pdfauthor 文本 文档作者，会在PDF文档属性中显示 pdfsubject 文本 文档主题，会在PDF文档属性中显示 pdfkeywords 文本 文档关键字，会在PDF文档属性中显示 除此之外，可以用\url命令输出URL地址，同时也具有超链接的功能。与排版纯文本不同，找\url命令的参数中，网址允许使用合法符号直接输入，并且默认以打字机字体输出，如果URL地址不需要超链接的效果，可以改用\nolinkurl命令。\href{&lt;URL&gt;}{文字}命令可以用来使文字产生指向URL地址的超链接效果。\hyperref[&lt;标签&gt;]{&lt;文字&gt;}命令可以用来产生使文字执行标签的超链接效果，这里方括号中的标签与\ref使用的标签相同，不能省略。\hypertarget{&lt;名称&gt;}{&lt;文字&gt;}用来给文字定义带有名称的链接点，在文档的其他地方，则可以使用命令\hyperlink{&lt;名称&gt;}{&lt;文字&gt;}让另一段文字链接到指定名称的连接点。 制作索引在LaTeX中制作索引，需要.tex源文件和外部索引程序的共同协作。在.tex源文件中，我们需要做一下几件事： 在导言区使用\makeindex命令，开启索引文件输出 在导言区调用makeidx宏包，开启索引列表排版功能 在正文中需要索引的关键字处使用\index命令，生成索引项 在需要生成索引的地方(通常是文档的末尾)，使用\printindex命令，实际输出处理好的索引列表 例子如下：123456789101112\documentclass[hyperref,UTF8]&#123;ctexart&#125;\usepackage&#123;makeidx&#125;\makeindex% ...西方称勾股定理为毕达哥拉斯定理，\index&#123;毕达哥拉斯定理&#125;将勾股定理的发现归功于公元前 6 %...勾股定理可以用现代语言表述如下\index&#123;勾股定理&#125;：%...\printindex\end&#123;document&#125; 与参考文献类似，要生成索引需要多次编译和外部工具Makeindex的配合，编译带索引的文档需要使用如下命令：123pdflatex ***makeindex ***pdflatex *** 以上命令可以在IDE的编译选项中找到在\index的参数中可以使用符号!来分隔不同层次的索引项，这样将得到分级的索引项。默认支持三级列表，例如：1234\index&#123;language&#125;\index&#123;language!Chinese&#125;\index&#123;language!Chinese!dialect&#125;\index&#123;language!English&#125; 在\index的参数后面使用符号|则可以使用几个特殊的功能，基本的用法是使用|see{&lt;条目&gt;}与|seealse{条目}表示参考条目。例如：123\index&#123;beta&#125;\index&#123;Beta|see&#123;beta&#125;&#125;\index&#123;gamma|seealso&#123;beta&#125;&#125; 以上]]></content>
      <tags>
        <tag>LaTeX</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LaTeX笔记(四)--文档结构层次]]></title>
    <url>%2F2018%2F02%2F11%2FLaTeX%E7%AC%94%E8%AE%B0-%E5%9B%9B%2F</url>
    <content type="text"><![CDATA[下面是介绍文档的层次结构 标题和标题页在LaTeX中，使用标题通常分为两个部分：声明标题内容和实际输出标题。每个标题则由标题、作者、日期等部分组成。声明标题、作者和日期分别使用\title，\author，\date命令。它们都带有一个参数，里面可以使用\\进行换行。标题的声明通常放在导言区，也可以放在标题输出之前的任何位置：1234\documentclass[UTF8,titlepage]&#123;ctexart&#125;\title &#123;语言\thanks&#123;本文由XX基金会赞助&#125;&#125;\author&#123;huangyuan\thanks&#123;sdut&#125;\\sdut \and xuan\thanks&#123;sdut&#125;\\sdut&#125;\date&#123;戊戌初春&#125; \author定义的参数可以分行，一般第一行是作者姓名，后面是作者的单位、联系方式等，如果文档有多个作者，则多个作者之间用\and分隔。在声明标题和作者时，可以使用\thanks命令产生一种特殊的脚注，它默认使用特殊符号和编号，通常用来表示文章的致谢、文档的版本、作者的详细信息等。使用\maketitle命令可以输出前面声明的标题，通常\maketitle是文档中document环境后面的第一个命令。整个标题的格式是预设好的，在article或ctexart中，标题不单独成页，可以使用文档类的选项titlepage和notitlepage来设置标题是否单独成页。 划分章节LaTeX的标准文档类可以划分多层章节，可以使用6到7个层次的章节。 层次 名称 命令 说明 -1 part(部分) \part 可选的最高层 0 chapter(章) \chapter report,book或ctexrep,ctexbook文档类的最高层 1 section(节) \section article或ctexart类的最高层 2 subsection(小节) \subsection 3 subsubsection(小小节) \subsubsection report,book或ctexrep,ctexbook文档类默认不编号，不编目录 4 paragraph(段) \paragraph 默认不编号，不编目录 5 subparagraph(小段) \subparagraph 默认不编号，不编目录 一个文档的最高层章节可以是\part，也可以不用\part直接使用\chapter(对book和report等)或\section(对article)。除\part外，只有在上一层章节存在时才能使用下一章节，否则编号会出现错误。在\part下面，\chapter或\section是连续编号的；在其他情况下，下一级的章节随上一节的编号增加会清零重新编号。可以使用带星号的章节命令(如\chapter*)来表示不编号、不编目录的章节。 多文件编译对于一篇只有几页的文章，把所有的内容都放进一个tex源文件就足够了，但是如果要排版更长的内容，单一文件编译的方式就不那么方便可，可以按照文档的逻辑层次，把整个文档分成多个tex源文件，这样文档的内容更便于检索和管理，也适合大型文档的多人协同编写。LaTeX提供\include{&lt;文件名&gt;}命令可以用来导入两一个文件的内容作为一个章节，文件名不用带.tex扩展名，\include命令会在之前和之后使用\clearpage或\cleardoublepage另起新页，同时将这个文件的内容贴到\include命令所在的文字。所以我们可以这样来组织一篇较长的文章：12345678910\documentclass[UTF8,titlepage]&#123;ctexart&#125;\title &#123;语言&#125;\author&#123;huangyuan\thanks&#123;sdut&#125;\\SDUT \and xuan\thanks&#123;sdut&#125;\\SDUT&#125;\date&#123;戊戌初春&#125;\begin&#123;document&#125;\maketitle\tableofcontents\include&#123;lang-natural&#125;\include&#123;lang-computer&#125;\end&#123;document&#125; 123%lang-natural.tex 不能单独编译\chapter&#123;自然语言&#125;这是自然语言章节 123% lang-computer.tex 不能单独编译\chapter&#123;计算机语言&#125;这是计算机语言章节 划分文档后，可以通过主文件来控制编译整个文档的一章或者某几章。当然可以把不要的章节注释掉，更好的办法是通过\includeonly{&lt;文件列表&gt;}命令，其中&lt;文件列表&gt;是用英文都好隔开的若干文件名。在导言区使用\includeonly命令以后，只有在文件列表中的文件才会被实际的引入主文件。更好的是，如果以前曾经完整的编译过整个文档，那么在使用\includeonly选择编译时，原来的章节编号、页码、交叉引用等仍然会保留为前一次编译的效果：1234567891011\documentclass[UTF8,titlepage]&#123;ctexart&#125;\title &#123;语言&#125;\author&#123;huangyuan\thanks&#123;sdut&#125;\\SDUT \and xuan\thanks&#123;sdut&#125;\\SDUT&#125;\includeonly&#123;lang-natural&#125;\date&#123;戊戌初春&#125;\begin&#123;document&#125;\maketitle\tableofcontents\include&#123;lang-natural&#125;\include&#123;lang-computer&#125;\end&#123;document&#125; 值得注意的是，在使用\include命令时，最好不要在子文件中新定义计数器、声明新字体，否则在使用\includeonly时，会因为找不到出现在辅助文件中而在源文件中缺失的计数器而出错。比\include命令更一般的是\input命令，它直接把文件的内容复制到\input命令所在的文字，不做其他多余的操作。\input命令接受一个文件名参数，文件名可以带扩展名，也可以不带扩展名(此时认为扩展名是.tex)。一般可以把导言区、复杂图标代码放在一个单独文件中，然后在主文件中使用\input插入。在被引入的文件末尾，可以使用\endinput命令显式的结束文件的读入，在\endinput命令的后面，就可以直接写一些注释性的文字，而不必再加入注释符号。 以上]]></content>
      <tags>
        <tag>LaTeX</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LaTeX笔记(三)(杂)]]></title>
    <url>%2F2018%2F02%2F11%2FLaTeX%E7%AC%94%E8%AE%B0-%E4%B8%89%2F</url>
    <content type="text"><![CDATA[前两篇笔记记录下了写一篇小文章所需要的东西，这一片就记录下一些零零散散的东西，计算机专业的嘛，只关心中文和英文，像什么德语、法语之类的东西就不在考虑范围内了，用的时候再去查也是可以的。 标点 在LaTeX中遇到单引号与双引号连续出现的情形，在中间使用\,命令分开：12``\,`A' or `B'\,'' he asked.``It's Knuth's book。'', he said。 这里\,命令产生很小的间距，但是LaTex并不会忽略以符号命名的宏前后的空格，所以在它的前后都不要加多余的空格。符号&#39;同时也是表示所有格和省字的撇好。 除了在数学模式中表示减号，符号-在LaTeX正文中也有多种用途：单独使用它是连字符(hyphen);两个连用--是en dash,用来表示数字范围;三个连用---是 em dash，即破折号。不过在中文书写中，表示数学范围也常使用符号~(数学模式的符号$\sim$)。 西文的省略号(ellipsis)使用\ldots或\dots命令产生，相比直接输入三个句号，拉开的间距要合理的多。水平间距在正文中可以使用下面的命令表示不可换行的水平间距不可换行的水平间距 命令 间距 \thinspace 或\, 0.1667em \negthinspace 或\! -0.1667em \enspace 0.5em \nobreakspace 或~ 空格 可换行的水平间距 命令 间距 \quad 1em \qquad 或\! 2em \enskip 0.5em \空格 空格 当上面的命令中没有合适的距离时，可以用\hspace{距离}命令来产生指定的水平间距(这里的\,用来分隔数字和单位)1Space\hspace&#123;1cm&#125;1\,cm \hspace命令产生的距离是可断行的，但是在某些情况下(强制断行的行首)，改命令产生的距离会被忽略，此时可以用带星号的命令\hspace*{距离}阻止距离被忽略。 盒子盒子(box)是TeX中的基本处理单位。最简单的命令是\mbox{内容},它产生一个格子，内容以左右模式排列，可以用它表示不允许断行的内容。\makebox与\mbox类似，但可以带两个可选参数，指定盒子的宽度和对齐方式：\makebox[&lt;宽度&gt;][&lt;位置&gt;]{&lt;内容&gt;}对齐参数可以取c(居中)、l、r、s(分散),默认居中。\fbox 和 \framebox产生带边框的盒子，语法和\mbox、\makebox类似 列表环境列表是常用的文本格式，LaTeX标准文档类提供了三种列表环境：带编号的enumerate环境、不编号的itemize环境和使用关键字的description环境。在列表内部使用\item命令开始一个列表项，它可以带一个可选参数表示手动编号或关键字123456789\begin&#123;enumerate&#125;\item 中文\item English\end&#123;enumerate&#125;\begin&#123;itemize&#125;\item 中文\item English\end&#123;itemize&#125; description环境总是使用\item命令的可选参数，把它作为条目的关键字加粗。1234\begin&#123;description&#125;\item[中文] 中文\item[英文] English\end&#123;description&#125; 上面三种列表环境可以嵌套使用(最多四层) 抄录和代码环境\verb命令可用来表示杭温中的抄录，语法格式如下：\verb&lt;符号&gt;&lt;抄录内容&gt;&lt;符号&gt;在\verb后，两个符号相同，表示起始符号和末尾符号，两个符号之间的内容会原样输出。使用带星号的命令\verb*则可以使输出的空格为可见的。大段的抄录可以使用verbatim环境：12345\begin&#123;verbatim&#125;#! user/bin /env perl$name = ''guy'';print ''Hello,$name!\n''\end&#123;verbatim&#125; 同样可以使用带星号的verbatim*环境输出可见空格。如果想在程序代码中增加语法高亮功能，可以使用listings宏包1234567\begin&#123;lstlisting&#125;[language=java]class Test&#123; public static void main(String ... args)&#123; System.out.println(''Hello Java''); &#125;&#125;\end&#123;lstlisting&#125; 以上]]></content>
      <tags>
        <tag>LaTeX</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LaTeX笔记(二)(开篇)]]></title>
    <url>%2F2018%2F01%2F27%2FLaTeX%E7%AC%94%E8%AE%B0-%E4%BA%8C%2F</url>
    <content type="text"><![CDATA[接上篇，写好的tex文件在这 https://github.com/huangyuanlove/latex_practice/blob/master/latex(1)/chapter_one.tex 写个框架既然有目标了，我们先写个大概的框架，然后往里面填充内容1234567891011121314151617181920% coding:UTF-8\documentclass[UTF8]&#123;ctexart&#125;\title&#123;杂谈勾股定理&#125;\author&#123;xuan&#125;\date&#123;\today&#125;\bibliographystyle&#123;plain&#125;\begin&#123;document&#125;\maketitle\tableofcontents\section&#123;勾股定理在古代&#125;\section&#123;勾股定理的近代形式&#125;\bibliography&#123;math&#125;\end&#123;document&#125; 以 %开头的行是注释，源文件一行中百分号后面的内容都会被忽略。 第4行是文档类，因为是中文的短文，所以用的是ctexart，并用[UTF8]选项说明编码方式。 第6-8行声明了文章的标题、作者、日期。其中的\today是当前日期。但是这些信息是通过14行的\maketitle排版的。 第10行的\bibliographystyle声明参考文献的格式。以上在\begin{document}之前的部分称为导言区(preamble)，导言区通常用来对文档的性质做一些设置，或自定义一些命令。 第12-20行以\begin{document}和\end{socument}声明了一个document环境，里面是论文的正文部分，也就是直接输出的部分。 第14行的\maketitle输出论文标题。 第15行的\tableofcontents输出目录。 第16-17行两个\section开始新的一节。 第18行的\bibliography{math}则是从文献数据库math(这里的math文献数据库是我们自己编辑的一个文件)中获取文献信息，打印参考文献列表。 为了格式清晰，源文件使用了一些空行作为分隔，在正文外的部分，空行不代表任何意义 填写正文自己把大段的文字先写上再说，自己试试查看排版之后格式。 使用空行分段， 段落的第一行缩进不需要自己打空格命令与环境脚注脚注是在正文欧几里得的后面用脚注命令\footnote得到的。12该定理的严格表述和证明则见于欧几里得\footnote&#123;欧几里得，约公元前330--275年。&#125; 在这里，\footnote后面花括号内的部分是命令的参数，也就是脚注的内容。注意一个细节，在表示起止年份时，用两个减号(–)，通常用来表示数字的范围。文中还使用\emph命令改变字体的形状，表示强调的内容：1的整数称为\emph&#123;勾股数&#125; 一个LaTeX命令(宏)的格式为：无参数：\command有n个参数:\command&lt;arg1&gt;&lt;arg2&gt;&lt;arg3&gt;有可选参数:\command&lt;arg——opt&gt;&lt;arg2&gt;&lt;arg3&gt;命令都一反斜线\开头，后接命令名，可以带一些参数，必选参数使用花括号括起来，可选参数使用方括号括起来。引用的内容这是在正文中使用quote环境得到的。1234我国《周髀算经》载商高（约公元前12世纪）答周公问：\begin&#123;quote&#125;勾广三，股修四，经隅五。\end&#123;quote&#125; quote环境即以\begin{quote}和\end{quote}为起止位置的部分，突出引用部分。但是quote环境不能改变引用内容的字体，因此还需要再使用改变字体的命令123\begin&#123;quote&#125;\kaishu\zihao&#123;-5&#125; 引用的内容\end&#123;quote&#125; 这里\zihao是一个有参数的命令，选择字号(-5就是小五号)，而\kaishu则是没有参数的命令，把字体切换为楷书，注意用空格把命令和后面的文字分开。文章的摘要也是在\maketitle之后用abstract环境生成的：123\begin&#123;abstract&#125;刚开始学\LaTeX,如果学习不是为了装逼，那一切将毫无意义。\end&#123;abstract&#125; 当然我们也可以自定义环境，比如上面的突出引用的环境：在导言区\maketitle之后1\newenvironment&#123;myquote&#125;&#123;\begin&#123;quote&#125;\kaishu\zihao&#123;-5&#125;&#125;&#123;\end&#123;quote&#125;&#125; 之后我们在突出引用的时候就可以这么写：1234我国《周髀算经》载商高（约公元前12世纪）答周公问：\begin&#123;myquote&#125;勾广三，股修四，经隅五。\end&#123;myquote&#125; 文章第二节的定理，是用一类定理环境输出的，定理环境是一类环境，在使用前需要先在导言区做定义：1\newtheorem&#123;thm&#125;&#123;定理&#125; 这就定义了一个thm环境，定理环境可以有一个可选参数，就是定理的名字，所以文章中的勾股定义就可以由新定义的thm环境得到：123\begin&#123;thm&#125;[勾股定理]直角三角形斜边的平方等于两腰的平方和。\end&#123;thm&#125; 数学公式最简单的方式就是把公式用$符号括起来，比如$a+b$就可以得到斜体的a+b，这种夹在行文中的公式称为”正文公式(in-text formula)”或”行内公式(inline formula)”。为了方便引用，经常会给公式编号，这种公式被称为”显式公式”或”列表公式(display formula)”,使用equation环境就可以方便地输入这种公式。123\begin&#123;equation&#125;a(a+b) = ab + ac\end&#123;equation&#125; 键盘上没有的符号，就需要使用命令来输入，”角”符号”∠”,就可以用\angle输入(虽然有的输入法也提供了数学符号的选项，但是不建议这么做，可以自己试试有什么区别)。 数学公式还有上线标、分式、根式等，在勾股定理的表达中，就用到了上标表示乘方：123\begin&#123;equation&#125;AB^2 = BC^2 + AC^2\end&#123;equation&#125; 符号^用来引入一个上标，_医用一个下标，如果上下标识多个字符，则需要使用花括号分组：2^{10}。 所以90°怎么输入，在latex默认的字体中，并没有专用于表示角度的符号，输入角度的时候是通过上标输入的:^\circ，其中\circ通常用来表示函数符号的二元运算符○，我们把它的上标借用来表示角度。 插入图片 使用图片有两种途径：一个是插入事先准备好的图片，二是使用latex代码直接在文档中画图。 插图功能不是由latex内核直接提供，而是有graphicx宏包提供的，要使用graphicx宏包的插图功能呢个，需要在导言区使用\usepackage命令引入宏包： 12\documentclass&#123;ctexart&#125;\usepackage&#123;graphicx&#125; 引入graphicx宏包后，就可以使用\includegraphics命令插图了： 1\includegraphic[width=3cm]&#123;gougu.png&#125; 这里\includegraphic有两个参数，方括号中可选参数width=3cm设置图形在文档中显示的宽度为3cm，第二个参数则是图片的文件名(和源文件同级)，还有一些类似的参数如scale(缩放)、height等。除了一些很小的图标，我们很少进行图文混排，而是使用单独的环境列出，而且很大的图形如果位置是固定，会给分页造成困难，因此，通常都把图像放在一个可以变动相对位置的环境中，称为浮动体。在浮动体中还可以给图片加入说明性标题。123456\begin&#123;figure&#125;[ht] \centering \includegraphics[width=3cm]&#123;gougu.png&#125; \caption &#123;\kaishu\zihao&#123;-5&#125; 宋赵爽在《周髀算经》注中做的弦图（仿制），该图给出了勾股定理的一个极具对称美德证明。&#125; \label&#123;fig:gougu&#125;\end&#123;figure&#125; 在上面的代码中，第1行和第6行使用了figure环境，就是插图使用的浮动体环境，figure环境有可选参数[ht]，表示浮动体可以出现在环境周围的文本所在处和一页的顶部。figure环境内部相当于普通的段落(默认没有缩进)；第二行用生命\centering表示后面的内容居中；第3行插入图片；第4行使用\caption命令给插图加上自动编号和标题；第5行的\lable命令则给图形定义一个标签，这个标签就可以在文章的其他地方引用\caption产生的编号。 使用表格制作表格，需要确定是表格的行、列、对齐模式和表格线，这是由tabular环境完成的：123456789101112\begin&#123;table&#125;[h]\begin&#123;tabular&#125;&#123;|lcr|&#125;\hline直角边 $a$ &amp; 直角边 $b$ &amp; 斜边 $c$\\\hline3 &amp; 4 &amp; 5\\5 &amp; 12&amp; 13\\\hline\end&#123;tabular&#125;%\qquad($a^2 + b^2 = c^2$)\end&#123;table&#125; 表格和插图一样，一般也放在浮动环境中，即table环境中，参数大致和figure差不多；tabular环境有一个参数，里面声明了表格中列的模式，在上面的表格中|lcr|表示第一列的内容左对齐，第二类居中对齐，第三列居中对齐，在第一列前面和第三列后面各有一条垂直的表格线。在tabular环境中，行与行之间用命令\\隔开，每一行内的表项使用符号$隔开，表格中的横线是用命令\hline生成。这里并没有给表格加标题，也没有把内容居中，而是把表格个一个公式并排排开，中间使用一个\qquad分割，这个命令产生长为2em(大约两个’M’的宽度)的空白。因为已经使用\qquad生成足够长度的空格了，所以再用\end{tabular}后的注释符取消换行产生的一个多余空格。又因为表格是和正文连在一起的，不允许再浮动了，所以在table环境中的表示位置参数处使用了[H]，但是这个参数是由float宏包提供的，所以还要在导言区使用\usepackage{float}。 文献引用上面提到了引用文献，是在math.bib这个文件中指定的，下面是math.bib文件的内容123456789101112131415161718192021222324% Encoding: UTF-8@Book&#123;Shiye, title = &#123;几何的有名定理&#125;, year = &#123;1986&#125;, author = &#123;矢野健太郎&#125;,&#125;@Book&#123;Kline, title = &#123;古今数学思想&#125;, year = &#123;2002&#125;, author = &#123;克莱因&#125;,&#125;@Book&#123;quanjing, title = &#123;商高、赵爽与刘徽关于勾股定理的证明&#125;, year = &#123;1998&#125;, author = &#123;曲安京&#125;, volume = &#123;20&#125;, number = &#123;3&#125;, journal = &#123;数学传播&#125;,&#125;@Comment&#123;jabref-meta: databaseType:bibtex;&#125; 一个文献数据文件的格式并不复杂，每一个条目包括类型、引用标签、标题、年限、作者等信息，可以手工输入，也可以通过jabref制作。在实际应用中，BIBTEX数据并不需要我们自己录入，可以从相关的学科网站直接现在或是从其他类型的文献数据库转换得到。BIBTEX是一个专门用于处理LATEX文档文献列表的程序，使用BIBTEX处理文献时，编译源文件需要增加为四次运行程序(在TexWorks中点击四次按钮)pdflatex ***.texbibtex ***.auxpdflatex ***.texpdflatex ***.tex第一次运行为BIBTEX准备好辅助文件，确定数据库中的哪些文献将被列出来，然后bibtex处理辅助文件aux，从文献数据库中选取文件，按指定的格式生成文献列表的latex代码，后面两次再读入文献列表代码并生成正确的引用信息。latex只选择被引用的文献，引用文献的方法是在正文中使用\cite命令，如：12将勾股定理的发现归功于公元前 6 世纪的毕达哥拉斯学派\cite&#123;Kline&#125;。该学派得到了一个法则......是我国古代对勾股定理的一种证明\cite&#123;quanjing&#125;。 \cite命令的参数Kline和quanjing分别是其中两篇的引用标签，也就是在math.bib中每个条目第一行出现的星系，使用\cite命令会在引用的文字显示文献在列表中的标号(它在第3次pdflatex编译后才能确定)，同时在辅助文件中说明某文献将被引用。如果要在列表中显示并不直接引用的文献，可以使用\nocite命令，一般是把它放在\bibliography之前：12\nocite&#123;Shiye&#125;\bibliography&#123;math&#125; 目录也是自动从章节命令中提取并写入目录文件中的，在文章中我们就使用了\tableofcontents命令，它将在第二次编译时生效。引用并不仅限于参考文献，图表、公式的编号，只要事先设定了标签，同样可以引用。基本的交叉引用命令是\ref，它以标签问参数，得到被引用标号。比如在这篇文章中，在插入图片时是引用\label命令为弦图定义了标签\label{fig:gougu}，这样在正文中就可以使用1图\ref&#123;fig:gougu&#125;是我国古代对勾股定理的一种证明\cite&#123;quanjing&#125;。 公式编号的引用也可照此做法，不过需要先在公式中定义标签：123\begin&#123;equation&#125; \label&#123;eq:gougu&#125;AB^2 = BC^2 + AC^2\end&#123;equation&#125; 引用数学公式的时候一般使用数学宏包amsmath就定义了\eqref命令，专门用于公式的引用，并能产生括号：导言区引入包1\usepackage&#123;amsmath&#125; 正文中引用公式：1满足式\eqref&#123;eq:gougu&#125;的整数称为\emph&#123;勾股数&#125;。 以上。]]></content>
      <tags>
        <tag>LaTeX</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LaTeX笔记(一)(准备工作)]]></title>
    <url>%2F2018%2F01%2F18%2FLaTeX%E7%AC%94%E8%AE%B0-%E4%B8%80%2F</url>
    <content type="text"><![CDATA[如果学习不是为了装逼，那一切都将毫无意义。没错，我又想学LaTeX了，作为世界上最好的排版系统(没有之一)，我也只是在写简历的时候用过(装上编译器，改模板而已)，没有怎么了解过。最近妹子有提到过说些毕业论文的时候可能要用，这就需要系统的学习一下了。 准备阶段本着实用至上的原则，LaTeX的历史以及光辉事迹就不在提了，想看的自己去搜 TexLive2017套装：下载地址http://mirrors.tuna.tsinghua.edu.cn/CTAN/systems/texlive/Images/texlive2017-20170524.iso 这个是清华镜像站点。http://mirror.ctan.org/systems/texlive/Images/texlive2017.iso 这个是官方的镜像下载地址。不推荐使用CTex TexWorks：Tex文件编辑器，你也可以使用其他编辑器+插件：比如 VisualStudioCode，Sublime，Notepad++等。 JabRef：下载地址 https://www.fosshub.com/JabRef.html 大部分用在写论文的引用文献上，只有使用LaTeX撰写科技论文的研究人员才能完全领略到JabRef的妙不可言。 学习资料：LaTeX实在太庞大了，加上各种package，网上各种博客资料不是很全面，只照顾到一部分，推荐刘海洋的LaTeX入门。 建议：多练习，就像学编程一样，把书上的例子都自己敲一遍。 安装软件将TexLive2017套装加载到光驱， Windows 用户双击 install-tl-advanced.bat； *nix 用户执行 install-tl。然后按照提示来安装就好了，最后将texlive\2017\bin\win32加入环境变量，*nix用户自己找执行文件所在的路径加到环境变量里面。其他的东西可以参考这个网站 http://www.latexstudio.net/archives/10208 Hello World老规矩，先跑个Hello World。 打开TexWork,在编辑区输入以下代码：123456789\documentclass&#123;article&#125;\begin&#123;document&#125;Hello World!\LaTeX\end&#123;document&#125; 然后保存一下文件，注意一定要使用UTF-8编码(默认)，Tex文件的后缀名为.tex，编译过程会多出好多临时文件。 在下图红框处(界面左上角)选择pafLaTeX,然后点击绿色按钮进行编译，编译过程中绿色按钮会变成红叉，编译成功后又变成绿色按钮。你会在弹出的窗口看到”Hello World LaTeX”，并且在tex文件同级的文件夹下看到生成的pdf文件。如果没有编译成功，可以尝试选择不同的编译类型，也可以搜索控制台报错信息来解决。 如果你觉得编辑窗口的字体看着不舒服，可以在编辑–&gt;首选项–&gt;编辑器或者格式–&gt;字体里面调整。 多说一句，TexWorks支持代码补全 说明\documentclass[UTF-8]{article} 声明文档类型是一篇文章。\begin{document} 和 \end{document} 标识出正文的范围\LaTeX 看结果就知道是表示结果中高低不平的LaTeX但是，当你把内容替换为汉字的时候，发现汉字并不能在pdf文件中展示，这是因为LaTeX原本是面向西文写作的，默认没有加载中文字体。我们可以通过替换文档类型来显示中文，将 \documentclass{article} 替换为 \documentclass[UTF-8]{ctexart} 就可以显示中文了。 下一个目标如下图，接下来我们来慢慢写出来图片所示的样式。 以上。]]></content>
      <tags>
        <tag>LaTeX</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Android布局文件中的xmlns:tools]]></title>
    <url>%2F2018%2F01%2F04%2FAndroid%E5%B8%83%E5%B1%80%E6%96%87%E4%BB%B6%E4%B8%AD%E7%9A%84xmlns-tools%2F</url>
    <content type="text"><![CDATA[在使用AndroidStudio创建布局文件的时候，跟布局下总是有如下代码：123&lt;RootTag xmlns:android="http://schemas.android.com/apk/res/android" xmlns:tools="http://schemas.android.com/tools" tools:context="***.***Activity" &gt; 于是在官网查了一下这俩货是干嘛用的，下面是自己的翻译+实践xmlns的全称是xmlnamespace,和c++中namespace差不多，都是为了解决命名上的冲突问题。在Android布局文件中，常见的xmlns大概有三个（你可以随意命名，把tools改成bug也可以，只要对应使用tools的地方都改成bug，说白了，它只是个变量而已）。123xmlns:android="http://schemas.android.com/apk/res/android"xmlns:tools="http://schemas.android.com/tools"xmlns:app="http://schemas.android.com/apk/res-auto" android用于Android系统定义的一些属性 app用于我们自定义的一些属性 tools给IDE或者预览界面用的，当打包编译时并不会包含在apk中。 tools可以干什么先看官网介绍 https://developer.android.com/studio/write/tool-attributes.html Android Studio supports a variety of XML attributes in the tools namespace that enable design-time features (such as which layout to show in a fragment) or compile-time behaviors (such as which shrinking mode to apply to your XML resources). When you build your app, the build tools remove these attributes so there is no effect on your APK size or runtime behavior. 大致意思就是说使用tools后面的属性不会再编译时存在，只存在于设计时的预览，不会影响apk的体积， Error handling attributes影响Lint提示的属性主要有下面三种： tools:ignoreIntended for: Any elementUsed by: Lint tools:targetApiIntended for: Any elementUsed by: Lint tools:localeIntended for: resourcesUsed by: Lint, Android Studio editor ignore属性是告诉Lint忽略xml中的某些警告，比如我们在ImageView或者ImageButton中没有写contentDescription属性，Lint会有警告：Missing contentDescription attribute on image,原因是这个属性是提供无障碍阅读的，没有这个属性的话Screen Reader无法正常工作，但是有些特定分类的软件是不考虑这些东西的。虽然这种警告无所谓，但是对于要求代码中不能有warning的公司来说，这是不可取的，我们可以用ignore属性来忽略这个警告(如果你说你改了Lint的警告级别，当我没说)：12345678&lt;ImageViewandroid:layout_width="wrap_content"android:layout_height="wrap_content"android:layout_marginStart="@dimen/margin_main"android:layout_marginTop="@dimen/margin_main"android:scaleType="center"android:src="@drawable/divider"tools:ignore="contentDescription" /&gt; targetApi和代码中的注解@RequiresApi(api = Build.VERSION_CODES.JELLY_BEAN_MR2)差不多。假设配置文件中的最小sdkLevel为11，而布局文件中使用了21的控件比如GridLayout,Lint会有警告，为了消除这个警告，可以这么写：123&lt;GridLayout xmlns:android="http://schemas.android.com/apk/res/android" xmlns:tools="http://schemas.android.com/tools" tools:targetApi="14" &gt; locale是告诉Lint和AndroidStudio editor默认的是什么语言，如果不指定的话，默认是英语。可以把这个属性添加到values/strings.xml中：12&lt;resources xmlns:tools="http://schemas.android.com/tools" tools:locale="es"/&gt; Design-time view attributes(设计时试图属性)tools: instead of androidIntended for: ViewUsed by: Android Studio layout editor 我们有一个TextView，需要显示从网络获取到的文件，控件大小是wrap_content,但是TextView中没有文字的话在预览界面中是看不到的，大部分同学可能会使用android:text=XXXX这个属性，调整好布局之后再把文字删除。一两个控件还好说，控件多了指不定哪个控件就忘记删除文本了，我们可以使用tools这个东西：12345678&lt;TextView android:id="@+id/unlock_bike" android:layout_width="wrap_content" android:layout_height="wrap_content" android:background="#12345678" android:paddingBottom="10dp" android:paddingTop="10dp" tools:text="测试用例" /&gt; 这时我们在IDE预览界面是可以看到文字的，打包成apk运行在手机上时是看不到的。总之，tools可以告诉Android Studio哪些属性在运行的时候是被忽略的，只在设计布局的时候有效。基本上原生控件的属性都可以这么使用。 tools:contextIntended for: Any root ViewUsed by: Lint, Android Studio layout editor这个属性告诉IDE当前布局和哪个activity相关联，在预览界面使用关联Activity的主题展示。1234&lt;android.support.constraint.ConstraintLayout xmlns:android="http://schemas.android.com/apk/res/android" xmlns:tools="http://schemas.android.com/tools" tools:context=".MainActivity" &gt; tools:itemCountIntended for: RecyclerViewUsed by: Android Studio layout editor这个属性告诉编辑器在预览窗口展示多少个列表项12345&lt;android.support.v7.widget.RecyclerView android:id="@+id/recyclerView" android:layout_width="match_parent" android:layout_height="match_parent" tools:itemCount="3"/&gt; tools:layoutIntended for: fragmentUsed by: Android Studio layout editor这个属性告诉编辑器fragment中显示哪个布局文件12&lt;fragment android:name="com.example.master.ItemListFragment" tools:layout="@layout/list_content" /&gt; tools:listitem / tools:listheader / tools:listfooterIntended for: AdapterView (and subclasses like ListView)Used by: Android Studio layout editor看属性名字就能猜出来了，预览界面显示列表的头部，底部和列表项布局12345678&lt;ListView xmlns:android="http://schemas.android.com/apk/res/android" xmlns:tools="http://schemas.android.com/tools" android:id="@android:id/list" android:layout_width="match_parent" android:layout_height="match_parent" tools:listitem="@layout/sample_list_item" tools:listheader="@layout/sample_list_header" tools:listfooter="@layout/sample_list_footer" /&gt; tools:showInIntended for: Any root View in a layout that’s referred to by an includeUsed by: Android Studio layout editor此属性可以通过指向使用此布局包含的布局，因此您可以预览(和编辑)这个文件，因为它嵌入在其父布局时出现123456&lt;TextView xmlns:android="http://schemas.android.com/apk/res/android" xmlns:tools="http://schemas.android.com/tools" android:text="@string/hello_world" android:layout_width="wrap_content" android:layout_height="wrap_content" tools:showIn="@layout/activity_main" /&gt; tools:menuIntended for: Any root ViewUsed by: Android Studio layout editor此属性指定菜单应该显示在应用程序栏的布局预览。该值可以是一个或多个菜单id，由逗号分隔123456&lt;LinearLayout xmlns:android="http://schemas.android.com/apk/res/android" xmlns:tools="http://schemas.android.com/tools" android:orientation="vertical" android:layout_width="match_parent" android:layout_height="match_parent" tools:menu="menu1,menu2" /&gt; tools:minValue / tools:maxValueIntended for: NumberPickerUsed by: Android Studio layout editor设置NumberPicker的最大值和最小值1234567&lt;NumberPicker xmlns:android="http://schemas.android.com/apk/res/android" xmlns:tools="http://schemas.android.com/tools" android:id="@+id/numberPicker" android:layout_width="match_parent" android:layout_height="wrap_content" tools:minValue="0" tools:maxValue="10" /&gt; tools:openDrawerIntended for: DrawerLayoutUsed by: Android Studio layout editor设置DrawerLayout在预览窗口的打开位置 Constant Value Description end 800005 Push object to the end of its container, not changing its size. left 3 Push object to the left of its container, not changing its size. right 5 Push object to the right of its container, not changing its size. start 800003 Push object to the beginning of its container, not changing its size. 1234567&lt;android.support.v4.widget.DrawerLayout xmlns:android="http://schemas.android.com/apk/res/android" xmlns:tools="http://schemas.android.com/tools" android:id="@+id/drawer_layout" android:layout_width="match_parent" android:layout_height="match_parent" tools:openDrawer="start" /&gt; 下面的不想翻译了，链接在下面https://developer.android.com/studio/write/tool-attributes.html#resource_shrinking_attributes自己撸吧 以上]]></content>
      <tags>
        <tag>Android</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[写在2018元旦之前:2017的总结]]></title>
    <url>%2F2017%2F12%2F30%2F%E5%86%99%E5%9C%A82018%E5%85%83%E6%97%A6%E4%B9%8B%E5%89%8D-2017%E7%9A%84%E6%80%BB%E7%BB%93%2F</url>
    <content type="text"><![CDATA[2017年已经过去了，现在已经是2018年1月1号了，写写这一年的收获总结和2018的计划吧。一个字总结了一下2018年：穷。我也不知道钱花到哪里去了【无奈、摊手】。当然这是开玩笑式的总结，但也是最接近事实的了。刚刚翻了翻2016年年末写了总结个2017的计划，我先捂会脸。 先看看完成了哪些吧： python达到初级水平:这个勉勉强强算是达到了吧。 J2EE学习ssm和nginx:这个就很惭愧了，一直没看，不是没时间，就是平时大概了解了一下，根本就没有系统的学习过。 Java和Android：这个一直没停下过，毕竟是饭碗，在别人看来差不多已经是高级工程师了，可我觉得我刚刚到中级水平吧(标准不一样嘛)。 Linux：这个也没怎么深入，能在linux平台下做开发、了解常见配置，除了问题能找到解决方案就好。公司开发坏境是windows,就算我想用linux，这个也不大好，只能平时自己玩玩。 想想自己2017年都学到了啥，其实我也不知道自己又学到了啥，有些东西都是基础性、底层的东西，表面上看起来没什么提高，实际上现在我也没觉得有啥用户，或许是因为自己还没有到那个层次吧。 表面上学到的东西如下： 记录了一下在使用高德地图踩的坑(写到博客上了)。 大致看了一下tcp协议，就当是复习了，当时学ccna的时候也没怎么在意。 大致看了一遍《Android开发艺术探索》，可惜IPC还是没学会。 大致看了一下python编程，了解了一下flask和Django。 又大致看了一遍《深入理解JVM虚拟机》，感觉不出来有什么提高，只是聊天吹水的时候又多了点东西。 大致看了一下C++，没深入学习，坚持不下去了。 动手搭建了一下elk，并没有什么卵用，毕竟公司有专门的运维。 动手搭建了一下Jenkins，并没有什么卵用，毕竟公司有专门的运维。 动手搭建了一下git服务，并没有什么卵用，毕竟公司有专门的运维。 写了两个IDEA的插件，写完之后才发现有人写过了，而且还是已经发布了的。 用不同的方式方法、框架、语言把《煎蛋》写了好几遍。 大致学习了一下kotlin。 其他的就是读了几本书、认识了几个朋友。 遗憾的事 和妹子异地，没有多陪陪妹子。 没有锻炼，身体素质差的不要不要的，手无缚鸡之力。 自己一直念念不忘的热修复没有动手实践过。 自己一直念念不忘的微信小程序也没有去试试。 自己一直念念不忘的日语也放弃了。 脾气似乎暴躁了许多，竟然喜欢《死亡笔记》中所描述的世界。 我可能是公司里在技术上最能作(zuo,一声)的人了，没有之一： 一开始做运营端app，嫌写findViewById麻烦，说服同事用ButterKnife注解。 后来需要做内部服务端app，觉得用ButterKnife也挺麻烦的，还得写变量(给变量去名字太蛋疼了，界面复杂的话一个界面好几十个控件变量)，上databinding吧，花一周时间把原来的注解全部干掉，换成databinding 后来想改网络框架来着，但是一直没时间，开发需求一版接一版，VersionCode一年内已经到40了，只能作罢。 现在一直想上热修复来着，但是还没弄，后端还没弄好，机制还不完善，不过我觉得迟早得上，毕竟有啥技术改动都是内部服务端app先上、先用、趟雷(毕竟内部人员使用，好说话),然后运营端app再上. 2018计划 有时间多陪陪妹子。 坚持锻炼。 至少读3本书，要有总结和读后感的那种。 有时间的话，至少参与一次开源翻译计划(Apche-CN)\ 人工智能和机器学习挺火的，妹子研究生也是这个方向，学学这一块的东西，至少不要拖妹子后腿吧。 Java和Android方向继续努力，撸源码，多学习。 坚持写博客，不能偷懒了。 修身养性，别这么大脾气了，一点就爆(抱个被子，泡点枸杞挺不错的)。 以上]]></content>
      <tags>
        <tag>乱七八糟</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Android中使用WebSocket-2]]></title>
    <url>%2F2017%2F12%2F26%2FAndroid%E4%B8%AD%E4%BD%BF%E7%94%A8WebSocket-2%2F</url>
    <content type="text"><![CDATA[上一篇提到在Android中使用WebSocket和服务端进行通信。是直接在Activity里面进行操作的这样会保持一个长连接，一个应用里面没必要也不应该保持多个长连接，所以我们可以把WebSocket客户端挪到Service里面，使用广播和Activity进行通信。 APP端：继承BroadcastReceiver，重写public void onReceive(Context context, Intent intent)方法，在该方法中进行业务处理。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566public class MainActivity extends AppCompatActivity implements View.OnClickListener &#123; private TextView showMessage; private EditText editText; private StringBuilder sb = new StringBuilder(); private WebSocketBroadcastReceiver webSocketBroadcastReceiver; @Override protected void onCreate(Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); setContentView(R.layout.activity_main); Intent intent = new Intent(this, WebSocketService.class); startService(intent); showMessage = findViewById(R.id.show_message); editText = findViewById(R.id.edit_text); findViewById(R.id.send).setOnClickListener(this); webSocketBroadcastReceiver = new WebSocketBroadcastReceiver(); IntentFilter intentFilter = new IntentFilter("web_socket"); registerReceiver(webSocketBroadcastReceiver, intentFilter); &#125; @Override public void onClick(View v) &#123; switch (v.getId()) &#123; case R.id.send: sb.append("客户端发送消息："); sb.append(new Date().toLocaleString()); sb.append("\n"); sb.append(editText.getText().toString().trim()); sb.append("\n"); showMessage.setText(sb.toString()); Intent intent = new Intent(this, WebSocketService.class); intent.putExtra("message", editText.getText().toString().trim()); startService(intent); editText.setText(""); break; default: break; &#125; &#125; class WebSocketBroadcastReceiver extends BroadcastReceiver &#123; @Override public void onReceive(Context context, Intent intent) &#123; String message = intent.getStringExtra("message"); sb.append("服务端返回消息："); sb.append(new Date().toLocaleString()); sb.append("\n"); sb.append(message); sb.append("\n"); showMessage.setText(sb.toString()); &#125;&#125; @Override protected void onDestroy() &#123; Intent intent = new Intent(this, WebSocketService.class); stopService(intent); unregisterReceiver(webSocketBroadcastReceiver); super.onDestroy(); &#125;&#125; Service继承Service,在onCreate()方法里面创建WebSocketClient并和服务端进行连接。在AndroidManifest.xml中注册服务。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667public class WebSocketService extends Service &#123; private IoTWebSocketClient ioTWebSocketClient; private Intent broadcastIntent; @Override public IBinder onBind(Intent intent) &#123; return null; &#125; @Override public void onCreate() &#123; super.onCreate(); broadcastIntent = new Intent(); broadcastIntent.setAction("web_socket"); ioTWebSocketClient = new IoTWebSocketClient(URI.create("ws://192.168.1.64:8887")); ioTWebSocketClient.connect(); &#125; @Override public int onStartCommand(Intent intent, int flags, int startId) &#123; String message = intent.getStringExtra("message"); if(ioTWebSocketClient.isClosing() || ioTWebSocketClient.isClosed())&#123; stopSelf(); return super.onStartCommand(intent, flags, startId); &#125; try &#123; ioTWebSocketClient.send(message); &#125;catch (Exception e)&#123; e.printStackTrace(); &#125; return super.onStartCommand(intent, flags, startId); &#125; @Override public void onDestroy() &#123; ioTWebSocketClient.close(); ioTWebSocketClient = null; super.onDestroy(); &#125; class IoTWebSocketClient extends WebSocketClient &#123; IoTWebSocketClient(URI serverUri) &#123; super(serverUri); &#125; @Override public void onOpen(ServerHandshake handshakedata) &#123; &#125; @Override public void onMessage(String message) &#123; broadcastIntent.putExtra("message", message); WebSocketService.this.sendBroadcast(broadcastIntent); &#125; @Override public void onClose(int code, String reason, boolean remote) &#123; &#125; @Override public void onError(Exception ex) &#123; stopSelf(); &#125; &#125;&#125; 在onStartCommand()方法里面，对发送消息方法的调用进行异常捕获，是因为这时候可能服务端重启或者服务端还没有准备好，这是发送消息会抛出异常，可以根据自己的业务需求进行改进。 以上]]></content>
      <tags>
        <tag>Android</tag>
        <tag>WebSocket</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Android中使用WebSocket]]></title>
    <url>%2F2017%2F12%2F25%2FAndroid%E4%B8%AD%E4%BD%BF%E7%94%A8WebSocket%2F</url>
    <content type="text"><![CDATA[背景：后端逻辑框架调整，将原来的推送和轮询方式改成了使用WebSocket通信。原来的请求方式是由app发起请求，appServer对请求进行分发，中转中继服务器将具体请求下发到对应的物联网服务器，物联网服务器将指令下发到指定的设备。整个流程涉及到很多层http请求，并且每个服务的回调接口还不一致，只能在app发情请求之后，接着去轮询服务器，服务器端去查询设备状态、是否对指令有响应。改版后涉及到对物联网的请求全部改成WebSocket,不在轮询，而是被动等待。后端使用的是Spring实现的WebSocket,app端使用的是https://github.com/TooTallNate/Java-WebSocket这个开源项目。 APP端实现 添加依赖compile &quot;org.java-websocket:Java-WebSocket:1.3.7&quot; 我们只需要关心三方库中WebSocketClient类就可以了，其他细节底层已经封装好了。 类中有四个方法需要重写： 12345678/**打开连接*/ public void onOpen(ServerHandshake handshakedata) /**服务端返回消息*/ public void onMessage(String message) /**关闭连接*/ public void onClose(int code, String reason, boolean remote) /**出现异常*/ public void onError(Exception ex) 一个简单的小测试，app端定义了一个发送按钮，和一个展示消息的文本 1234567891011121314151617181920212223242526272829303132333435363738394041&lt;?xml version="1.0" encoding="utf-8"?&gt;&lt;LinearLayout xmlns:android="http://schemas.android.com/apk/res/android" xmlns:tools="http://schemas.android.com/tools" android:layout_width="match_parent" android:layout_height="match_parent" android:orientation="vertical" tools:context="com.huangyuanlove.testwebsocket.MainActivity"&gt; &lt;ScrollView android:layout_width="match_parent" android:layout_height="0dp" android:layout_weight="1"&gt; &lt;TextView android:id="@+id/show_message" android:layout_width="wrap_content" android:layout_height="wrap_content" /&gt; &lt;/ScrollView&gt; &lt;LinearLayout android:layout_width="match_parent" android:layout_height="wrap_content" android:orientation="horizontal"&gt; &lt;EditText android:id="@+id/edit_text" android:layout_width="0dp" android:layout_height="wrap_content" android:layout_weight="1" /&gt; &lt;TextView android:id="@+id/send" android:layout_width="wrap_content" android:layout_height="wrap_content" android:background="@color/colorAccent" android:padding="10dp" android:text="发送" android:textColor="@android:color/black" /&gt; &lt;/LinearLayout&gt;&lt;/LinearLayout&gt; 在代码里面处理具体逻辑： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109import android.os.Bundle;import android.os.Handler;import android.os.Message;import android.support.design.widget.Snackbar;import android.support.v7.app.AppCompatActivity;import android.view.View;import android.widget.EditText;import android.widget.TextView;import org.java_websocket.client.WebSocketClient;import org.java_websocket.handshake.ServerHandshake;import java.net.URI;import java.util.Date;public class MainActivity extends AppCompatActivity implements View.OnClickListener &#123; private TextView showMessage; private EditText editText; private WebSocketClient webSocketClient; private StringBuilder sb = new StringBuilder(); private Handler handler = new Handler(new Handler.Callback() &#123; @Override public boolean handleMessage(Message msg) &#123; sb.append("服务器返回数据："); sb.append(msg.obj.toString()); sb.append("\n"); showMessage.setText(sb.toString()); return true; &#125; &#125;); @Override protected void onCreate(Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); setContentView(R.layout.activity_main); showMessage = findViewById(R.id.show_message); editText = findViewById(R.id.edit_text); findViewById(R.id.send).setOnClickListener(this); URI serverURI = URI.create("ws://192.168.1.199:8887"); webSocketClient = new WebSocketClient(serverURI) &#123; @Override public void onOpen(ServerHandshake handshakedata) &#123; sb.append("onOpen at time："); sb.append(new Date()); sb.append("服务器状态："); sb.append(handshakedata.getHttpStatusMessage()); sb.append("\n"); showMessage.setText(sb.toString()); &#125; @Override public void onMessage(String message) &#123; Message handlerMessage = Message.obtain(); handlerMessage.obj = message; handler.sendMessage(handlerMessage); &#125; @Override public void onClose(int code, String reason, boolean remote) &#123; sb.append("onClose at time："); sb.append(new Date()); sb.append("\n"); sb.append("onClose info:"); sb.append(code); sb.append(reason); sb.append(remote); sb.append("\n"); showMessage.setText(sb.toString()); &#125; @Override public void onError(Exception ex) &#123; sb.append("onError at time："); sb.append(new Date()); sb.append("\n"); sb.append(ex); sb.append("\n"); showMessage.setText(sb.toString()); &#125; &#125;; webSocketClient.connect(); &#125; @Override public void onClick(View v) &#123; switch (v.getId()) &#123; case R.id.send: if(webSocketClient.isClosed() || webSocketClient.isClosing())&#123; Snackbar.make(v,"Client正在关闭",Snackbar.LENGTH_SHORT).show(); webSocketClient.connect(); break; &#125; webSocketClient.send(editText.getText().toString().trim()); sb.append("客户端发送消息："); sb.append(new Date()); sb.append("\n"); sb.append(editText.getText().toString().trim()); sb.append("\n"); showMessage.setText(sb.toString()); editText.setText(""); break; default: break; &#125; &#125;&#125; 服务端实现上面提到我们后端使用的Spring中的WebSocket实现，其实用什么实现服务端无所谓，只要遵循协议就可以。个人在本地做测试的时候用的还是这个开源项目。 服务端只需要关心WebSocketServer这个类就好，这个类里面有五个方法需要重写： 12345678910/**服务开启*/public void onStart() /**有客户端连接*/public void onOpen(WebSocket webSocket, ClientHandshake clientHandshake)/**服务端关闭*/public void onClose(WebSocket webSocket, int i, String s, boolean b)/**收到客户端的消息*/public void onMessage(WebSocket webSocket, String s)/**出现异常*/ public void onError(WebSocket webSocket, Exception e) 具体代码如下： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576package com.huangyuanlove;import org.java_websocket.WebSocket;import org.java_websocket.WebSocketImpl;import org.java_websocket.handshake.ClientHandshake;import org.java_websocket.server.WebSocketServer;import java.io.BufferedReader;import java.io.InputStreamReader;import java.net.InetSocketAddress;import java.net.UnknownHostException;public class TestWebSocket extends WebSocketServer &#123; public TestWebSocket(int port) throws UnknownHostException &#123; super(new InetSocketAddress(port)); &#125; public TestWebSocket(InetSocketAddress address) &#123; super(address); &#125; public static void main(String[] args) &#123; WebSocketImpl.DEBUG = true; try &#123; int port = 8887; // 843 flash policy port TestWebSocket s = new TestWebSocket(port); s.start(); System.out.println("ChatServer started on port: " + s.getPort()); BufferedReader sysin = new BufferedReader(new InputStreamReader(System.in)); while (true) &#123; String in = sysin.readLine(); s.broadcast(in); if (in.equals("exit")) &#123; s.stop(1000); break; &#125; &#125; &#125; catch (Exception ex) &#123; ex.printStackTrace(); &#125; &#125; @Override public void onOpen(WebSocket webSocket, ClientHandshake clientHandshake) &#123; broadcast("new connection: " + clientHandshake.getResourceDescriptor()); System.out.println(webSocket.getRemoteSocketAddress().getAddress().getHostAddress() + " entered the room!"); &#125; @Override public void onClose(WebSocket webSocket, int i, String s, boolean b) &#123; broadcast(webSocket + " onClose"); System.out.println(webSocket + " onClose"); &#125; @Override public void onMessage(WebSocket webSocket, String s) &#123; broadcast(s); System.out.println(webSocket + ": " + s); &#125; @Override public void onError(WebSocket webSocket, Exception e) &#123; e.printStackTrace(); if (webSocket != null) &#123; // some errors like port binding failed may not be assignable to a specific websocket &#125; &#125; @Override public void onStart() &#123; System.out.println("Server started!"); &#125;&#125; 上面代码中onMessage方法中的broadcast方法是向所有连接到服务器的客户端发送消息(广播发送，其实就是一个小型的局域网聊天室)，如果只是谁发来的消息就回复给谁，可以调用webSocket.send()方法。是用的时候先开启服务端，然后开启客户端(app)，需要注意是的，在客户端中重写的方法都不是在主线程中，如果需要更新UI，请切换到UI线程。或者在客户端中使用Service,在Service中收到消息之后，广播给UI界面。 以上]]></content>
      <tags>
        <tag>Android</tag>
        <tag>WebSocket</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[《我的安卓爬坑之旅》-高德地图遇到的坑-3]]></title>
    <url>%2F2017%2F12%2F19%2F%E3%80%8A%E6%88%91%E7%9A%84%E5%AE%89%E5%8D%93%E7%88%AC%E5%9D%91%E4%B9%8B%E6%97%85%E3%80%8B-%E9%AB%98%E5%BE%B7%E5%9C%B0%E5%9B%BE%E9%81%87%E5%88%B0%E7%9A%84%E5%9D%91-3%2F</url>
    <content type="text"><![CDATA[这次是逆地理位置编码出现的坑，在提交工单后，官方回复是badcase，已经收录，后续着手优化。SDK版本号：com.amap.api:location:3.6.1、com.amap.api:map3d:4.1.3、com.amap.api:map3d-native:4.1.3、com.amap.api:search:5.5.0。过程如下：2017年12月5号接到用户反馈，定位位置准确，但是显示的中文具体位置不准确，误差大概在千米级别。当时就麻爪了，这可不是误差，这是错误。 首先排除网络以及信号问题：根据用户反馈，得知用户所在位置信号良好，周围不存在遮盖物，也不在地下室之类的信号差的地方，不存在定位偏差问题(app上显示的定位和手机位置一致)。网络状况良好，浏览器可以打开网页、app可以进行其他操作。先排除用户使用情况的原因是：接到过多次反馈，是因为用户没有看app提示，或者直接忽略掉提示导致的误报。 排除代码问题 在测试服上进行同样操作，得到的坐标值正确(手机拿到坐标值在app上显示，然后把坐标拿到高德坐标拾取系统进行定位，显示位置一致)，定位以及展示代码没问题。 拿到坐标值在客户端进行逆地理位置编码(RegeocodeQuery query = new RegeocodeQuery(new LatLonPoint(lat, lon), 200,GeocodeSearch.AMAP); geocoderSearch.getFromLocationAsyn(query);)，得到的地理位置正确，误差在所传参数以内，改变逆地理位置编码的经确定，改变定位位置(北京市内随机取点)，多次操作，定位及展示以及逆地理位置编码均正确。到这，就有点抓狂了，这TM什么问题，到底哪里出问题了。。 全国范围内取点，代码参数和生产环境保持一致，祈祷着或许是因为在新疆这种空旷、建筑物少的地方，误差可能会大些(好几公里没有建筑物，没有明显地标，总不能展示第几课白杨树下吧，23333)。抓到了偏远地区的坐标以及十分空旷地区的坐标，展示以及你地理位置编码均正确。 这时候也冷静下来了，出了问题不一定是自己代码问题吗，有可能是二方、三方代码的锅，只是习惯上养成了出了问题先找自己的原因，找不到再找其他的。找高德，提工单，详细描述问题： 具体情况这样：我把(119.564298,31.995402)这个坐标用客户端调用逆地理位置编码接口:RegeocodeQuery query = new RegeocodeQuery(new LatLonPoint(lat, lon), 200,GeocodeSearch.AMAP);geocoderSearch.getFromLocationAsyn(query);在回调函数public void onRegeocodeSearched(RegeocodeResult result, int rCode)中取得结果：result.getRegeocodeAddress().getFormatAddress() 是江苏省镇江市丹阳市云阳镇北环路6号。但实际上江苏省镇江市丹阳市云阳镇北环路6号这个地址与上述坐标点距离很远(这个是在高德坐标拾取器 http://lbs.amap.com/console/show/picker 上看到的)。 高德回复第二天高德给了回复： 您好，感谢反馈，目前这块的算法确实有一些问题，您的badcase我们已经收录，后续会针对这块做优化。给您造成不便敬请谅解。感谢您的致信，欢迎持续关注高德开放平台！ 以上]]></content>
      <tags>
        <tag>Android</tag>
        <tag>Android爬坑之旅</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[flask笔记一 快速入门]]></title>
    <url>%2F2017%2F07%2F15%2Fflask%E7%AC%94%E8%AE%B0%E4%B8%80(%E5%BF%AB%E9%80%9F%E5%85%A5%E9%97%A8)%2F</url>
    <content type="text"><![CDATA[学习python和flask中看过的资料和自己的实践总结Flask英文以下内容来自flask中文 环境安装Flask依赖两个外部库：Werkzeug和Jinja2。Werkzeug是一个WSGI工具集、Jinja2负责渲染模板。首先需要python2.6或者更高的版本，python3.X安装方式可能有所不一致。 virtualenvvirtualenv 为每个不同项目提供一份 Python 安装。它并没有真正安装多个 Python 副本，但是它确实提供了一种巧妙的方式来让各项目环境保持独立。sudo apt-get install python-virtualenvvirtualenv安装完成后，用IDE比如pycharm创建一个Flask的项目工程，并在其下创建一个venv文件夹12345$ mkdir myproject$ cd myproject$ virtualenv venvNew python executable in venv/bin/pythonInstalling distribute............done. 然后激活相应的环境$ . venv/bin/activate然后激活virtualenv中的Flask$ pip install Flask 项目配置在pycharm中，打开setting在Project Interpreter中选择当前工程文件下的virtualenv打开工程的Configuration在python interpreter中选择当前工程文件下的virtualenv 项目说明总述刚刚新建的工程看起来会是这样的123456789from flask import Flaskapp = Flask(__name__)@app.route('/')def hello_world(): return 'Hello World!'if __name__ == '__main__': app.run() 运行这段程序(文件名不要是 flask.py，这会和已有的文件冲突)，浏览器访问127.0.0.1:5000，然后就会看到熟悉的hello world.那么，这段代码做了什么？ 首先，我们导入了 Flask 类。这个类的实例将会是我们的 WSGI 应用程序。接下来，我们创建一个该类的实例，第一个参数是应用模块或者包的名称。 如果你使用单一的模块（如本例），你应该使用 name ，因为模块的名称将会因其作为单独应用启动还是作为模块导入而有不同（ 也即是 ‘main‘ 或实际的导入名）。这是必须的，这样 Flask 才知道到哪去找模板、静态文件等等。详情见 Flask 的文档。 然后，我们使用 route() 装饰器告诉 Flask 什么样的URL 能触发我们的函数。这个函数的名字也在生成 URL 时被特定的函数采用，这个函数返回我们想要显示在用户浏览器中的信息。 最后我们用 run() 函数来让应用运行在本地服务器上。 其中 if name == ‘main‘: 确保服务器只会在该脚本被 Python 解释器直接执行的时候才会运行，而不是作为模块导入的时候。欲关闭服务器，按 Ctrl+C。你会发现它只能从自己的计算机上访问，网络中其他任何地方都不能访问，我们可以修改run()方法使该服务公开可用app.run(host=&#39;0.0.0.0&#39;)这样会让操作系统监听所有的公网IP同样可以开启debug模式app.debug = True;app.run()或者app.run(debug=True) 路由如上面的代码所示，route()装饰其吧一个函数绑定到对应的URL上1234567@app.route('/')def index(): return 'Index Page'@app.route('/hello')def hello(): return 'Hello World' 不仅如此，还可以构造含有动态部分的URL，也可以在一个函数上附着多个规则 变量规则要给 URL 添加变量部分，你可以把这些特殊的字段标记为 ， 这个部分将会作为命名参数传递到你的函数。规则可以用 指定一个可选的转换器。如下所示 123456789@app.route('/user/&lt;username&gt;')def show_user_profile(username): # show the user profile for that user return 'User %s' % username@app.route('/post/&lt;int:post_id&gt;')def show_post(post_id): # show the post with the given id, the id is an integer return 'Post %d' % post_id HTTP方法HTTP有许多不同的访问URL方法。默认情况下，路由只回应GET请求，但是通过route()装饰器传递methods参数可以改变这个行为。 123456@app.route('/login', methods=['GET', 'POST'])def login(): if request.method == 'POST': do_the_login() else: show_the_login_form() 模板渲染像javaweb一样，不会直接用servlet直接输出html代码，Flask可以使用render_template()方法来渲染模板，Flask配备Jinja2模板引擎Jinja2中文，Jinja2英文123456from flask import render_template@app.route('/hello/')@app.route('/hello/&lt;name&gt;')def hello(name=None): return render_template('hello.html', name=name) Flask 会在 templates 文件夹里寻找模板。所以，如果你的应用是个模块，这个文件夹应该与模块同级；如果它是一个包，那么这个文件夹作为包的子目录:情况 1: 模块:123/application.py/templates /hello.html 情况 2: 包:1234/application /__init__.py /templates /hello.html 下面是hello.html文件内容1234567&lt;!doctype html&gt;&lt;title&gt;Hello from Flask&lt;/title&gt;&#123;% if name %&#125; &lt;h1&gt;Hello &#123;&#123; name &#125;&#125;!&lt;/h1&gt;&#123;% else %&#125; &lt;h1&gt;Hello World!&lt;/h1&gt;&#123;% endif %&#125; 访问请求数据可以通过request.form属性来访问表单数据。12345@app.route("/signin", methods=["POST"])def signin(): print request.args.get("username") username = request.form["username"] return render_template('hello.html', name=username) 如果form表单中不存在所要获取的键，会抛出特殊的KeyError异常。 文件上传首先确保HTML表单中设置 enctype=&quot;multipart/form-data&quot;属性，否则浏览器根本不会发送文件。已上传的文件存储在内存或是文件系统中一个临时的位置。可以通过请求对象的file属性访问它。每个上传的文件都会存储在这个字典里。同时它还有一个save()方法，这个方法允许把文件保额哦村到服务器的文件系统上。如果像知道上传的文件在客户端是什么名字，可以访问filename属性1234567from flask import request@app.route('/upload', methods=['GET', 'POST'])def upload_file(): if request.method == 'POST': f = request.files['the_file'] f.save('/var/www/uploads/uploaded_file.txt') Cookies可以通过cookies属性来访问Cookies，用响应对象的set_cookie方法来设置Cookies。请求对象的cookies属性是一个内容为客户端提交的所有Cookies的字典.读取cookies：1234567from flask import request@app.route('/')def index(): username = request.cookies.get('username') # use cookies.get(key) instead of cookies[key] to not get a # KeyError if the cookie is missing. 存储cookie：1234567from flask import make_response@app.route('/')def index(): resp = make_response(render_template(...)) resp.set_cookie('username', 'the username') return resp 需要注意的是，Cookies是设置在响应对象上的。由于通常视图函数只是返回字符串，之后Flask将字符串转换为响应对象。 重定向和错误可以使用redirect()函数把用户重定向到其他地方。用abort()函数放弃请求并返回错误代码，如下：12345678910from flask import abort, redirect, url_for@app.route('/')def index(): return redirect(url_for('login'))@app.route('/login')def login(): abort(401) this_is_never_executed() 这是一个完全没有任何意义的代码，因为用户会从主页重定向到一个不能访问的页面。默认情况下，错误代码会显示一个黑白的错误页面，如果要定制错误页面，可以使用errorhandler()装饰器12345from flask import render_template@app.errorhandler(404)def page_not_found(error): return render_template('page_not_found.html'), 404 注意`render_template()调用之后的404，这告诉Flask，该页的错误代码是404。默认是200,也就是一切正常 关于响应视图函数的返回值会被自动转换为一个响应对象。如果返回值是一个字符串， 它被转换为该字符串为主体的、状态码为 200 OK的 、 MIME 类型是text/html 的响应对象。Flask 把返回值转换为响应对象的逻辑是这样： 如果返回的是一个合法的响应对象，它会从视图直接返回。 如果返回的是一个字符串，响应对象会用字符串数据和默认参数创建。 如果返回的是一个元组，且元组中的元素可以提供额外的信息。这样的元组必须是 (response, status, headers) 的形式，且至少包含一个元素。 status 值会覆盖状态代码， headers 可以是一个列表或字典，作为额外的消息标头值。 如果上述条件均不满足， Flask 会假设返回值是一个合法的 WSGI 应用程序，并转换为一个请求对象。如果你想在视图里操纵上述步骤结果的响应对象，可以使用 make_response() 函数。 譬如你有这样一个视图:123@app.errorhandler(404)def not_found(error): return render_template('error.html'), 404 只需要把返回值表达式传递给make_response()，获取结果对象并修改，然后再返回它:12345@app.errorhandler(404)def not_found(error): resp = make_response(render_template('error.html'), 404) resp.headers['X-Something'] = 'A value' return resp 会话除请求对象之后，还有一个session对象，它允许你在不同请求间存储特定用户的信息。他是在Cookies的基础上实现，并且对Cookies进行密钥签名。这意味着用户可以查看你Cookie的内容，但却不能修改它，除非用户知道签名的密钥。要使用会话，需要设置一个密钥123456789101112131415161718192021222324252627282930from flask import Flask, session, redirect, url_for, escape, requestapp = Flask(__name__)@app.route('/')def index(): if 'username' in session: return 'Logged in as %s' % escape(session['username']) return 'You are not logged in'@app.route('/login', methods=['GET', 'POST'])def login(): if request.method == 'POST': session['username'] = request.form['username'] return redirect(url_for('index')) return ''' &lt;form action="" method="post"&gt; &lt;p&gt;&lt;input type=text name=username&gt; &lt;p&gt;&lt;input type=submit value=Login&gt; &lt;/form&gt; '''@app.route('/logout')def logout(): # remove the username from the session if it's there session.pop('username', None) return redirect(url_for('index'))# set the secret key. keep this really secret:app.secret_key = 'A0Zr98j/3yX R~XHH!jmN]LWX/,?RT' 这里提到的escape()可以在模板引擎外做转义 以上]]></content>
      <tags>
        <tag>Python</tag>
        <tag>flask</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[TCP协议的简单理解]]></title>
    <url>%2F2017%2F07%2F03%2FTCP%E5%8D%8F%E8%AE%AE%E7%9A%84%E7%AE%80%E5%8D%95%E7%90%86%E8%A7%A3%2F</url>
    <content type="text"><![CDATA[尽管TCP和UDP都使用相同的网络层(IP)，TCP却向应用层提供与UDP完全不同的服务。TCP提供一种面向连接的、可靠的字节流服务。这里的面向连接是指：两个使用TCP的应用（通常是一个客户一个服务器）在彼此交换数据之前必须先建立一个TCP连接。 TCP的主要特点 TCP是面向连接的运输层协议 每一条TCP连接只能两个短点，每一条TCP都是点对点的 提供可靠交付服务 提供全双工服务 面向字节流TCP通过下列方式来提供可靠性 应用数据被分割成TCP认为最合适发送的数据块。这个UDP完全不同，应用程序产生的数据报长度将保持不变。由TCP传递给IP的信息单位称为报文段或段(segment) 当TCP发出一个段之后，它将启动一个定时器，等待目的端确认收到这个报文段，如果目的端不能及时确认接收，将重发这个报文段 当TCP收到发至TCP连接的另一端的数据，它将发送一个确认。 TCP保持它首部和数据的检验和。这是一个端到端的检验和，目的是检测数据在传输过程中的任何变化。如果检验和有差错，TCP将丢弃这个报文段和不确认接收此报文段，并希望另一端重传此报文段。 既然TCP报文段作为IP数据报来传输，而IP数据报的到达可能会失序，因此TCP报文段的到达也可能会失序。如果必要，TCP将对收到的数据进行重新排序，将收到的数据以正确的顺序交给应用层。 既然IP数据报会发生重复，TCP的接收端必须丢弃重复的数据。 TCP还能提供流量控制。TCP连接的每一方都有固定大小的缓冲空间，TCP的接收端只允许另一端发送接收端缓冲区所能接纳的数据。这将防止较快主机致使较慢主机缓冲区溢出。停止等待协议停止等待协议用下面的图来说明：图片来源于《计算机网络第六版》谢希仁编著在全双工通信的情况下，每一端既是接收方也是发送方，为方便，简化为A向B发送数据. 在无差错的情况下，A向B发送数据分组M1，发送完了就等待B的确认。B确认接收M1之后向A发送确认收到M1的数据。A收到B发送的”确认收到M1”的消息后，再向B发送下一组数据分组。 在有差错的情况下，B收到的数据分组可能是内容不对，B就把数据直接丢弃；也可能是数据分组在 传输过程中丢失了，B什么也没有接收到。这两种情况下，B什么也不操作（不通知A数据有错或者没收到数据。等到过一段时间，A没有收到B的确认消息，就认为刚刚发送的数据丢失了，然后重新传输刚才发送的分组。这要求A在每次发送一个数据分组时，都要设计一个超时计数器。 但是要注意 1) A在发送完一个分组后，必须暂时保留已发送的分组的副本（超时重传）。只有等到分组确认后才能清除暂时保留的副本 2) 分组和确认分组必须都进行编号 3) 超时及时器设置的重传时间应当比数据在分组传输的平均往返时间更长一些。 确认丢失和确认迟到下图左边的情况是B向A发送的确认收到M1的消息丢失了。A在设定的超时重传时间内没有收到确认，但并无法知道是自己发送的分组出错、丢失，或者是B发送的确认丢失了，因此A在超时计时器到期后就要重传M1。假定B又收到了重传的分组M1.这时应采取两个行动： 1) 丢弃这个重复的分组M1，不向上层交付。 2) 向A发送确认，不能认为已经发送过确认就不再发送，因为A之所以重传M1就表示A没有收到M1的确认。下图右边的情况是传输过程中没有出现差错，但是B对分组M1的确认迟到了，A会收到重复确认，然后丢弃掉，但是这时A已经重发数据分组M1了，B收到重复的分组M1胡同样丢弃重复的分组M1，并重传确认分组。连续ARQ协议 滑动窗口协议比较复杂。图片来源于《计算机网络第六版》谢希仁编著下图a表示发送发维持的发送窗口，它的意义是：位于发送窗口内的5个分组都可以连续发送出去，而不需要等待对方确认。连续ARQ协议规定，发送方每收到一个确认，就把窗口向前滑动一个分组的位置，b表示发送发收到了对第一个分组的确认，于是把发送的分组向前移动一个分组的位置。接收方一般都是采用累计确认的方式。这就是说，接收方不必对收到的分组逐个发送确认，而是在收到几个分组后，对按序到达的的最后一个分组发送确认，这就表示：到这个分组为止的所有分组都已经正确收到了。滑动窗口 TCP的滑动窗口是以字节为单位的。现在假定A收到了B发来的确认报文段，其中窗口是20，而确认号是31(这表明B期望收到的下一个序号是31,到序号30为止的数据已经收到了)。根据这两个数据，A就构造出自己的发送窗口，如下图所示 发送窗口表示：在没有收到B的确认情况下，A可以把窗口内的数据都发送出去。凡是已经发送过的数据，在未收到确认之前都必须暂时保留，以便在超时重传时使用。发送窗口里面的序号表示允许发送的序号。显然，窗口越大，发送方就可以在收到对方确认之前连续发送更多的数据，因而可能获得更高的传输效率。但是接收方必须来得及处理这些收到的数据。发送窗口后延的后面部分表示已发送且已收到了确认。这些数据显然不需要再保留。而发送窗口前沿的前面部分表示不允许发送的，因为接收方都没有为这部分数据保留临时存放的缓存空间。 发送窗口的位置由窗口前沿和后延的位置共同确定。发送窗口后沿的变换情况有两种可能，即不懂(没有收到新的确认)和前移(收到了新的确认)。发送窗口后沿不可能向后移动，因为不能撤销掉已收到的确认。发送窗口前沿通常是不断向前移动，但也有可能不动。这对应于两种情况：一时没有收到信的确认，对方通知的窗口大小也不变；二是收到了新的确认但对方通知的窗口缩小了，使得发送窗口前沿正好不动。发送窗口前沿也可能向后收缩，但是TCP的标准强烈不赞成这么做。TCP连接的建立假定主机A运行的是TCP客户程序，而B运行TCP服务器程序。最初两端的TCP进程都处于CLOSED(关闭)状态。如下图所示。现在A主动打开连接，而B是被动打开连接。 B的TCP服务器先创建传输控制块TCB，准备接受客户程序的连接请求，然后服务器进场就处于LISTEN(监听)状态，等待客户端的连接请求。如果有，即作出响应。 A的TCP客户进程也是首先创建传输控制模块TCB，然后向B发出连接请求报文段，这时首部中的同部位SYN=1，同时选择一个初始序号 seq=x 。TCP规定，SYN报文段(即SYN=1的报文段)不能携带数据，但要消耗掉一个序号。这时，TCP客户进程进入SYN-SENT(同步已发送)状态。 B收到连接请求报文段后，如果同意建立连接，则向A发送确认。在确认报文段中应把SYN位和ACK位都置1，确认号是ack=x+1 ,同时也为自己选择一个初始序号seq=y。这个报文段也不能携带数据，但同样要消耗掉一个序号。这时TCP服务器进程进入SYN-RCVD(同步收到)状态。 TCP客户进程收到B的确认后，还要向B给出确认。确认报文段的ACK置1，确认号ack=y+1，而自己的序号seq=x+1。TCP的标准规定，ACK报文段可以携带数据。但如果不携带数据则不消耗序号，在这种情况下，下一个数据报文段的序号仍然是seq=x+1。这时TCP连接已经建立，A进入ESTABLISHED(已建立连接)状态。 当B收到A的确认后，也进入ESTABLISHED状态 A最后发送一次确认主要是为了防止已失效的连接请求报文段突然又传送到了B，因而产生错误。TCP连接的释放数据传输结束后，通信的双方都可释放连接。 现在A和B都处于ESTABLISHED状态，A的应用进程先向其TCP发出连接释放报文段，并停止再发送数据，主动关闭TCP连接，A把连接释放报文段首部的宗旨控制位FIN置1，其序号seq=u，它等于前面已传送过的数据的最后一个直接的序号加1.这时A进入FIN-WAIT-1(终止等待1)状态，等待B的确认。TCP规定，FIN报文段即使不携带数据，它也消耗掉一个序号。 B收到连接释放报文段后即发出确认，确认号是ack=u+1，而这个报文段自己的序号是v，等于B前面已传送过的数据的最后一个字节的序号加1。然后B就进入CLOSE-WAIT(关闭等待)状态。TCP服务器进程这时应通知高层应用进程，因而从A到B这个方向的连接就释放了，这时的TCP连接处于半关闭(half-close)状态，即A已经没有数据要发送了，但B若发送数据，A仍要接收，就是说，从B到A这个方向的连接并未关闭，这个状态可能会持续一些时间。 A收到来自B的确认后，就进图FIN-WAIT-2(终止等待2)状态，等待B发出的连接释放报文段。 若B已经没有要向A发送的数据，其应用进程就通知TCP释放连接。这时B发出的连接释放报文段必须使用FIN=1.现在假定B的序号为w(在半关闭状态B可能又发送了一些数据)，B还必须重复上次已发送过的确认号ack=u+1。这时B就进入LAST-ACK(最后确认)状态，等待A的确认。 A在收到B的连接释放报文段后，必须对此发出确认。在确认报文段中把ACK置1，确认号ack=w+1，而自己的序号是seq=u+1，TCP规定，前面发送的FIN报文段要消耗一个序号。然后进入到TIME-WAIT(时间等待)状态。现在TCP连接还没有释放掉。必须经过时间等待计时器(TIME-WAIT timer)设置的时间2MSL后，A才进入到CLOSED状态，时间MSL叫做最长报文段寿命。 B只要收到了A发出的确认，就进入CLOSED状态。同样，B在撤销相应的出书控制块TCB后，就结束了这次的TCP连接。B结束TCP连接的时间要比A早一些。TCP有限状态机粗实线箭头表示对客户进程的正常变迁、粗虚线箭头表示对服务器进程的正常变迁、另一种细线箭头表示异常变迁。 以上文字和图片均来自于《计算机网络第6版》谢希仁著 以上]]></content>
      <tags>
        <tag>tcp协议</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Jenkins安装与使用]]></title>
    <url>%2F2017%2F06%2F28%2FJenkins%E5%AE%89%E8%A3%85%E4%B8%8E%E4%BD%BF%E7%94%A8%2F</url>
    <content type="text"><![CDATA[公司需求，业务越来越多，服务器越来越多，后台部署项目麻烦的要死，于是上了jenkins这货。关于这货是干嘛的，请移步这里https://jenkins.io/,下载请移步这里https://jenkins.io/download/安装环境：ubuntu 16.04、tomcat7(这个是因为Jenkins是个war包)、maven(这个是因为后台的项目是maven工程)、jdk8(这个是因为需要tomcat)、gradle(构建Android工程)、SDK(构建Android工程) Jenkins 环境安装JDK、Tomcat、MAVEN(如有需要)、gradle(构建Android工程)、SDK(构建Android工程) 安装Jenkins在上面的下载地址下载war，丢到tomcat的webapps文件夹下，然后启动tomcat，浏览器访问jenkin工程127.0.0.1:8080/jenkins如下图所示：打开红字提示的文件，里面是首次进入时需要的密码,点击右下角continue。 jenkins安装插件可以自定义也可以安装推荐的插件，我这里安装的是建议的插件.稍等一会，插件安装完成后会自动跳转到创建jenkins用户的界面 创建jenkins用户按照提示创建即可，点击右下角Save and finish 配置Jenkins以后再次访问jenkins的时候就不用再去使用初始密码，只需要使用上一步创建的账号即可，登录后首界面如下，点击左侧的系统管理，在中间列出的工具里面点击Global Tool Configuration，指定JDK和MAVEN的路径，如下然后Save保存 创建一个新的Maven工程点击左侧菜单栏新建,输入工程名字，然后选择构建一个只有风格的软件项目,然后ok 配置工程在新的界面可以配置项目的构建、源码管理等我的工程是存放在git上面的，所以就选择git构建触发器可以配置在什么时间配置，我们暂时没有，需要手动点击构建才行构建环境没有配置构建一项选择 Invoke top-level Maven target,当然根据需求可以选择其他构建方式Maven Version是上面配置maven时选择的别名，Goals是需要执行的maven命令(前面不需要加maven)点击左下角保存 开始构建点击左侧的立即构建，可以在构建历史中查看原来构建的个过程点击构建历史列表里面对应构建历史的小圆点，可以查看控制台输出ps：如果是普通用户启动的tomcat，使用git管理源码，则下载下来的工程源码在/home/username/.jenkins/workspace，如果是root用户，则在 /root/.jenkins/workspace下pps:据说jenkins的包不需要tomcat也可以，执行java -jar ***.war即可]]></content>
      <tags>
        <tag>jenkins</tag>
        <tag>运维</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[elk简单环境搭建 for linux]]></title>
    <url>%2F2017%2F06%2F13%2Felk%E7%AE%80%E5%8D%95%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA-for-linux%2F</url>
    <content type="text"><![CDATA[环境：ubuntu 16.06虚拟机：4核8G内存在官网下载的tag.gz包，官网地址https://www.elastic.co/webinars/introduction-elk-stack安装版本是5.4.1，本文只安装了Elasticsearch、Logstash、Kibana Elasticsearch 下载压缩包并解压 在es的根目录下config/elasticsearch.yml文件，内容如下1234567891011121314151617181920# Use a descriptive name for the node:node.name: xuannode ##不要有'-'、'_'、'+'# Path to directory where to store the data (separate multiple locations by comma):#path.data: /home/huangyuan/elk/elasticsearch/data## Path to log files:#path.logs: /home/huangyuan/elk/elasticsearch/logs/*## Set the bind address to a specific IP (IPv4 or IPv6):#network.host: 0.0.0.0## Set a custom port for HTTP:#http.port: 9200discovery.zen.ping.unicast.hosts: ["0.0.0.0"]http.cors.enabled: truehttp.cors.allow-origin: "*" logstash 下载压缩包并解压 创建一个logstash.conf文件，输入以下内容并保存: 123456789101112input&#123; file &#123; path =&gt; &quot;/home/huangyuan/elkdata/*.log&quot; &#125;&#125;output &#123; elasticsearch &#123; hosts =&gt; &quot;http://192.168.1.179:9200&quot; index =&gt; &quot;logstash-%&#123;+YYYY.MM.dd&#125;&quot; &#125; stdout &#123;&#125;&#125; 启动时执行 bin/logstash -f logstash.conf kibana 下载压缩包并解压缩 编辑config/kibana.yml12345678910# Kibana is served by a back end server. This setting specifies the port to use.server.port: 5601# Specifies the address to which the Kibana server will bind. IP addresses and host names are both valid values.# The default is 'localhost', which usually means remote machines will not be able to connect.# To allow connections from remote users, set this parameter to a non-loopback address.server.host: "192.168.1.179"# The Kibana server's name. This is used for display purposes.server.name: "xuankibina"# The URL of the Elasticsearch instance to use for all your queries.elasticsearch.url: "http://192.168.1.179:9200" 启动的时候依次启动 es、logstash、kibana就可以了PS:1.在LogStash的配置文件logstash.conf中,input配置的就是logstash要监听的文件路径，启动之后，先在监听的文件夹中创建一个log文件并输入随意内容。 elasticsearch不能用root用户启动 启动es报错max virtual memory areas vm.max_map_count [65530]is too low, increase to at least [262144]:解决方法是修改/etc/sysctl.conf配置文件，添加vm.max_map_count=262144，重启机器才起作用.以上]]></content>
      <tags>
        <tag>运维</tag>
        <tag>elk</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[git工具]]></title>
    <url>%2F2017%2F05%2F10%2Fgit%E5%B7%A5%E5%85%B7%2F</url>
    <content type="text"><![CDATA[公司代码版本管理系统由svn迁到了git，对于AndroidStudio来讲，内置的GUI工具足以应付日常开发，但在请求失败的情况下，对失败原因的提示不够清晰。个人习惯上用命令行，但是对于命令行中比较两个文件差异以及合并来说，个人还是不大习惯，于是就配置成了使用其他软件进行合并。可以使用$ git difftool --tool-help查看对比文件差异支持的软件，用$ git mergetool --tool-help查看合并代码支持的软件，个人只试过两种:codecompare和beyond compare。不习惯bc的界面，最后决定使用codecompare。 配置codecompare为diff和merge工具 安装codecompare软件 配置codecompare为diff工具 git config --global diff.tool codecompare 配置codecompare的路径path 后面是软件的安装路径 git config --global difftool.codecompare.path D://CodeCompare//CodeCompare.exe 配置codecompare为merge工具 git config --global merge.tool codecompare 配置codecompare的路径path 后面是软件的安装路径 git config --global mergetool.codecompare.path D://CodeCompare//CodeMerge.exe 在比较本地修改后的文件与本地仓库中的文件差异时，执行 git difftool &lt;filename&gt;即可。当更新代码自动合并失败的时候，执行 git mergetool即可。 配置beyond compare为diff和merge工具配置方式和codecompare一样，需要注意的是： 如果beyond compare软件是4.X1) 如果git的版本低于2.2.0,配置的时候用bc32) 如果git的版本大于等于2.2.0,配置的时候用bc这个如何配置官网有说明，就不再赘述在比较本地修改后的文件与本地仓库中的文件差异时，执行 git difftool &lt;filename&gt;即可。当更新代码自动合并失败的时候，执行 git mergetool即可。有人不习惯git自动merge成功后填写merge信息的编辑器，说明一下，默认的编辑器是vim,不习惯用的话可以使用 git config --global core.edit &lt;软件路径&gt;来修改。需要注意的是，git命令行似乎读不到windows系统的path，需要写软件的绝对路径。 以上]]></content>
      <tags>
        <tag>git</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[搭建git服务]]></title>
    <url>%2F2017%2F04%2F15%2F%E6%90%AD%E5%BB%BAgit%E6%9C%8D%E5%8A%A1%2F</url>
    <content type="text"><![CDATA[公司的版本控制要从SVN迁移到git，正式的开发环境还没有搭建好，于是自己做了一个简单git服务。环境：本机: win10，服务器：ubuntu 16.04 LTS,ip:192.168.1.103本地安装git环境，配置用户名和邮箱之类的信息，然后生成秘钥，生成方式见 http://blog.csdn.net/huangyuan_xuan/article/details/49125597。服务器： 安装git,ssh服务sudo apt install git ssh 新增用户，用户名为gitadduser git 初始化git仓库，我放在/home/git/repositorycd /home/git/repositorygit init --bare test.git--base参数是初始化裸仓库。执行tree命令可以查看目录结构如下： 添加秘钥将本地生成的id_rsa.pub文件里面的内容追加到/home/git/.ssh/authorized_keys文件中。可以先将秘钥文件上传到服务器，然后在服务器上操作文件，添加内容。 修改权限将 /home/git 所有者更改为git用户chown -R git:git /home/git用户home目录755权限chmod 755 /home/git.ssh目录700权限chmod 700 .sshauthorized_keys 600权限chmod 600 .ssh/authorized_keys 修改ssh配置文件配置文件是/etc/ssh/sshd_config，取消这行 AuthorizedKeysFile %h/.ssh/authorized_keys 前面的注释 重启ssh服务sudo service ssh restart 可选项：为了安全 禁止git用户shell登录，需要修改/etc/passwd将 git:x:1001:1001:,,,:/home/git:/bin/bash改为 git:x:1001:1001:,,,:/home/git:/usr/bin/git-shell 回到本地，进行克隆git clone git@192.168.1.103:/home/git/code/test.git或者git clone git@192.168.1.103:code/test.git如果ssh不是默认的22端口，则在ip后添加端口。]]></content>
      <tags>
        <tag>运维</tag>
        <tag>git</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JVM-内存分配与回收策略]]></title>
    <url>%2F2017%2F04%2F07%2FJVM-%E5%86%85%E5%AD%98%E5%88%86%E9%85%8D%E4%B8%8E%E5%9B%9E%E6%94%B6%E7%AD%96%E7%95%A5%2F</url>
    <content type="text"><![CDATA[Java技术体系中所提倡的自动内存管理最终可以归结为自动化的解决了两个问题：给对象分配内存以及回收分配给对象的内存。对象的内存分配，往大方向讲，就是在堆上分配(但也可能经过JIT编译后被拆散为标量类型并间接地栈上分配)，对象主要分配在新生代的Eden区上，如果启动了本地线程分配缓冲，将按线程优先在TLAB上分配。少数情况下也可能会直接分配在老年代中，分配的规则并不是百分百固定的，其细节取决于当前使用的是哪一种垃圾回收器组合，还有虚拟机中与内存相关的参数设置。 对象优先在Eden分配 大多数情况下，对象在新生代Eden区中分配，当Eden区没有足够空间进行分配时，虚拟机将发起一次Minor GC。虚拟机提供了-XX：+PrintGCDetails这个收集器日志参数，告诉虚拟机在发生垃圾收集行为时打印内存回收日志，并且在进程退出的时候输出当前的内存各区域分配情况。 新生代GC(Minor GC):指发生在新生代的垃圾收集动作，因为Java对象大多都具备朝生夕灭的特性，所以Minor GC非常频繁，一般回收速度也比较快。 老年代GC(Major GC/Full GC):指发生在老年代的GC，出现了Major GC，经常会伴随至少一次的Minor GC，(但非绝对的，在Parallel Scavenge收集器的手机策略里就有直接进行Major GC的策略选择过程)。Major GC的速度一般会比Minor GC慢10倍以上。 大对象直接进入老年代 所谓的大对象是指，需要大量连续内存空间的Java对象，最典型的大对象就是那种很长的字符串以及数组，大对象对虚拟机的内存分配来说就是一个坏消息，经常出现大对象容易导致内存还有不少空间时就提前出发垃圾收集以获取足够的连续空间来”安置”它们。 长期存活的对象将进入老年代 既然虚拟机采用了分代收集的思想来管理内存，那么内存回收时就必须能识别哪些对象应放在新生代，哪些对象应放在老年代中。为了做到这点，虚拟机给每个对象定义了一个对象年龄(Age)计数器。如果对象在Eden出生并经过第一个Minor GC后仍然存活，并且能被Survivor容纳的话，将被移动到Survivor空间中，并且对象年龄设为1。对象在Survivor区中每经过一个Minor GC，年龄就增加1岁，当它的年龄增加到一定程度(默认是15岁)，就会被晋升到老年代中。对象晋升老年代的年龄阈值，可以通过参数-XX：MaxTenuringThreshold设置。 动态对象年龄判定 为了能更好的适应不同程序的内存状况，虚拟机并不是永远的要求对象的年龄必须达到了MaxTenuringThreshold才能晋升到老年代，如果Survivor空间中相同的年龄所有对象大小的总和大于Survivor空间的一般，年龄大于或等于改年龄的对象就可以直接进入老年代，无序等到MaxTenuringThreshold中要求的年龄。 空间分配担保 在发生Minor GC之前，虚拟机会先检查老年代最大可用的连续空间是否大于新生代所有对象总空间，如果这个条件成立，那么Minor GC可以确保是安全的。如果不成立，则虚拟机会查看HandlePromotionFailure设置值是否允许担保失败。如果允许，那么会继续检查老年代最大可用的连续空间是否大于历次晋升到老年代对象的平均大小，如果大于，将尝试着进行一次Minor GC，尽管这次Minor GC是有风险的；如果小于，或者HandlePromotionFailure设置不允许冒险，那这时也要改为进行一次Full GC。新生代使用复制收集算法，但为了内存利用率，只使用其中一个Survivor空间来作为轮换备份，因此当出现大量对象在Minor GC后仍然存活的情况(最极端的情况就是内存回收后新生代中所有对象都存活)，就需要老年代进行分配担保，把Survivor无法容纳的对象直接进入老年代。 与生活中的贷款担保类似，老年代要进行这样的担保，前提是老年代本身还有容纳这些对象的剩余空间，一共有多少对象会活下来在实际完成内存回收之前是无法明确知道的，所以只好取之前每一次回收晋升到老年代对象容量的平均大小值作为经验值，与老年代的剩余空间进行比较，决定是否进行Full GC来让老年代腾出更多空间。取平均值进行比较其实仍然是一种动态概率的手段，也就是说，如果某次Minor GC存活后的对象突增，远远高于平均值的话，依然会导致担保失败(Handle Promotion Failure)。如果出现了HandlePromotionFailure失败，那就只好在失败后重新发起一次Full GC。 虽然担保失败时绕的圈子是最大的，但大部分情况下都还是会将HandlePromotionFailure开关打开，避免Full GC过于频繁。 以上]]></content>
      <tags>
        <tag>JVM</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JVM-垃圾收集算法与实现]]></title>
    <url>%2F2017%2F03%2F30%2FJVM-%E5%9E%83%E5%9C%BE%E6%94%B6%E9%9B%86%E7%AE%97%E6%B3%95%2F</url>
    <content type="text"><![CDATA[由于垃圾收集算法的实现涉及大量的程序细节，而且各个平台的虚拟机操作内存的方法又各不相同，这里只是介绍几种算法的思想及其发展过程。 垃圾收集算法标记-清除算法 最基础的算法是”标记-清除”(Mark-Sweep)算法，算法分为’标记’和’清除’两个阶段：首先标记处所有需要回收的对象，在标记后统一回收所有被标记的对象。它的主要不足有两个：一个事效率问题，标记和清除两个过程的效率都不高；另外一个事空间问题，标记清除之后会产生大量不连续的内存碎片，空间碎片太多可能会导致以后再程序运行过程中需要分配较大对象时，无法找到足够的连续内存而不得不提前触发另一次垃圾收集动作。 1. 复制算法 它将可用内存按容量划分为大小相等的两块，每次只使用其中的一块，当这一块的内存用完了，就将还存活着的对象复制到另外一块上面，然后把已经使用过的内存空间一次清理掉。这样使得每次都是对整个半区进行内存回收，内存分配时也就不用考虑内存碎片等复杂情况。只要移动堆顶指针，按顺序分配内存即可，实现简单，运行高效，只是这种算法的代价是将内存缩小为了原来的一般，代价太高。现在的商业虚拟机都采用这种手机算法回收新生代，IBM公司的专门研究表明，新生代中的对象98%是朝生夕死的，所以并不需要按照1:1的比例来划分内存空间，而是将内存分为一块较大的Eden空间和两块较小的Survivor空间，每次使用Eden和其中一块Survivor空间上，最后清理掉Eden和刚才用过的Survivor中还存活着的对象一次性复制到另外一块Survivor空间上，最后清理掉Eden和刚才用过的Survivor空间。 2. 标记-整理算法 复制收集短发在对象存活率较高时就要进行较多的复制操作，效率将会变低。更关键的是，如果不想浪费一半的空间，就需要额外的控件进行分配担保，以应对被使用的的内存中所有对象都100%存活的极端情况，所以在老年代一半不能直接选用这种算法。根据老年代的特点，有人提出了另外一种”标记-整理”(Mark-Compact)算法，标记过程任然与”标记-清除”算法一样，但后续步骤不是直接对可回收对象进行清理，而是让所有存活的对象都向一端移动，然后直接清理掉端便捷以外的内存。 3. 分代收集算法 当前商业虚拟机的垃圾收集都采用”分代收集”(Generational Collection)算法，这种算法并没有什么新的思想，只是根据对象的存货周期的不同将内存划分为几块，一般是把Java堆分为新生代和老年代，这样就可以根据各个年代的特点采用最适当的收集算法。在新生代中，每次垃圾收集时都发现有大批对象死去，只有少量存活，那就选用复制算法，只需要付出少量存活对象的复制成本就可以完成收集。而老年代中因为对象存活率高、没有额外空间对它进行分配担保，就必须使用”标记-清理”或者”标记-整理”算法来进行回收。 HotSpot算法实现枚举根节点 从可达性分析中从GC Roots节点引用链这个操作为例，可作为GC Roots的节点主要在全局性的引用(例如常量或类静态属性)与执行上下文(例如栈帧中的本地变量表)中，现在很多应用仅仅方法区就有数百兆，如果要逐个检查这里面的引用，那么必然会消耗很多时间。另外，可达性分析对执行时间的敏感还体现在GC停顿上，因为这项分析工作必须在一个能确保一致性的快照中进行—-这里一致性的意思是指在这个分析期间整个执行系统看起来就像被冻结在某个时间点上，不可以出现分析过程中对象引用关系还在不断变化的情况，该点不满足的话分析结果准确性就无法得到抱枕。这点是导致GC进行时必须停顿所有Java执行线程(Sun将这件事情称为”Stop The World”)的其中一个重要原因，即使是在号称几乎不会发生停顿的CMS收集器中，枚举根节点时也是必须要停顿的。由于目前的主流java虚拟机使用的都是准确式GC，所以当执行系统停顿下来后，并不需要一个不漏的检查完所有执行上下文和全局引用位置，虚拟机应当是有办法直接得知哪些地方存放着对象引用。在HotSpot的实现中，是使用一组称为OopMap的数据结构来达到这个目的的，在类加载完成的时候，HotSpot就把对象内什么偏移量上是什么类型的数据计算出来，在JIT编译过程中，也会在特定的位置记录下栈和寄存器中哪些位置是引用，这样，GC在扫描时就可以直接得知这些信息了。 安全点 在OopMap的协助下，HotSpot可以快速且准确地完成GC Roots枚举，但一个很现实的问题随之而来：可能导致引用关系变化，或者说OopMap内容变化的指令非常多，如果为每一条指令都生成对应的OopMap，那将会需要大量的额外空间，这样GC的空间成本将会变得很高。实际上，HotSpot也的确没有为每条指令都生成OopMap，前面已经提到，只是在“特定的位置”记录了这些信息，这些位置称为安全点（Safepoint），即程序执行时并非在所有地方都能停顿下来开始GC，只有在到达安全点时才能暂停。 Safepoint的选定既不能太少以致于让GC等待时间太长，也不能过于频繁以致于过分增大运行时的负荷。 所以，安全点的选定基本上是以程序“是否具有让程序长时间执行的特征”为标准进行选定的——因为每条指令执行的时间都非常短暂，程序不太可能因为指令流长度太长这个原因而过长时间运行，“长时间执行”的最明显特征就是指令序列复用，例如方法调用、循环跳转、 异常跳转等，所以具有这些功能的指令才会产生Safepoint。对于Sefepoint，另一个需要考虑的问题是如何在GC发生时让所有线程（这里不包括执行JNI调用的线程）都“跑”到最近的安全点上再停顿下来。 这里有两种方案可供选择：抢先式中断（Preemptive Suspension）和主动式中断（Voluntary Suspension），其中抢先式中断不需要线程的执行代码主动去配合，在GC发生时，首先把所有线程全部中断，如果发现有线程中断的地方不在安全点上，就恢复线程，让它“跑”到安全点上。 现在几乎没有虚拟机实现采用抢先式中断来暂停线程从而响应GC事件。而主动式中断的思想是当GC需要中断线程的时候，不直接对线程操作，仅仅简单地设置一个标志，各个线程执行时主动去轮询这个标志，发现中断标志为真时就自己中断挂起。轮询标志的地方和安全点是重合的，另外再加上创建对象需要分配内存的地方。 安全区域 使用Safepoint似乎已经完美地解决了如何进入GC的问题，但实际情况却并不一定。Safepoint机制保证了程序执行时，在不太长的时间内就会遇到可进入GC的Safepoint。但是，程序“不执行”的时候呢？所谓的程序不执行就是没有分配CPU时间，典型的例子就是线程处于Sleep状态或者Blocked状态，这时候线程无法响应JVM的中断请求，“走”到安全的地方去中断挂起，JVM也显然不太可能等待线程重新被分配CPU时间。 对于这种情况，就需要安全区域（Safe Region）来解决。安全区域是指在一段代码片段之中，引用关系不会发生变化。 在这个区域中的任意地方开始GC都是安全的。 我们也可以把Safe Region看做是被扩展了的Safepoint。 在线程执行到Safe Region中的代码时，首先标识自己已经进入了Safe Region，那样，当在这段时间里JVM要发起GC时，就不用管标识自己为Safe Region状态的线程了。在线程要离开Safe Region时，它要检查系统是否已经完成了根节点枚举（或者是整个GC过程），如果完成了，那线程就继续执行，否则它就必须等待直到收到可以安全离开Safe Region的信号为止。以上]]></content>
      <tags>
        <tag>JVM</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JVM垃圾回收-对象已死？]]></title>
    <url>%2F2017%2F03%2F29%2FJVM%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6-%E5%AF%B9%E8%B1%A1%E5%B7%B2%E6%AD%BB%EF%BC%9F%2F</url>
    <content type="text"><![CDATA[在堆里面存放着Java世界中几乎所有的对象实例，垃圾收集器在对堆进行回收前，第一件事情就是要确定这些对象之中哪些还存活着，哪些已经死去(即不能再被任何途径使用的对象)。 引用计数算法 很多教科书判断对象是否存活的算法是这样的：给对象中添加一个引用计数器，每当有一个地方引用它时，计数器值就加1;当引用失效时，计数器就减1；任何时刻计数器为0的对象就是不可能再被使用的。客观来讲，引用计数法(Reference Counting)的实现简单，判定效率也很高，在大部分情况下它都是一个不错的算法，但是，至少主流的Java虚拟机里面没有选用引用计数器算法来管理内存，其中主要的原因是它很难解决对象之间相互循环引用的问题。 可达性分析算法 在主流的商用程序语言的主流实现中，都是通过可达性分析(Reachability Analysis)来判定对象是否存活的。这个算吗的基本思路就是通过一系列的称为GC Roots的对象作为起始点，从这些节点开始向下搜索，搜索所走过的路径称为引用链(Reference Chain),当一个对象到GC Roots没有任何引用链相连时(在图论中，就是从GC Roots到这个对象不可达)，则证明此对象是不可用的。在Java语言中，可作为GC Roots的对象包括一下几种： 虚拟机栈(栈帧中的本地变量表)中引用的对象。 方法区中静态属性引用的对象。 方法区中常量引用的对象。 本地方法栈中JNI(一般说的Native方法)引用的对象 生存还是死亡 即使在可达性分析算法中不可达的对象，也并非是非死不可的，这时候他们暂时处于缓刑阶段，要真正宣告一个对象死亡，至少要经历两次标记过程：如果对象在进行可达性分析后发现没有与GC Roots相连接的引用链，那它将会被第一次标记并且进行一次筛选，筛选的条件是此对象是否有必要执行finalize()方法。当对象没有覆盖finalize()方法，或者finalize()方法已经被虚拟机调用过，虚拟机将这两种情况都视为”没有必要执行”。如果这个对象呗判定为有必要执行finalize()方法，那么这个对象将会放置在一个叫做F-Queue的队列之中，并在稍后由一个虚拟机自动建立的、优先级低的Finalizer线程去执行它。这里所谓的执行是指虚拟机会触发这个方法，但并不承诺会等待它运行结束，这样做的原因是：如果一个对象在finalize()方法中执行缓慢，或者发生了死循环，将很可能会导致F-Queue队列中其他对象永久处于等待，甚至导致整个内存回收系统崩溃。finalize()方法是对象 逃脱死亡命运的最后一次机会，稍后GC将对F-Queue中的对象进行第二次小规模的标记。 回收方法区 很多人认为方法区是没有垃圾收集的，Java虚拟机规范中确实说过可以不要求虚拟机方法区实现垃圾收集，而且在方法区中进行垃圾收集的性价比一般比较低：在堆中，尤其是在新生代中，常规应用进行一次垃圾收集一般可以回收70%-95%的空间，而永久代的垃圾收集效率远低于此。永久代的垃圾收集主要回收两部分内容：废弃常量和无用的类。回收废弃常量与回收Java堆中的对象非常类似。以常量池中字面量的回收为例：假如一个字符串”ABC”已经进入了常量池中，但是当前系统没有任何一个String对象是叫做”ABC”的，换句话说，就是没有任何String对象引用常量池中的”ABC”常量，也没有其他地方引用了这个字面量，如果这时繁盛内存回收，而且必要的话，这个”ABC”常量就会被系统清理出常量池，常量池中的其他类、方法、字段的符号引用也与此类似。判定一个常量是否是”废弃常量”比较简单，而要判定一个类是否是”无用的类”的条件则相对苛刻许多。类需要同时满足下面三个调教才能算是”无用的类”： 该类所有的实例都已经被回收，也就是Java堆中不存在该类的任何实例。 加载该类的ClassLoader已经被回收。 该类对用的java.lang.Class对象没有在任何对方被引用，无法在任何地方通过反射访问该类的方法。 虚拟机可以对满足上述3个条件的无用类进行回收，这里说的仅仅是“可以”，而并不是和对象一样，不使用了就必然会回收。 是否对类进行回收，HotSpot虚拟机提供了-Xnoclassgc参数进行控制，还可以使用-verbose：class以及-XX：+TraceClassLoading、 -XX：+TraceClassUnLoading查看类加载和卸载信息，其中-verbose：class和-XX：+TraceClassLoading可以在Product版的虚拟机中使用，-XX：+TraceClassUnLoading参数需要FastDebug版的虚拟机支持。在大量使用反射、 动态代理、 CGLib等ByteCode框架、 动态生成JSP以及OSGi这类频繁自定义ClassLoader的场景都需要虚拟机具备类卸载的功能，以保证永久代不会溢出。 以上]]></content>
      <tags>
        <tag>JVM</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Android N 应用内更新]]></title>
    <url>%2F2017%2F03%2F28%2FAndroid-N-%E5%BA%94%E7%94%A8%E5%86%85%E6%9B%B4%E6%96%B0%2F</url>
    <content type="text"><![CDATA[继之前跪在Android M的动态权限之后，最近又跪在了Android N的StrictMode上了。所以啊，要对技术持有敬畏的态度。场景如下：我司内部员工使用的APP需要有应用内更新的功能，意思就是在应用内下载最新版本的应用并且调起安装界面。方案：由于每次从新打开app都需要重新登录，那就在登录界面加上检查更新的接口请求，后台对比当前版本App的VersionCode 和 数据库存储的VersionCode对比，如果需要更新，则返回最新版本软件的下载地址，前端进行下载安装。当前端解析出下载地址后，弹出提示框，下载或者取消。点击下载则开启线程下载，同时在界面上显示下载进度，下载完成后，调起安装界面进行安装。代码很简单，这里放出不涉及我司业务的代码：1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950private void downLoadAPK() &#123; downLoadThread = new Thread(new Runnable() &#123; @Override public void run() &#123; try &#123; URL url = new URL(downLoadUrl); HttpURLConnection conn = (HttpURLConnection) url .openConnection(); conn.connect(); int length = conn.getContentLength(); InputStream is = conn.getInputStream(); File file = new File(""); if (!file.exists()) &#123; file.mkdir(); &#125; File apkFile = new File(saveFilePath); if (apkFile.exists()) &#123; apkFile.delete(); &#125; FileOutputStream fos = new FileOutputStream(apkFile); int count = 0; byte buf[] = new byte[1024]; // 点击取消就停止下载. while (!interceptFlag) &#123; int numread = is.read(buf); count += numread; progress = (int) (((float) count / length) * 100); // 更新进度 getHandler().sendEmptyMessage(DOWN_UPDATE); if (numread &lt;= 0) &#123; // 下载完成通知安装 getHandler().sendEmptyMessage(DOWN_OVER); interceptFlag = false; &#125; fos.write(buf, 0, numread); &#125; fos.close(); is.close(); &#125; catch (Exception e) &#123; e.printStackTrace(); &#125; &#125; &#125;); downLoadThread.start(); &#125; 以上为下载文件的代码，逻辑很简单，起一个新线程，使用HttpURLConnection进行文件下载。123456789private void installAPK(String filePath) &#123; File apkFile = new File(filePath); Intent intent = new Intent(Intent.ACTION_VIEW); if (!apkFile.exists()) &#123; return; &#125; intent.setDataAndType(Uri.fromFile(apkFile), "application/vnd.android.package-archive"); context.startActivity(intent);&#125; 以上代码是刚开始写的安装软件的代码，在Android N 以下运行正常，但是在Android N上却爆出了如下错误，12345678910111213141516171819android.os.FileUriExposedException: file: exposed beyond app through Intent.getData() at android.os.StrictMode.onFileUriExposed(StrictMode.java:1799) at android.net.Uri.checkFileUriExposed(Uri.java:2346) at android.content.Intent.prepareToLeaveProcess(Intent.java:8949) at android.content.Intent.prepareToLeaveProcess(Intent.java:8908) at android.app.Instrumentation.execStartActivity(Instrumentation.java:1519) at android.app.ContextImpl.startActivity(ContextImpl.java:829) at android.app.ContextImpl.startActivity(ContextImpl.java:806) at android.content.ContextWrapper.startActivity(ContextWrapper.java:366) at com.mmuu.travel.service.ui.LoginFrg.installAPK(LoginFrg.java:349) at com.mmuu.travel.service.ui.LoginFrg.access$200(LoginFrg.java:66) at com.mmuu.travel.service.ui.LoginFrg$1.onFinish(LoginFrg.java:134) at android.os.CountDownTimer$1.handleMessage(CountDownTimer.java:127) at android.os.Handler.dispatchMessage(Handler.java:102) at android.os.Looper.loop(Looper.java:154) at android.app.ActivityThread.main(ActivityThread.java:6114) at java.lang.reflect.Method.invoke(Native Method) at com.android.internal.os.ZygoteInit$MethodAndArgsCaller.run(ZygoteInit.java:874) at com.android.internal.os.ZygoteInit.main(ZygoteInit.java:764) 网上搜了一下，是Android N在权限上做了一些修改：参考链接 https://developer.android.google.cn/about/versions/nougat/android-7.0-changes.html 系统权限更改为了提高私有文件的安全性，面向 Android 7.0 或更高版本的应用私有目录被限制访问 (0700)。此设置可防止私有文件的元数据泄漏，如它们的大小或存在性。此权限更改有多重副作用：私有文件的文件权限不应再由所有者放宽，为使用 MODE_WORLD_READABLE 和/或 MODE_WORLD_WRITEABLE 而进行的此类尝试将触发 SecurityException。 注：迄今为止，这种限制尚不能完全执行。应用仍可能使用原生 API 或 File API 来修改它们的私有目录权限。但是，我们强烈反对放宽私有目录的权限。 传递软件包网域外的 file:// URI 可能给接收器留下无法访问的路径。因此，尝试传递 file:// URI 会触发 FileUriExposedException。分享私有文件内容的推荐方法是使用 FileProvider。DownloadManager 不再按文件名分享私人存储的文件。旧版应用在访问 COLUMN_LOCAL_FILENAME 时可能出现无法访问的路径。面向 Android 7.0 或更高版本的应用在尝试访问 COLUMN_LOCAL_FILENAME 时会触发 SecurityException。通过使用 DownloadManager.Request.setDestinationInExternalFilesDir() 或 DownloadManager.Request.setDestinationInExternalPublicDir() 将下载位置设置为公共位置的旧版应用仍可以访问 COLUMN_LOCAL_FILENAME 中的路径，但是我们强烈反对使用这种方法。对于由 DownloadManager 公开的文件，首选的访问方式是使用ContentResolver.openFileDescriptor()。 解决方案： FileProvider1.1 在mainfest中加入FileProvider注册123456789101112&lt;application&gt; &lt;provider android:authorities="你的应用名.fileprovider" android:name="android.support.v4.content.FileProvider" android:grantUriPermissions="true" android:exported="false"&gt; &lt;meta-data android:name="android.support.FILE_PROVIDER_PATHS" android:resource="@xml/filepaths"/&gt; &lt;/provider&gt;&lt;/application&gt; 1.2 在res文件夹下新建xml文件夹，在xml文件夹中新建filepaths文件，这个文件名字和上面的 Android:resource后面的名字要一致编辑该文件：123456&lt;?xml version="1.0" encoding="utf-8"?&gt;&lt;paths&gt; &lt;external-path name="external_storage_root" path="" /&gt;&lt;/paths&gt; 1.3 修改安装代码1234567891011121314151617private void installAPK(String filePath) &#123; File apkFile = new File(filePath); Intent intent = new Intent(Intent.ACTION_VIEW); if (!apkFile.exists()) &#123; return; &#125; if (Build.VERSION.SDK_INT &gt;= Build.VERSION_CODES.N) &#123; intent.setFlags(Intent.FLAG_GRANT_READ_URI_PERMISSION); Uri contentUri = FileProvider.getUriForFile(context, BuildConfig.APPLICATION_ID + ".fileProvider", apkFile); intent.setDataAndType(contentUri, "application/vnd.android.package-archive"); &#125; else &#123; intent.setDataAndType(Uri.fromFile(apkFile), "application/vnd.android.package-archive"); &#125; getActivity().getApplicationContext().startActivity(intent); context.finish(); &#125; 首先判断设备的Android版本，N或者N以上使用FileProvider进行安装，N一下还是原来的方式。注意调用startActivity要使用ApplicationContext，使用Activity.this会报错。 使用DownloadManager123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154public class ApkDownLoad &#123; public static final String DOWNLOAD_FOLDER_NAME = getLocalForderPath(); public static final String DOWNLOAD_FILE_NAME = "XXX.apk"; public static final String APK_DOWNLOAD_ID = "apkDownloadId"; private Context context; private String url; private String notificationTitle; private String notificationDescription; private DownloadManager downloadManager; private CompleteReceiver completeReceiver; /** * @param context * @param url 下载apk的url * @param notificationTitle 通知栏标题 * @param notificationDescription 通知栏描述 */ public ApkDownLoad(Context context, String url, String notificationTitle, String notificationDescription) &#123; super(); this.context = context; this.url = url; this.notificationTitle = notificationTitle; this.notificationDescription = notificationDescription; downloadManager = (DownloadManager) context .getSystemService(Context.DOWNLOAD_SERVICE); completeReceiver = new CompleteReceiver(); /** register download success broadcast **/ context.registerReceiver(completeReceiver, new IntentFilter( DownloadManager.ACTION_DOWNLOAD_COMPLETE)); &#125; public void execute() &#123; // 清除已下载的内容重新下载 long downloadId = UpdateUtils.getLong(context, APK_DOWNLOAD_ID); if (downloadId != -1) &#123; downloadManager.remove(downloadId); UpdateUtils.removeSharedPreferenceByKey(context, APK_DOWNLOAD_ID); &#125; Request request = new Request(Uri.parse(url)); // 设置Notification中显示的文字 request.setTitle(notificationTitle); request.setDescription(notificationDescription); // 设置可用的网络类型 request.setAllowedNetworkTypes(Request.NETWORK_MOBILE | Request.NETWORK_WIFI); // 设置状态栏中显示Notification request.setNotificationVisibility(DownloadManager.Request.VISIBILITY_VISIBLE_NOTIFY_COMPLETED); // 不显示下载界面 request.setVisibleInDownloadsUi(false); // 设置下载后文件存放的位置 File folder = Environment .getExternalStoragePublicDirectory(DOWNLOAD_FOLDER_NAME); if (!folder.exists() || !folder.isDirectory()) &#123; folder.mkdirs(); &#125; // 设置下载文件的保存路径 request.setDestinationInExternalPublicDir(DOWNLOAD_FOLDER_NAME, DOWNLOAD_FILE_NAME); // 设置文件类型 MimeTypeMap mimeTypeMap = MimeTypeMap.getSingleton(); String mimeString = mimeTypeMap.getMimeTypeFromExtension(MimeTypeMap .getFileExtensionFromUrl(url)); request.setMimeType(mimeString); // 保存返回唯一的downloadId UpdateUtils.putLong(context, APK_DOWNLOAD_ID, downloadManager.enqueue(request)); &#125; class CompleteReceiver extends BroadcastReceiver &#123; @Override public void onReceive(Context context, Intent intent) &#123; /** * get the id of download which have download success, if the id is * my id and it's status is successful, then install it **/ long completeDownloadId = intent.getLongExtra( DownloadManager.EXTRA_DOWNLOAD_ID, 0); long downloadId = UpdateUtils.getLong(context, APK_DOWNLOAD_ID); if (completeDownloadId == downloadId) &#123; // if download successful if (queryDownloadStatus(downloadManager, downloadId) == DownloadManager.STATUS_SUCCESSFUL) &#123; // clear downloadId UpdateUtils.removeSharedPreferenceByKey(context, APK_DOWNLOAD_ID); // unregisterReceiver context.unregisterReceiver(completeReceiver); // install apk String apkFilePath = new StringBuilder(Environment .getExternalStorageDirectory().getAbsolutePath()) .append(File.separator) .append(DOWNLOAD_FOLDER_NAME) .append(File.separator).append(DOWNLOAD_FILE_NAME) .toString(); install(context, apkFilePath); &#125; &#125; &#125; &#125; /** * 查询下载状态 */ public static int queryDownloadStatus(DownloadManager downloadManager, long downloadId) &#123; int result = -1; DownloadManager.Query query = new DownloadManager.Query() .setFilterById(downloadId); Cursor c = null; try &#123; c = downloadManager.query(query); if (c != null &amp;&amp; c.moveToFirst()) &#123; result = c.getInt(c .getColumnIndex(DownloadManager.COLUMN_STATUS)); &#125; &#125; finally &#123; if (c != null) &#123; c.close(); &#125; &#125; return result; &#125; /** * install app * * @param context * @param filePath * @return whether apk exist */ public static boolean install(Context context, String filePath) &#123; Intent i = new Intent(Intent.ACTION_VIEW); File file = new File(filePath); if (file != null &amp;&amp; file.length() &gt; 0 &amp;&amp; file.exists() &amp;&amp; file.isFile()) &#123; i.setDataAndType(Uri.parse("file://" + filePath), "application/vnd.android.package-archive"); i.addFlags(Intent.FLAG_ACTIVITY_NEW_TASK); context.startActivity(i); return true; &#125; return false; &#125;&#125; 检测到需要升级时 new ApkDownLoad().execute()就可以了，其中UpdateUtils.getLong()是一个SharedPreferences封装。以上两种方式在小米5Android N 上实测有效以上]]></content>
      <tags>
        <tag>Android</tag>
        <tag>Android爬坑之旅</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JVM内存区域]]></title>
    <url>%2F2017%2F03%2F27%2FJVM%E5%86%85%E5%AD%98%E5%8C%BA%E5%9F%9F%2F</url>
    <content type="text"><![CDATA[Java虚拟机在执行Java程序的过程中会把它所管理的内存划分为若干个不同的数据区域.这些区域都有各自的用途,以及创建和销毁的时间.有的区域随着虚拟机进程的启动而存在,有些区域则依赖用户线程的启动和结束而建立和销毁.根据《Java虚拟机规范(JavaSE 7版)》的规定,Java虚拟机所管理的内存将会包括以下几个运行时数据区域.如下所示: 程序计数器 程序计数器(Program Counter Register)是一块较小的内存空间,它可以看作是当前线程所执行的字节码的行号指示器.在虚拟机的概念模型里(仅是概念模型,各种虚拟机可能会通过一些更高效的方式去实现),字节码解释器工作时就是通过改变这个计数器的值来选取下一条需要执行的字节码指令,分支、循环、跳转、异常处理、线程恢复等基础功能都需要依赖这个计数器来完成.由于Java虚拟机的多线程是通过线程轮流切换并分配处理器执行时间的方式来实现的,在任何一个确定的时刻,一个处理器(对于多核处理器来说是一个内核)都只会执行一条线程中的指令.因此,为了线程切换后能恢复到正确的执行位置,每条线程都需要有一个独立的程序计数器,各条线程之间计数器互不影响,独立存储,我们称这类内存区域为”线程私有”的内存.如果线程正在执行的是一个Java方法,这个计数器记录的是正在执行的虚拟机字节码指令的地址;如果正在执行的是Native方法,这个计数器值则为空(Undefined).此内存区域是唯一一个在Java虚拟机规范中没有规定任何OutOfMemoryError情况的区域. Java虚拟机栈 与程序计数器一样,Java虚拟机栈(Java Virtual Machine Stacks)也是线程私有的,它的生命周期与线程相同.虚拟机栈描述的是Java方法执行的内存模型:每个方法在执行的同时都会创建一个栈帧(Stack Frame)用于存储局部变量表、操作数栈、动态链接、方法出口等信息.每一个方法从调用直至执行完成的过程,就对应着一个栈帧在虚拟机栈中入栈到出栈的过程.经常有人把Java内存区分为堆内存(Heap)和栈内存(Stack),这种分法比较粗糙,Java内存区域的划分实际上远比这复杂. 这种划分方式的流行只能说明大多数程序员最关注的、与对象内存分配关系最密切的内存区域是这两块.所指的”栈”就是现在讲的虚拟机栈,或者说是虚拟机栈中局部变量表部分.局部变量表存放了编译期可知的各种基本数据类型(boolean、byte、char、short、int、float、long、double)、对象引用(reference类型,它不等同于对象本身,可能是一个指向对象起始地址的引用指针,也可能是指向一个代表对象的句柄或其他与此对象相关的位置)和returnAddress类型(指向了一条字节码指令的地址).其中64位长度的long和double类型的数据会占用2个局部变量空间(Slot),其余的数据类型只占用1个. 局部变量表所需的内存空间在编译期间完成分配,当进入一个方法时,这个方法需要在帧中分配多大的局部变量空间是完全确定的,在方法运行期间不会改变局部变量表的大小.在Java虚拟机规范中,对这个区域规定了两种异常状况:如果线程请求的栈深度大于虚拟机所允许的深度,将抛出StackOverflowError异常;如果虚拟机栈可以动态扩展(当前大部分的Java虚拟机都可动态扩展,只不过Java虚拟机规范中也允许固定长度的虚拟机栈),如果扩展时无法申请到足够的内存,就会抛出OutOfMemoryError异常. 本地方法栈 本地方法栈(Native Method Stack)与虚拟机栈所发挥的作用是非常相似的,它们之间的区别不过是虚拟机栈为虚拟机执行Java方法(也就是字节码)服务,而本地方法栈则为虚拟机使用到的Native方法服务. 在虚拟机规范中对本地方法栈中方法使用的语言、 使用方式与数据结构并没有强制规定,因此具体的虚拟机可以自由实现它. 甚至有的虚拟机(譬如Sun HotSpot虚拟机)直接就把本地方法栈和虚拟机栈合二为一. 与虚拟机栈一样,本地方法栈区域也会抛出StackOverflowError和OutOfMemoryError异常. Java堆 对于大多数应用来说,Java堆(Java Heap)是Java虚拟机所管理的内存中最大的一块.Java堆是被所有线程共享的一块内存区域,在虚拟机启动时创建.此内存区域的唯一目的就是存放对象实例,几乎所有的对象实例都在这里分配内存.这一点在Java虚拟机规范中的描述是:所有的对象实例以及数组都要在堆上分配,但是随着JIT编译器的发展与逃逸分析技术逐渐成熟,栈上分配、标量替换优化技术将会导致一些微妙的变化发生,所有的对象都分配在堆上也渐渐变得不是那么”绝对”了.Java堆是垃圾收集器管理的主要区域,因此很多时候也被称做”GC堆”(Garbage Collected Heap).从内存回收的角度来看,由于现在收集器基本都采用分代收集算法,所以Java堆中还可以细分为:新生代和老年代;再细致一点的有Eden空间、From Survivor空间、To Survivor空间等.从内存分配的角度来看,线程共享的Java堆中可能划分出多个线程私有的分配缓冲区(Thread Local Allocation Buffer,TLAB).不过无论如何划分,都与存放内容无关,无论哪个区域,存储的都仍然是对象实例,进一步划分的目的是为了更好地回收内存,或者更快地分配内存.根据Java虚拟机规范的规定,Java堆可以处于物理上不连续的内存空间中,只要逻辑上是连续的即可,就像我们的磁盘空间一样.在实现时,既可以实现成固定大小的,也可以是可扩展的,不过当前主流的虚拟机都是按照可扩展来实现的(通过-Xmx和-Xms控制). 如果在堆中没有内存完成实例分配,并且堆也无法再扩展时,将会抛出OutOfMemoryError异常. 方法区 方法区(Method Area)与Java堆一样,是各个线程共享的内存区域,它用于存储已被虚拟机加载的类信息、常量、静态变量、即时编译器编译后的代码等数据.虽然Java虚拟机规范把方法区描述为堆的一个逻辑部分,但是它却有一个别名叫做Non-Heap(非堆),目的应该是与Java堆区分开来.对于习惯在HotSpot虚拟机上开发、 部署程序的开发者来说,很多人都更愿意把方法区称为”永久代”(Permanent Generation),本质上两者并不等价,仅仅是因为HotSpot虚拟机的设计团队选择把GC分代收集扩展至方法区,或者说使用永久代来实现方法区而已,这样HotSpot的垃圾收集器可以像管理Java堆一样管理这部分内存,能够省去专门为方法区编写内存管理代码的工作.对于其他虚拟机(如BEA JRockit、 IBM J9等)来说是不存在永久代的概念的.原则上,如何实现方法区属于虚拟机实现细节,不受虚拟机规范约束,但使用永久代来实现方法区,现在看来并不是一个好主意,因为这样更容易遇到内存溢出问题(永久代有-XX:MaxPermSize的上限,J9和JRockit只要没有触碰到进程可用内存的上限,例如32位系统中的4GB,就不会出现问题),而且有极少数方法(例如String.intern())会因这个原因导致不同虚拟机下有不同的表现. 因此,对于HotSpot虚拟机,根据官方发布的路线图信息,现在也有放弃永久代并逐步改为采用Native Memory来实现方法区的规划了,在目前已经发布的JDK1.7的HotSpot中,已经把原本放在永久代的字符串常量池移出.Java虚拟机规范对方法区的限制非常宽松,除了和Java堆一样不需要连续的内存和可以选择固定大小或者可扩展外,还可以选择不实现垃圾收集.相对而言,垃圾收集行为在这个区域是比较少出现的,但并非数据进入了方法区就如永久代的名字一样”永久”存在了.这区域的内存回收目标主要是针对常量池的回收和对类型的卸载,一般来说,这个区域的回收”成绩”比较难以令人满意,尤其是类型的卸载,条件相当苛刻,但是这部分区域的回收确实是必要的.根据Java虚拟机规范的规定,当方法区无法满足内存分配需求时,将抛出OutOfMemoryError异常. 运行时常量池 运行时常量池(Runtime Constant Pool)是方法区的一部分. Class文件中除了有类的版本、字段、方法、接口等描述信息外,还有一项信息是常量池(Constant Pool Table),用于存放编译期生成的各种字面量和符号引用,这部分内容将在类加载后进入方法区的运行时常量池中存放.Java虚拟机对Class文件每一部分(自然也包括常量池)的格式都有严格规定,每一个字节用于存储哪种数据都必须符合规范上的要求才会被虚拟机认可、装载和执行,但对于运行时常量池,Java虚拟机规范没有做任何细节的要求,不同的提供商实现的虚拟机可以按照自己的需要来实现这个内存区域.不过,一般来说,除了保存Class文件中描述的符号引用外,还会把翻译出来的直接引用也存储在运行时常量池中.运行时常量池相对于Class文件常量池的另外一个重要特征是具备动态性,Java语言并不要求常量一定只有编译期才能产生,也就是并非预置入Class文件中常量池的内容才能进入方法区运行时常量池,运行期间也可能将新的常量放入池中,这种特性被开发人员利用得比较多的便是String类的intern()方法.既然运行时常量池是方法区的一部分,自然受到方法区内存的限制,当常量池无法再申请到内存时会抛出OutOfMemoryError异常. 直接内存 直接内存(Direct Memory)并不是虚拟机运行时数据区的一部分,也不是Java虚拟机规范中定义的内存区域.但是这部分内存也被频繁地使用,而且也可能导致OutOfMemoryError异常出现,所以我们放到这里一起讲解.在JDK 1.4中新加入了NIO(New Input/Output)类,引入了一种基于通道(Channel)与缓冲区(Buffer)的I/O方式,它可以使用Native函数库直接分配堆外内存,然后通过一个存储在Java堆中的DirectByteBuffer对象作为这块内存的引用进行操作.这样能在一些场景中显著提高性能,因为避免了在Java堆和Native堆中来回复制数据.显然,本机直接内存的分配不会受到Java堆大小的限制,但是,既然是内存,肯定还是会受到本机总内存(包括RAM以及SWAP区或者分页文件)大小以及处理器寻址空间的限制.服务器管理员在配置虚拟机参数时,会根据实际内存设置-Xmx等参数信息,但经常忽略直接内存,使得各个内存区域总和大于物理内存限制(包括物理的和操作系统级的限制),从而导致动态扩展时出现OutOfMemoryError异常. 以上]]></content>
      <tags>
        <tag>JVM</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Android的消息机制]]></title>
    <url>%2F2017%2F03%2F23%2FAndroid%E7%9A%84%E6%B6%88%E6%81%AF%E6%9C%BA%E5%88%B6%2F</url>
    <content type="text"><![CDATA[Android消息机制主要是指Handler的运行机制，Handler的运行需要底层的MessageQueue和Looper的支撑。MessageQueue的中文翻译是消息队列，它的内部存储了一组消息，以队列的形式对外提供插入和删除的工作。虽然叫消息队列，但是它的内部存储结构并不是真正的队列，而是采用单链表的数据结构来存储消息队列。Looper可以理解为消息循环。由于MessageQueue只是一个消息的存储单元，它不能去处理消息，而Looper就填补了这个功能，Looper会以无限循环的形式去查找是否有新消息，如果有的话就处理消息，否则就等待。Looper中还有一个特殊的概念：ThreadLocal，ThreadLocal并不是线程，它的作用是可以在每个线程中存储数据。Handler创建的时候会采用当前线程的Looper来构造消息循环系统，ThreadLocal可以在不同的线程中互不干扰的存储并提供数据，Handler可以通过ThreadLocal轻松获取每个线程的Looper。需要注意的是，线程默认是没有Looper的，如果需要使用Handler就必须为现成创建Looper，我们经常提到的主线程，也叫UI线程，它就是ActivityThread，ActivityThread被创建时就会初始化Looper，这也是在主线程中默认可以使用Handler的原因。 ThreadLocal的工作原理ThreadLocal是一个线程内部的数据存储类，通过它可以在指定的线程中存储数据，数据存储以后，只能在指定的线程中才可以获取到存储的数据，对于其他线程来说则无法获取到，我们在使用的时候：1234567891011121314151617final ThreadLocal&lt;Boolean&gt; mBooleanThreadLocal = new ThreadLocal&lt;&gt;(); new Thread("Thread#1")&#123; @Override public void run() &#123; mBooleanThreadLocal.set(false); Log.d("huangyuan","Thread#1" + mBooleanThreadLocal.get()); &#125; &#125;.start(); new Thread("Thread#2")&#123; @Override public void run() &#123; mBooleanThreadLocal.set(true); Log.d("huangyuan","Thread#2" + mBooleanThreadLocal.get()); &#125; &#125;.start(); 这样，我们虽然在不同的线程中访问的是同一个ThreadLocal对象，但是他们的值却是不一样的。这是因为不同的线程访问同一个ThreadLocal的get方法，ThreadLocal内部会从各自的线程中取出一个数组，然后再从数组中根据当前ThreadLocal的索引去查找出对应的value值。ThreadLocal是一个泛型类，定义为public class ThreadLocal&lt;T&gt;,首先看ThreadLocal的set方法，如下：12345678public void set(T value) &#123; Thread t = Thread.currentThread(); ThreadLocalMap map = getMap(t); if (map != null) map.set(this, value); else createMap(t, value); &#125; 上面的方法中，首先会通过getMap方法获取ThreadLocalMap（存储线程的ThreadLocal数据），ThreadLocalMap是ThreadLocal类的静态内部类，其内部包含了一个静态内部类Entry，声明如下static class Entry extends WeakReference&lt;ThreadLocal&gt;,ThreadLocalMap类中有一个Entry类型的数组private Entry[] table;,下面是set方法的具体实现：1234567891011121314151617181920212223242526272829303132private void set(ThreadLocal key, Object value) &#123; // We don't use a fast path as with get() because it is at // least as common to use set() to create new entries as // it is to replace existing ones, in which case, a fast // path would fail more often than not. Entry[] tab = table; int len = tab.length; int i = key.threadLocalHashCode &amp; (len-1); for (Entry e = tab[i]; e != null; e = tab[i = nextIndex(i, len)]) &#123; ThreadLocal k = e.get(); if (k == key) &#123; e.value = value; return; &#125; if (k == null) &#123; replaceStaleEntry(key, value, i); return; &#125; &#125; tab[i] = new Entry(key, value); int sz = ++size; if (!cleanSomeSlots(i, sz) &amp;&amp; sz &gt;= threshold) rehash(); &#125; ThreadLocal的get方法如下：12345678910public T get() &#123; Thread t = Thread.currentThread(); ThreadLocalMap map = getMap(t); if (map != null) &#123; ThreadLocalMap.Entry e = map.getEntry(this); if (e != null) return (T)e.value; &#125; return setInitialValue(); &#125; 从ThreadLocal的set和get方法可以看出，他们所操作的对象都是当前线程的ThreadLocalMap对象的table数组，因此在不同线程中访问同一个ThreadLocal的set和get方法，他们对ThreadLocal所做的读写操作仅限于各自线程的内部，这就是为什么ThreadLocal可以在多个线程中互不干扰的存储和修改数据。 消息队列的工作原理 消息队列在Android中指的是MessageQueue，MessageQueue主要包含两个操作，插入和读取。读取操作本身会伴随着删除操作，插入和读取对应的方法分别为enqueueMessage和next，其中enqueueMessage的作用是往消息队列中插入一跳消息，而next的作用是从消息队列中取出一条消息并将其从消息队列中移除，尽管MessageQueue叫消息队列，但是它的内部实现并不是用的队列，实际上它是通过一个单链表的数据结构来维护消息列表，单链表在插入和删除上比较有优势。下面是enqueueMessage的实现：1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253boolean enqueueMessage(Message msg, long when) &#123; if (msg.target == null) &#123; throw new IllegalArgumentException("Message must have a target."); &#125; if (msg.isInUse()) &#123; throw new IllegalStateException(msg + " This message is already in use."); &#125; synchronized (this) &#123; if (mQuitting) &#123; IllegalStateException e = new IllegalStateException( msg.target + " sending message to a Handler on a dead thread"); Log.w(TAG, e.getMessage(), e); msg.recycle(); return false; &#125; msg.markInUse(); msg.when = when; Message p = mMessages; boolean needWake; if (p == null || when == 0 || when &lt; p.when) &#123; // New head, wake up the event queue if blocked. msg.next = p; mMessages = msg; needWake = mBlocked; &#125; else &#123; // Inserted within the middle of the queue. Usually we don't have to wake // up the event queue unless there is a barrier at the head of the queue // and the message is the earliest asynchronous message in the queue. needWake = mBlocked &amp;&amp; p.target == null &amp;&amp; msg.isAsynchronous(); Message prev; for (;;) &#123; prev = p; p = p.next; if (p == null || when &lt; p.when) &#123; break; &#125; if (needWake &amp;&amp; p.isAsynchronous()) &#123; needWake = false; &#125; &#125; msg.next = p; // invariant: p == prev.next prev.next = msg; &#125; // We can assume mPtr != 0 because mQuitting is false. if (needWake) &#123; nativeWake(mPtr); &#125; &#125; return true; &#125; 从其实现来安，主要操作其实就是单链表的插入操作。next的实现如下：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105Message next() &#123; // Return here if the message loop has already quit and been disposed. // This can happen if the application tries to restart a looper after quit // which is not supported. final long ptr = mPtr; if (ptr == 0) &#123; return null; &#125; int pendingIdleHandlerCount = -1; // -1 only during first iteration int nextPollTimeoutMillis = 0; for (;;) &#123; if (nextPollTimeoutMillis != 0) &#123; Binder.flushPendingCommands(); &#125; nativePollOnce(ptr, nextPollTimeoutMillis); synchronized (this) &#123; // Try to retrieve the next message. Return if found. final long now = SystemClock.uptimeMillis(); Message prevMsg = null; Message msg = mMessages; if (msg != null &amp;&amp; msg.target == null) &#123; // Stalled by a barrier. Find the next asynchronous message in the queue. do &#123; prevMsg = msg; msg = msg.next; &#125; while (msg != null &amp;&amp; !msg.isAsynchronous()); &#125; if (msg != null) &#123; if (now &lt; msg.when) &#123; // Next message is not ready. Set a timeout to wake up when it is ready. nextPollTimeoutMillis = (int) Math.min(msg.when - now, Integer.MAX_VALUE); &#125; else &#123; // Got a message. mBlocked = false; if (prevMsg != null) &#123; prevMsg.next = msg.next; &#125; else &#123; mMessages = msg.next; &#125; msg.next = null; if (DEBUG) Log.v(TAG, "Returning message: " + msg); msg.markInUse(); return msg; &#125; &#125; else &#123; // No more messages. nextPollTimeoutMillis = -1; &#125; // Process the quit message now that all pending messages have been handled. if (mQuitting) &#123; dispose(); return null; &#125; // If first time idle, then get the number of idlers to run. // Idle handles only run if the queue is empty or if the first message // in the queue (possibly a barrier) is due to be handled in the future. if (pendingIdleHandlerCount &lt; 0 &amp;&amp; (mMessages == null || now &lt; mMessages.when)) &#123; pendingIdleHandlerCount = mIdleHandlers.size(); &#125; if (pendingIdleHandlerCount &lt;= 0) &#123; // No idle handlers to run. Loop and wait some more. mBlocked = true; continue; &#125; if (mPendingIdleHandlers == null) &#123; mPendingIdleHandlers = new IdleHandler[Math.max(pendingIdleHandlerCount, 4)]; &#125; mPendingIdleHandlers = mIdleHandlers.toArray(mPendingIdleHandlers); &#125; // Run the idle handlers. // We only ever reach this code block during the first iteration. for (int i = 0; i &lt; pendingIdleHandlerCount; i++) &#123; final IdleHandler idler = mPendingIdleHandlers[i]; mPendingIdleHandlers[i] = null; // release the reference to the handler boolean keep = false; try &#123; keep = idler.queueIdle(); &#125; catch (Throwable t) &#123; Log.wtf(TAG, "IdleHandler threw exception", t); &#125; if (!keep) &#123; synchronized (this) &#123; mIdleHandlers.remove(idler); &#125; &#125; &#125; // Reset the idle handler count to 0 so we do not run them again. pendingIdleHandlerCount = 0; // While calling an idle handler, a new message could have been delivered // so go back and look again for a pending message without waiting. nextPollTimeoutMillis = 0; &#125; &#125; 可以返现next方法是一个无限循环的方法，如果消息队列为空，那么next方法会一直阻塞在这里，当有消息到来时，next方法会返回这条消息并将其从单链表中移除 Looper的工作原理 Looper在Android的消息机制中扮演者消息循环的角色，具体来说就是它会不停地从MessageQueue中查看是否有新消息，如果有新消息就会立刻处理，否则就一直阻塞在那里。首先看一下它的构造方法，在构造中它会创建一个MessageQueue也就是消息队列，然后将当前线程的对象保存起来，如下：1234private Looper(boolean quitAllowed) &#123; mQueue = new MessageQueue(quitAllowed); mThread = Thread.currentThread(); &#125; Handler的工作需要Looper，没有Looper的线程就会报错，我们可以通过Looper.prepare()即可为当前线程创建一个Looper，接着通过Looper.loop()来开启消息循环。Looper除了prepare方法外，还提供了prepareMainLoop方法，这个方法主要是给主线程也就是ActivityThread创建Looper使用的，其本质也是通过prepare方法来实现的。由于主线程的Looper比较特殊，所以Looper提供了一个getMainLooper方法，通过它可以在任何地方获取到主线程的Looper。Looper也是可以退出的，Looper提供了quit和quitSafely来退出一个Looper，二者的区别是：quit会直接突出Looper，而quitSafely只是设定一个退出标记，然后把消息队列中的已有消息处理完毕后才安全的退出。Looper退出后，通过Handler发送的消息会失败，这个时候Handler的send方法会返回false。在子线程中，如果手动为其创建了Looper，那么在所有的事情完成以后应该调用quit方法来总之消息循环，否则这个子线程就会一直处于等待的状态，而如果退出Looper以后，这个线程就会立刻终止，因此建议不需要的时候终止Looper。 Looper最重要的一个方法是loop方法，只有调用了loop后，消息循环系统才会真正的起作用，实现如下： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960/** * Run the message queue in this thread. Be sure to call * &#123;@link #quit()&#125; to end the loop. */ public static void loop() &#123; final Looper me = myLooper(); if (me == null) &#123; throw new RuntimeException("No Looper; Looper.prepare() wasn't called on this thread."); &#125; final MessageQueue queue = me.mQueue; // Make sure the identity of this thread is that of the local process, // and keep track of what that identity token actually is. Binder.clearCallingIdentity(); final long ident = Binder.clearCallingIdentity(); for (;;) &#123; Message msg = queue.next(); // might block if (msg == null) &#123; // No message indicates that the message queue is quitting. return; &#125; // This must be in a local variable, in case a UI event sets the logger final Printer logging = me.mLogging; if (logging != null) &#123; logging.println("&gt;&gt;&gt;&gt;&gt; Dispatching to " + msg.target + " " + msg.callback + ": " + msg.what); &#125; final long traceTag = me.mTraceTag; if (traceTag != 0) &#123; Trace.traceBegin(traceTag, msg.target.getTraceName(msg)); &#125; try &#123; msg.target.dispatchMessage(msg); &#125; finally &#123; if (traceTag != 0) &#123; Trace.traceEnd(traceTag); &#125; &#125; if (logging != null) &#123; logging.println("&lt;&lt;&lt;&lt;&lt; Finished to " + msg.target + " " + msg.callback); &#125; // Make sure that during the course of dispatching the // identity of the thread wasn't corrupted. final long newIdent = Binder.clearCallingIdentity(); if (ident != newIdent) &#123; Log.wtf(TAG, "Thread identity changed from 0x" + Long.toHexString(ident) + " to 0x" + Long.toHexString(newIdent) + " while dispatching to " + msg.target.getClass().getName() + " " + msg.callback + " what=" + msg.what); &#125; msg.recycleUnchecked(); &#125; &#125; loop方法是一个死循环，唯一跳出循环的方式是MessageQueue的next方法返回了null，当Looper的quit方法被调用时，Looper就会通知消息队列退出，当消息队列被标记为退出状态时，它的next方法就会返回null，也就是说，Looper必须退出，否则loop方法就会无限循环下去，loop方法会调用MessageQueue的next方法来获取新消息，而next方法是一个阻塞操作，当没有消息时，next方法会一直阻塞在那里，这也导致loop方法一直阻塞在那里，如果MessageQueue的next方法返回了新消息，Looper就会处理这条消息， msg.target.dispatchMessage(msg)，这里的 msg.target是发送这条消息的handler对象，这样Handler发送的消息最终又交个它的 dispatchMessage(msg);方法来处理了，但是这里不同的是，Handler的dispatchMessage方法是在创建Handler时所使用的Looper中执行的，这样就成功的将代码逻辑切换到指定的线程中去执行了。 Handler的工作原理 Handler的工作主要包含消息的发送和接收过程。消息的发送可以通过post的一系列方法以及send的一系列方法来实现，post的一系列方法最终是通过send的一列方法来实现的。发送一条消息的典型过程如下： 12345678910111213141516171819202122232425262728 public final boolean sendMessage(Message msg) &#123; return sendMessageDelayed(msg, 0); &#125;public final boolean sendMessageDelayed(Message msg, long delayMillis) &#123; if (delayMillis &lt; 0) &#123; delayMillis = 0; &#125; return sendMessageAtTime(msg, SystemClock.uptimeMillis() + delayMillis); &#125;public boolean sendMessageAtTime(Message msg, long uptimeMillis) &#123; MessageQueue queue = mQueue; if (queue == null) &#123; RuntimeException e = new RuntimeException( this + " sendMessageAtTime() called with no mQueue"); Log.w("Looper", e.getMessage(), e); return false; &#125; return enqueueMessage(queue, msg, uptimeMillis); &#125;private boolean enqueueMessage(MessageQueue queue, Message msg, long uptimeMillis) &#123; msg.target = this; if (mAsynchronous) &#123; msg.setAsynchronous(true); &#125; return queue.enqueueMessage(msg, uptimeMillis); &#125; 可以发现，Handler发送消息的过程仅仅是向消息队列中插入了一条消息，MessageQueue的next方法就会返回这条消息给Looper，Looper收到消息后就开始处理了，最终消息由Looper交由Handler处理，即Handler的dispatchMessage方法会被调用，这时Handler就是进入了处理消息的阶段。dispatchMessage的实现如下： 123456789101112public void dispatchMessage(Message msg) &#123; if (msg.callback != null) &#123; handleCallback(msg); &#125; else &#123; if (mCallback != null) &#123; if (mCallback.handleMessage(msg)) &#123; return; &#125; &#125; handleMessage(msg); &#125;&#125; Handler处理消息的过程如下： 检查Message的callback是否为null，不为null就通过handleCallback来处理消息，Message的callback是一个Runnable对象，实际上就是Handler的post方法所传递的Runnable参数。handleCallback的逻辑如下： 123private static void handleCallback(Message message) &#123; message.callback.run(); &#125; 其次，检查mCallback是否为null，不为null就调用没CallBack的HandlerMessage方法来处理消息，Callback是个接口，它的定义如下： /** * Callback interface you can use when instantiating a Handler to avoid * having to implement your own subclass of Handler. * * @param msg A {@link android.os.Message Message} object * @return True if no further handling is desired */ public interface Callback { public boolean handleMessage(Message msg); } 通过Callback可以采用如下方式来创建Handler对象：Handler handler = new Handler(callback)。 最后，调用Handler的handleMessahe方法来处理消息。 以上]]></content>
      <tags>
        <tag>Android</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Window和WindowManager]]></title>
    <url>%2F2017%2F03%2F21%2FWindow%E5%92%8CWindowManager%2F</url>
    <content type="text"><![CDATA[Window表示一个窗口的概念，在日常开发中直接接触WIndow的机会并不对，再试在某些特殊时候我们需要在桌面上显示一个类似悬浮窗的东西，那么这种效果就需要用到Window来实现。 Window只是个抽象类，它的具体实现是PhoneWindow。创建一个Window是很简单的事，只需要通过WindowManager即可完成，WindowManager是外界访问Window的入口，Window的具体实现位于WindowMangerService中，WindowMnager和WWindowMangerService的交互是一个IPC过程，Android中所有的视图都是通过Window来呈现的，不管是Activity、Dialog还是Toast，它们的视图实际上都是附加在Window上的，因此Window实际是View的直接管理者。 Window的内部机制 Window是一个抽象的概念，每一个Window都对应着一个View和一个ViewRootImpl，Window和View通过ViewRootImpl来建立联系，因此Window并不是实际存在的，它是以View的形式存在，。这点从WindowManager的定义也可以看出，它提供的三个接口方法addView,updateViewLayout以及removeView都是针对View，这说明View才是Window存在的实体。在实际使用中无法直接访问Window，对Window的访问必须通过WindowManger。 Window的添加过程 Window的添加过程需要通过WindowManager的addView来实现，WindowManager是一个接口，它的真正实现是WindowManagerImpl类，在WindowManagerImpl中Window的三大操作实现如下：123456789101112131415161718192021@Override public void addView(@NonNull View view, @NonNull ViewGroup.LayoutParams params) &#123; applyDefaultToken(params); mGlobal.addView(view, params, mContext.getDisplay(), mParentWindow); &#125; @Override public void updateViewLayout(@NonNull View view, @NonNull ViewGroup.LayoutParams params) &#123; applyDefaultToken(params); mGlobal.updateViewLayout(view, params); &#125;@Override public void removeView(View view) &#123; mGlobal.removeView(view, false); &#125; @Override public void removeViewImmediate(View view) &#123; mGlobal.removeView(view, true); &#125; WindowManagerImpl并没有直接实现Window的三大操作，而是全部交给了WindowManagerGlobal来处理，WindowManagerGlobal以工厂的形式向外提供自己的实现，WindowManagerImpl这种工作模式是典型的桥接模式，将所有的操作全部委托给WindowManagerGlobal来实现。在WindowManagerGlobal的addView方法主要分为如下几步： 检查参数是否合法，如果是子Window，那么还需要调整一些布局参数。 1234567891011121314151617181920212223242526public void addView(View view, ViewGroup.LayoutParams params, Display display, Window parentWindow) &#123; if (view == null) &#123; throw new IllegalArgumentException("view must not be null"); &#125; if (display == null) &#123; throw new IllegalArgumentException("display must not be null"); &#125; if (!(params instanceof WindowManager.LayoutParams)) &#123; throw new IllegalArgumentException("Params must be WindowManager.LayoutParams"); &#125; final WindowManager.LayoutParams wparams = (WindowManager.LayoutParams) params; if (parentWindow != null) &#123; parentWindow.adjustLayoutParamsForSubWindow(wparams); &#125; else &#123; // If there's no parent, then hardware acceleration for this view is // set from the application's hardware acceleration setting. final Context context = view.getContext(); if (context != null &amp;&amp; (context.getApplicationInfo().flags &amp; ApplicationInfo.FLAG_HARDWARE_ACCELERATED) != 0) &#123; wparams.flags |= WindowManager.LayoutParams.FLAG_HARDWARE_ACCELERATED; &#125; &#125;&#125; 创建ViewRootImpl并将View添加到列表中。在WindowManagerGlobal内部有如下几个列表比较重要： 12345private final ArrayList&lt;View&gt; mViews = new ArrayList&lt;View&gt;(); private final ArrayList&lt;ViewRootImpl&gt; mRoots = new ArrayList&lt;ViewRootImpl&gt;(); private final ArrayList&lt;WindowManager.LayoutParams&gt; mParams = new ArrayList&lt;WindowManager.LayoutParams&gt;(); private final ArraySet&lt;View&gt; mDyingViews = new ArraySet&lt;View&gt;(); 在以上声明中，mView存储的是多有WIndow所对应的View,mRoots存储的是所有Window所对应的ViewRootImpl，mParams存储的是所有Window所对应的布局参数，而mDyingView则存储了那些正在被删除的View对象，或者说是那些已经调用removeView方法但是删除操作还未完成的Window对象，在addView中通过如下方式将Window的一系列对象添加到列表中：12345root = new ViewRootImpl(view.getContext(), display); view.setLayoutParams(wparams); mViews.add(view); mRoots.add(root); mParams.add(wparams); 通过ViewRootImpl来更新界面并完成Window的添加过程。这个过程由ViewRootImpl的setView方法来完成：12345678910111213// do this last because it fires off messages to start doing things try &#123; root.setView(view, wparams, panelParentView); &#125; catch (RuntimeException e) &#123; // BadTokenException or InvalidDisplayException, clean up. synchronized (mLock) &#123; final int index = findViewLocked(view, false); if (index &gt;= 0) &#123; removeViewLocked(index, true); &#125; &#125; throw e; &#125; 在setView内部会通过requestLayout来完成异步刷新请求。在下面的代码中，scheduleTraversals实际是View绘制的入口：12345678@Override public void requestLayout() &#123; if (!mHandlingLayoutInLayoutRequest) &#123; checkThread(); mLayoutRequested = true; scheduleTraversals(); &#125; &#125; 接着会通过WindowSession最终来完成Window的添加过程。 Window的删除过程Window的删除过程和添加过程一样，都是先通过WindowManagerImpl后，再进一步通过WindowManagerGlobal来实现的，如下：1234567891011121314151617public void removeView(View view, boolean immediate) &#123; if (view == null) &#123; throw new IllegalArgumentException("view must not be null"); &#125; synchronized (mLock) &#123; int index = findViewLocked(view, true); View curView = mRoots.get(index).getView(); removeViewLocked(index, immediate); if (curView == view) &#123; return; &#125; throw new IllegalStateException("Calling with view " + view + " but the ViewAncestor is attached to " + curView); &#125; &#125; removeView的逻辑很清晰，首先通过findViewLocked来查找待删除的View的索引，这个查找过程就是建立的数据遍历，然后再通过调用removeViewLocked来做进一步的删除，如下：123456789101112131415161718private void removeViewLocked(int index, boolean immediate) &#123; ViewRootImpl root = mRoots.get(index); View view = root.getView(); if (view != null) &#123; InputMethodManager imm = InputMethodManager.getInstance(); if (imm != null) &#123; imm.windowDismissed(mViews.get(index).getWindowToken()); &#125; &#125; boolean deferred = root.die(immediate); if (view != null) &#123; view.assignParent(null); if (deferred) &#123; mDyingViews.add(view); &#125; &#125; &#125; removeViewLocked是通过ViewRootImpl来完成删除操作的，在WindowManager中提供了两种删除接口removeView和removeViewImmediate,它们分别表示异步删除和同步删除，一般不需要使用removeViewImmediate这个方法。这里主要说异步删除的情况：具体的删除操作由ViewRootImpl的die方法来完成，在异步删除的情况下，die方法只是发送了一个请求删除的消息后就立刻返回了，这个时候View并没有完成删除操作，所以最后会将其添加到mDyingView中。ViewRootImpl的die方法如下：1234567891011121314151617boolean die(boolean immediate) &#123; // Make sure we do execute immediately if we are in the middle of a traversal or the damage // done by dispatchDetachedFromWindow will cause havoc on return. if (immediate &amp;&amp; !mIsInTraversal) &#123; doDie(); return false; &#125; if (!mIsDrawing) &#123; destroyHardwareRenderer(); &#125; else &#123; Log.e(mTag, "Attempting to destroy the window while drawing!\n" + " window=" + this + ", title=" + mWindowAttributes.getTitle()); &#125; mHandler.sendEmptyMessage(MSG_DIE); return true; &#125; 在die方法中只是做了简单的判断，如果是异步删除，那么就发送一个MSG_DIE的消息，ViewRootImpl中的Handler会处理此消息并调用doDie方法，如果是同步删除，那么就不发送消息直接调用doDie方法。在doDie内部会调用dispatchDetachedFromWindow方法，真正删除View的逻辑在dispatchDetachedFromWindow方法内部实现。dispatchDetachedFromWindow方法主要做四件事： 垃圾回收相关的工作，比如清除数据和消息，移除回调等。 通过Session的remove方法删除Window：mWindowSession.remove(mWindow)，这同样是一个IPC过程，最终会调用WindowManagerService的removeWindow方法。 调用View的dispatchDetachedFromWindow方法，在内部会调用View的onDetachedFromWindow以及onDetachedFromWindowInternal()。 调用WindowManagerGlobal的doRemoveView方法刷新数据，包括mRoots、mParams以及mDyingViews，需要将当前Window锁关联的这三类对象从列表中删除。Window的更新过程1234567891011121314151617181920public void updateViewLayout(View view, ViewGroup.LayoutParams params) &#123; if (view == null) &#123; throw new IllegalArgumentException("view must not be null"); &#125; if (!(params instanceof WindowManager.LayoutParams)) &#123; throw new IllegalArgumentException("Params must be WindowManager.LayoutParams"); &#125; final WindowManager.LayoutParams wparams = (WindowManager.LayoutParams)params; view.setLayoutParams(wparams); synchronized (mLock) &#123; int index = findViewLocked(view, true); ViewRootImpl root = mRoots.get(index); mParams.remove(index); mParams.add(index, wparams); root.setLayoutParams(wparams, false); &#125; &#125; 首先它需要更新View的LayoutParams并替换掉老的LayoutParams，接着再更新ViewRootImpl中的layoutParams，这一步是通过ViewRootImpl的setLayoutParams方法来实现的。在ViewRootImpl中会通过scheduleTraversals方法来对View重新布局，包括测量、布局、重绘这三个过程，除了View本身的重绘以外，ViewRootImpl还会通过WindowSession开更新Window的视图，这个过程最终是由WindowManagerService的relayoutWindow()来具体实现，它同样是一个IPC的过程。 以上]]></content>
      <tags>
        <tag>Android</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[简单的桌面小部件]]></title>
    <url>%2F2017%2F03%2F20%2F%E7%AE%80%E5%8D%95%E7%9A%84%E6%A1%8C%E9%9D%A2%E5%B0%8F%E9%83%A8%E4%BB%B6%2F</url>
    <content type="text"><![CDATA[实现一个简单的桌面小部件，响应点击事件，更新等功能。 定义小部件界面 定义小部件配置信息 定义小部件的实现类 声明小部件在AndroidStudio中只需要在main\java下新建一个widget,就可以了，IDE会自动在res\layout添加布局文件，在res\xml下新建配置信息文件。然后就可以进行具体实现了。 定义小部件界面RemoteView目前并不能支持所有的View，现在支持的类型如下： Layout FrameLayout LinearLayout RelativeLayout GridLayout View AnalogClock Button Chronometer ImageButton ImageView ProgressBar TextView ViewFlipper ListView GridView StackView AdapterViewFlipper ViewStub 这个没什么好说的，按照写界面布局的方式写就好了，但是不建议写过于复杂的布局。 定义小部件配置信息下面的代码就是IDE自动成的配置信息文件，不喜欢IDE代劳的同学可以自己创建。12345678910&lt;?xml version="1.0" encoding="utf-8"?&gt;&lt;appwidget-provider xmlns:android="http://schemas.android.com/apk/res/android" android:initialKeyguardLayout="@layout/test_remote_view_widget" android:initialLayout="@layout/test_remote_view_widget" android:minHeight="40dp" android:minWidth="40dp" android:previewImage="@drawable/example_appwidget_preview" android:resizeMode="horizontal|vertical" android:updatePeriodMillis="86400000" android:widgetCategory="home_screen"&gt;&lt;/appwidget-provider&gt; initialLayout：布局文件previewImage： 预览的图片updatePeriodMillis：刷新周期，单位毫秒 定义小部件的实现类实现的功能是当点击这个小部件的时候改变文字内容12345678910111213141516171819202122232425public class TestRemoteViewWidget extends AppWidgetProvider &#123; private static final String CLICK_ACTION = "com.huangyuan.testwidget.TAP_CLICK_ACTION"; @Override public void onReceive(Context context, Intent intent) &#123; super.onReceive(context, intent); Toast.makeText(context,"onReceive:" + intent.getAction(),Toast.LENGTH_SHORT).show(); if(intent.getAction().equals(CLICK_ACTION))&#123; AppWidgetManager appWidgetManager = AppWidgetManager.getInstance(context); RemoteViews remoteViews = new RemoteViews(context.getPackageName(),R.layout.test_remote_view_widget); remoteViews.setTextViewText(R.id.appwidget_text,"点击"); appWidgetManager.updateAppWidget(new ComponentName(context,TestRemoteViewWidget.class),remoteViews); &#125; &#125; @Override public void onUpdate(Context context, AppWidgetManager appWidgetManager, int[] appWidgetIds) &#123; Toast.makeText(context,"onUpdate" ,Toast.LENGTH_SHORT).show(); RemoteViews remoteViews = new RemoteViews(context.getPackageName(),R.layout.test_remote_view_widget); Intent clickIntent = new Intent(); clickIntent.setAction(CLICK_ACTION); PendingIntent pendingIntent = PendingIntent.getBroadcast(context,0,clickIntent,0); remoteViews.setOnClickPendingIntent(R.id.appwidget_text,pendingIntent); appWidgetManager.updateAppWidget(appWidgetIds,remoteViews); &#125;&#125; 其中还有其他方法： onEnabled:当该窗口小部件第一次添加到桌面时调用该方法，可添加多次，但只在第一次调用 onUpdate:小部件被添加时或者每次小部件更新时都会调用一次该方法，小部件的更新时机由updatePeriodMillis指定。 onDeleted:每删除一次桌面小部件就调用一次。 onDisabled:当最后一个该类型的桌面小部件被删除时调用该方法，追时最后一个。需要注意的是，更新remoteView时，不能直接访问里面的View,需要通过RemoteView所提供的一系列方法更新View。 更新文本： remoteViews.setTextViewText(); 更新图片： remoteViews.setImageViewResource();remoteViews.setImageViewBitmap(); 添加单击事件：remoteViews.setOnClickPendingIntent();]]></content>
      <tags>
        <tag>Android</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[通过简单的自定义view来看View的工作流程]]></title>
    <url>%2F2017%2F03%2F18%2F%E9%80%9A%E8%BF%87%E7%AE%80%E5%8D%95%E7%9A%84%E8%87%AA%E5%AE%9A%E4%B9%89view%E6%9D%A5%E7%9C%8BView%E7%9A%84%E5%B7%A5%E4%BD%9C%E6%B5%81%E7%A8%8B%2F</url>
    <content type="text"><![CDATA[通过简单的自定义View(画个圆)，来了解一下View的工作流程以及自定义View应该注意的地方。 一、自定义View的分类1.1 继承View重写onDraw方法这种方法主要用于实现一些不规则的效果，比如动态或者静态显示一些不规则的图形，采用这种方式需要自己支持wrap_content,并且padding需要自己处理. 1.2 继承ViewGroup派生特殊的Layout这种方式主要用于实现自定义布局，如流式布局。采用这种方式需要合适的处理ViewGroup的测量、布局这两个过程，并同时处理子元素的测量和布局过程。 1.3 继承特定的View(如TextView)这种方法一般用于扩展某种已有的View的功能，比如TextView，这种方法比较容易实现，不需要自己支持wrap_content和padding。 1.4 继承特定的ViewGroup采用这种方式不需要自己处理ViewGroup的测量和布局这两个过程。 二、值得注意的地方2.1 让View支持wrap_content这是因为直接继承View或者ViewGroup的控件，如果不在onMeasure中对wrap_content做特殊处理，那么当外界在适用wrap_content时就无法达到预期的效果。 2.2 如果有必要，让View支持padding这是因为如果直接继承View，如果不在draw方法中处理padding，那么padding属性是无法起作用的。另外，直接继承自ViewGroup的控件需要在onMeasure和onLayout中考虑padding和子元素的margin对其造成的影响，不然将导致padding和子元素的margin失效。 2.3 尽量不要在View中使用Handler，没必要因为View内部本身就提供了post系列的方法， 完全可以替代Handler的作用，当然除非你很明确要使用Handler来发送消息 2.4 及时停止动画和线程如果需要停止线程或者动画，可以在onDetachedFromWindow方法中处理，当包含此View的Activity退出或者当前View被remove时，View的onDetachedFromWindow方法会被调用，和此方法对应的是onAttachedToWindow，当包含此View的Activity启动时，View的onAttachedToWindow方法会被调用。 2.5 View带有滑动嵌套情形时，需要处理好滑动冲突如果有滑动冲突的话，那么要合适的处理滑动冲突，否则将会严重影响View的效果。 三、自定义View3.1 继承View重写onDraw方法首先来看一下代码1234567891011121314151617181920212223242526272829303132public class TestCustomCircleView extends View &#123; private int color = Color.RED; private Paint paint; public TestCustomCircleView(Context context) &#123; super(context); init(); &#125; public TestCustomCircleView(Context context, AttributeSet attrs) &#123; super(context, attrs); init(); &#125; public TestCustomCircleView(Context context, AttributeSet attrs, int defStyleAttr) &#123; super(context, attrs, defStyleAttr); init(); &#125; private void init()&#123; paint = new Paint(); paint.setColor(color); &#125; @Override protected void onDraw(Canvas canvas) &#123; super.onDraw(canvas); int width = getWidth(); int height = getHeight(); int radius = Math.min(width,height)/2; canvas.drawCircle(width/2,height/2,radius,paint); &#125;&#125; 上面的代码只是一种初级的实现，当我们进行使用的时候，只支持margin属性，并不支持padding属性。对onDraw方法进行修改，只要在绘制的时候考虑一下padding即可。123456789101112@Override protected void onDraw(Canvas canvas) &#123; super.onDraw(canvas); int paddingLeft = getPaddingLeft(); int paddingRight = getPaddingRight(); int paddingTop = getPaddingTop(); int paddingBottom = getPaddingBottom(); int width = getWidth() - paddingLeft - paddingRight; int height = getHeight() - paddingBottom - paddingTop; int radius = Math.min(width, height) / 2; canvas.drawCircle(paddingLeft + width / 2, paddingTop + height / 2, radius, paint); &#125; 但是现在还不能支持warp_content属性，现在使用wrap_content和使用match_parent没有任何区别：对于直接继承自View的控件，如果不对wrap_content做特殊处理，那么使用wrap_content就相当于使用match_parent.这里就需要我们重写onMeasure方法，当宽高属性为wrap_content时，取一个默认值。123456789101112131415161718192021222324252627282930@Overrideprotected void onMeasure(int widthMeasureSpec, int heightMeasureSpec) &#123; int desiredWidth = 100; int desiredHeight = 100; int widthMode = MeasureSpec.getMode(widthMeasureSpec); int widthSize = MeasureSpec.getSize(widthMeasureSpec); int heightMode = MeasureSpec.getMode(heightMeasureSpec); int heightSize = MeasureSpec.getSize(heightMeasureSpec); int width; int height; //宽度 if (widthMode == MeasureSpec.AT_MOST) &#123; width = Math.min(desiredWidth, widthSize); &#125; else if (widthMode == MeasureSpec.EXACTLY) &#123; width = widthSize; &#125; else &#123; width = desiredWidth; &#125; //高度 if (heightMode == MeasureSpec.AT_MOST) &#123; height = Math.min(desiredHeight, heightSize); &#125; else if (heightMode == MeasureSpec.EXACTLY) &#123; height = heightSize; &#125; else &#123; height = desiredHeight; &#125; setMeasuredDimension(width, height);&#125; 这样，当我们使用wrap_content时，就是使用默认的100px的值。 四、使用自定义属性4.1 创建自定义的配置文件在values目录下面创建自定义属性的XML，比如attrs.xml，也可以选择类似于attrs_circleview.xml等这种以attrs开头的文件名，当然这个文件名并没有什么限制，可以随便取名字。我们选择创建attrs.xml文件。12345&lt;resources&gt; &lt;declare-styleable name="TestCustomCircleView"&gt; &lt;attr name="circle_color" format="color"/&gt; &lt;/declare-styleable&gt;&lt;/resources&gt; 4.2 在构造方法中解析自定义的属性值并做相应的处理1234567public TestCustomCircleView(Context context, AttributeSet attrs, int defStyleAttr) &#123; super(context, attrs, defStyleAttr); TypedArray typedArray = context.obtainStyledAttributes(attrs, R.styleable.TestCustomCircleView); color = typedArray.getColor(R.styleable.TestCustomCircleView_circle_color,Color.RED); typedArray.recycle(); init();&#125; 首先加载自定义属性集合，接着解析属性集合中TestCustomCircleView_circle_color，如果没有指定属性值，则使用Color.RED作为默认值。 4.3 在布局文件中使用自定义属性&lt;com.example.huangyuan.custom.TestCustomCircleView android:layout_width="wrap_content" android:layout_height="wrap_content" android:layout_gravity="center_horizontal" app:circle_color="@color/grey" /&gt;]]></content>
      <tags>
        <tag>Android</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[View的滑动]]></title>
    <url>%2F2017%2F03%2F15%2FView%E7%9A%84%E6%BB%91%E5%8A%A8%2F</url>
    <content type="text"><![CDATA[View的位置主要由它的四个顶点来决定，分别对应于View的四个属性：top,left,right,bottom,其中top是左上角的纵坐标，left是左上角的横坐标，right是右下角的横坐标，bottom是右下角的纵坐标。需要注意的是，这些坐标都是相当于View的父容器来说的，因此它是一种相对坐标，View的坐标和父容器的关系如下所示： width = right - leftheight = bottom - topleft = getLeft()right = getRight()top = getTop()bottom = getBottom()从Android3.0 开始，View增加了额外的几个参数：x,y,trabslationX和translationY。其中x和y是View左上角的坐标，而translationX和translationY是View左上角相对于父容器的偏移量。这几个参数也是相对于父容器的坐标，并且translationX和translationY的默认值是0，和View的四个基本的位置参数一样，View也为他们提供了get/set方法，这几个参数的换算关系如下x = left + translationX需要注意的是，View在平移过程中，top和left表示的是原始左上角的位置信息，其值并不会发生改变，此时发生改变的是x,y,translationX和translationY。 一 VelocityTracker 和 GestureDetector速度最终，用于追踪手指在滑动过程中的速度，包括水平和竖直方向的速度。使用方法在View的onTouchEvent方法中追踪当前单击事件的速度：12VelocityTracker velocityTracker = VelocityTracker.obtain();velocityTracker.addMovement(event); 接着，当我们想知道当前的滑动速度时，这个时候可以采用如下方式来获得当前速度：123velocityTracker.computeCurrentVelocity(1000);float xVelocity = velocityTracker.getXVelocity();float yVelocity = velocityTracker.getYVelocity(); 在这一步中有两点需要注意 获取速度之前必须先计算速度，即getXVelocity()和getYVelocity()之前必须调用computeCurrentVelocity(1000) 这里的速度时指一段时间内手指所划过的像素数，速度可以是负数，当手指在水平方向从左向右滑动时，速度为正，反之为负数。最后，当不在使用它的时候，需要调用clear方法来重置并回收内存:12velocityTracker.clear();velocityTracker.recycle(); 手势检测，用于辅助检测用户的单击、滑动、长按、双击等行为。首先创建GestureDetector的对象，接着接管View的onTouchEvent方法。做完下面两部，就可以有选择的实现接口中的方法了123GestureDetector gestureDetector = new GestureDetector(this,this); gestureDetector.setIsLongpressEnabled(false); return gestureDetector.onTouchEvent(event); 其中gestureDetector.setIsLongpressEnabled(false)是为了解决长按之后无法拖动的现象。 二 使用ScrollTo/ScrollBy调用方式 View.scrollTo(int x, int y),View.scrollBy(int x, int y)方法源码：12345678910111213141516171819202122232425262728293031/** * Set the scrolled position of your view. This will cause a call to * &#123;@link #onScrollChanged(int, int, int, int)&#125; and the view will be * invalidated. * @param x the x position to scroll to * @param y the y position to scroll to */ public void scrollTo(int x, int y) &#123; if (mScrollX != x || mScrollY != y) &#123; int oldX = mScrollX; int oldY = mScrollY; mScrollX = x; mScrollY = y; invalidateParentCaches(); onScrollChanged(mScrollX, mScrollY, oldX, oldY); if (!awakenScrollBars()) &#123; postInvalidateOnAnimation(); &#125; &#125; &#125; /** * Move the scrolled position of your view. This will cause a call to * &#123;@link #onScrollChanged(int, int, int, int)&#125; and the view will be * invalidated. * @param x the amount of pixels to scroll by horizontally * @param y the amount of pixels to scroll by vertically */ public void scrollBy(int x, int y) &#123; scrollTo(mScrollX + x, mScrollY + y); &#125; 从源码中可以看出，scrollBy实际上也是调用scrollBy的方法。需要注意的是在View的滑动过程中，mScrollX和mScrollY的改变规则：在滑动过程中，mScrollX的值总是等于View左边缘和View内容左边缘在水平方向的距离，而mScrollY的值总是等于View上边缘和View内容上边缘在竖直方向的距离。其中mScrollX和mScrollY的单位是像素，并且当View左边缘在View内容左边缘的右边时，mScrollX为正值，反之为负值；当View上边缘在View内容上边缘的下边时，mScrollY为正值，反之为负值。换句话说：从左向右滑动，mScrollX为负值，反之为正值；如果从上往下滑动，mScrollY为负值，反之为正值。意思就是说ScrollTo/ScrollBy只能滑动View的内容而不能滑动View本身，比如，只能滑动TextView的文字，而不能滑动TextView控件本身 三 使用动画这个没什么好介绍的，想要兼容3.0以下的属性动画，建议使用nineoldandroids来实现 四 改变布局参数改变布局参数，也就是改变·LayoutParams· 五 使用Scroller进行平滑移动自定义一个控件，添加成员变量·Scroller·，如下：123456789101112131415161718192021222324252627282930313233343536373839public class ScrollerTextView extends TextView &#123; private Scroller mScroller; public ScrollerTextView(Context context) &#123; super(context); mScroller = new Scroller(context); &#125; public ScrollerTextView(Context context, AttributeSet attrs) &#123; super(context, attrs); mScroller = new Scroller(context); &#125; public ScrollerTextView(Context context, AttributeSet attrs, int defStyleAttr) &#123; super(context, attrs, defStyleAttr); mScroller = new Scroller(context); &#125; public void smoothScrollBy(int dx,int dy)&#123; mScroller.startScroll(mScroller.getFinalX(),mScroller.getFinalY(),dx,dy,2000); invalidate(); &#125; public void smoothScrollTo(int fx, int fy)&#123; int dx = fx - mScroller.getFinalX(); int dy = fy - mScroller.getFinalY(); smoothScrollBy(dx,dy); &#125; @Override public void computeScroll() &#123; if(mScroller.computeScrollOffset())&#123; scrollTo(mScroller.getCurrX(), mScroller.getCurrY()); postInvalidate(); &#125; super.computeScroll(); &#125;&#125; 其实Scroller也是通过ScrollTO/ScrollBy实现的，同样只能滑动内容，不能滑动本身。PS：在调用startScroll时，并没有让View进行滑动。而是在调用invalidate()进行重绘的时候，会去调用computeScroll方法，但是computeScroll在View只是个空实现，因此需要我们自己去实现。在computeScroll中进行平移。也就是说当View重绘后在draw方法中调用computeScroll,而computeScroll又会去向Scroller获取当前的scrollX和scrollY,然后通过scrollTo方法实现滑动，接着又调用postInvalidate()方法来进行第二次重绘，这一次重绘过程和第一次一样，还是会去调用computeScroll()方法，如此反复，直到整个滑动过程结束。 以上]]></content>
      <tags>
        <tag>Android</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[《我的安卓爬坑之旅》-高德地图遇到的坑(2)]]></title>
    <url>%2F2017%2F02%2F25%2F%E3%80%8A%E6%88%91%E7%9A%84%E5%AE%89%E5%8D%93%E7%88%AC%E5%9D%91%E4%B9%8B%E6%97%85%E3%80%8B-%E9%AB%98%E5%BE%B7%E5%9C%B0%E5%9B%BE%E9%81%87%E5%88%B0%E7%9A%84%E5%9D%91-2%2F</url>
    <content type="text"><![CDATA[这篇博客是关于高德使用中遇到的问题，或许是因为开发文档中没有说明，或许是因为自己段位不够，反正就是遇到坑了。 关于定位点和覆盖物 有这么一个业务需求：定位手机所在位置成功后，请求服务器数据，服务器返回手机所在地点指定范围内的的点，然后把这些点添加到地图上。刚开始还没有什么问题，按照官网的demo来做的，到后来数据量多的时候就出现了marker重叠的问题。当然，marker点多的话，重叠也是无法避免的，但是，把定位的标记也给覆盖掉了，这就有点不好了。也没有查到相关的api，demo上添加定位点也是用的marker，估计都是同一级别，按照添加的先后顺序覆盖叠加。后来找到了一个方法 mLocMarker.setToTop();这样可以把某个marker设置到最高的层级显示。还有一个方法是123456public void setDisplayLevel(int var1) &#123; IMarkerAction var2 = this.a.getIMarkerAction(); if(var2 != null) &#123; var2.setDisplayLevel(var1); &#125;&#125; 这个是Marker对象中的一个方法，但是从官方下载下来的文档中并没有提到这个方法，自己也没有去使用。了解过的朋友可以在评论区回复我一下，谢谢。 AndroidStudio第二次编译之后地图不显示 AS2.2版本加了 Instant Run 模式，通常情况下这回节省我们很多时间，比如当我们修改了界面布局，想要在手机上看一下效果，没有必要重启整个应用，这个时候就可以使用 Instant Run 模式了，ide内部会进行判断是否需要重启整个应用，如果不需要，只会热重启当前页面。为这个功能点赞啊，有的时候页面藏的比较深，需要多步操作才能打开，这个功能可以节省很多时间。但是啊但是。。。我在Fragment中使用高德地图的时候，使用这个功能会出现地图加载不出来（一片空白），但是定位成功的问题。刚开始的是吓尿了，以为代码出了什么问题，直到我提了工单，看到回复后放心了： 您好，Instant Run 确实是不支持这种，目前他们也没有给出解决方案，这里有详细的解释http://stackoverflow.com/questions/33902467/android-studio-2-0-why-does-instant-run-not-work-when-modifying-xml-layout-reso感谢您的致信，欢迎持续关注高德开放平台！ 地图加载完成的回调函数因为业务上的原因，需要在地图加载完成后做一些操作，当时官网的开发者文档上没有啊，于是又提了工单，接到回复后又放心了 您好，AMap 提供了地图加载完成的方法， 可详见：12345aMap.setOnMapLoadedListener(new AMap.OnMapLoadedListener() &#123; @Override public void onMapLoaded() &#123; &#125; &#125;); 感谢您的致信，欢迎持续关注高德开放平台！ 步行路径规划当距离比较短时路线不在地图中间位置 由于业务上的原因，自己的位置和目的地的距离较短，需要步行路径规划，但是啊但是，路径可以规划成功，但是把路径添加到地图上的时候，路径没有显示在屏幕中间位置啊，而是诡异的飘到了一边。反复检查了N边代码，没有问题啊，和官网demo一样啊，把坐标点抠出来，改一下官网demo的起始点(就是两个坐标值),然后，也出现了路径飘到一边的情况，于是又去提了万能的工单，看到工单的回复后，我又放心了 我：Demo是从官网的demo上改的，就在om.amap.map3d.demo.route包下的WalkRouteActivity这个类里面，改了一下mStartPoint，和 mEndPoint 的值，附件图片是我修改之后的值 private LatLonPoint mStartPoint = new LatLonPoint(39.990145, 116.481194);private LatLonPoint mEndPoint = new LatLonPoint(39.99026006391499, 116.4813472288069);从官网下载回来后只改了这两个地方，把key换成了自己的，其他地方的代码没有动。如果可以的话，你们可以试一下，找两个距离非常近的点。答复：您好，这个问题确实是由SDK内部处理不当引起的bug，我们会在下个版本中修复，给您带来不便深表歉意感谢您的致信，欢迎持续关注高德开放平台！ 解决方法：判断两个点的距离，小于500米的时候，取起始点位置连线的中间位置作为地图中间点，强制将地图上的此位置拉到屏幕中间。 以上]]></content>
      <tags>
        <tag>Android</tag>
        <tag>Android爬坑之旅</tag>
        <tag>高德地图</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[写在2016年末]]></title>
    <url>%2F2016%2F12%2F31%2F%E5%86%99%E5%9C%A82016%E5%B9%B4%E6%9C%AB%2F</url>
    <content type="text"><![CDATA[2016年的最后一天的最后半个小时了，写写这一年的收获总结和2017的计划吧。一个字总结了一下2016年：穷。当然这是开玩笑式的总结，但也是最接近事实的了。 2016总结技术方面：&nbsp;&nbsp;&nbsp;&nbsp;自从踏上IT这条不归路开始，就打算做一个全栈攻城狮，从敲下第一行hello world到自己独立用java写一个完整的大作业再到写出实际可用的程序到现在的工作，仔细想想已经五年多了吧。但是这仅仅是个开始，我对自己现在的定位是全栈攻城狮的道路刚刚慢出第一步，现在也就算是个全栈学徒吧。 编程技能自定级别python入门HTML初级J2EE初级JAVA中级Android中级Linux中级 在工作中也踩过、填过、挖过很多坑，万幸的是一直坚持了下来，没有放弃，也没有想过要转行的事，就想一直在这个行业发展，努力提高自己的技术。 15年双十二和今年的十二月四号，都参加了开源中国举办的源创汇年终盛典，接触到了很多大牛(虽然他们不曾记得我)，接触到很多以前没有见识过也没有想象过的东西，对自己的成长有很大帮助。 开通了自己的博客(gitpage),把博客从csdn迁移到github上，租用了腾讯云主机，备案了自己的域名，有了自己的简单的网站，可以写一些自己感兴趣的东西(自由的感觉真好，法无禁止皆可为)。 也感谢这一年来小伙伴的帮助，幸好有你们，帮我解决了困难。 当然，在这一年中也有很多事情不是那么顺利，从上家公司离职，从10月到12月，中间休息了两个月，回了一次家，跑去深圳和妹子玩了四五天的样子(几乎是全部时间都泡在图书馆了，沉迷学习无法自拔)，其余时间也就是看看书，打打游戏之类的，总之这两个月的时间大部分都被浪费掉了，没有任何收获。 生活上也没啥好说的，业余时间就是宅在家里，看看书，敲敲代码，打打游戏，不喜欢出去逛，貌似好像是在6、7月份的样子，二哥来北京玩，爬了一次八达岭长城，除此之外，就是去了三次漫展，其他的就没有什么了。 2017计划首先，最重要的就是提升自己的技术能力： python达到初级水平;html方面学习一下h5; J2EE方面学习一下ssm框架、nginx; JAVA和Android方面尽可能的提升自己，尽量在两年内能初步达到高级水平; Linux方面，熟悉一下vim，了解以下服务器方向的相关知识，毕竟自己只是拿linux做开发，没有把精力放在服务器假设方向。 生活方面就尽量改变一下自己宅的属性,尽量多出去走走吧(这个有点难，比提升技术实力还要难) 借用一本小说中的一段话吧： “其实所有的智慧生物都在饮鸩止渴。所有的智慧生物都在通过不断的科技进步，不断的探索未知来满足着自己的探索欲望。这些科技，以及理论还有知识，不是好东西，它们是毒药，它们会让文明形成强烈的依赖症，当所有的未知都被探索完毕的时候，这种鸩毒就会最终发作，并且让这个文明最终陷入到毒发身亡的境地之中。可是最可笑的是，虽然这个道理十分明显，可是包括我在内的所有文明，都无法逃脱这个怪圈。” “我……我怎么可以停止呢？就算它们明明是毒药，可是我也要不断的去吃啊。”萧宇喃喃自语着，“如果我的科技不能进步，如果现在就斩断我进步的道路，我现在就会发疯的。这一点是天生注定的，当我还在地球上的时候，当我拿起笔，拿起书本，学习到第一个数学公式，学习到第一个物理定理的时候，这种鸩毒就已经在我的灵魂深处深深的扎下了根，让我终其一生不得解脱。我的毒瘾会越来越大，我所需要的鸩毒分量会越来越多，我只能继续这样维持下去。以后再毒发，总比现在就毒发要好。” 这个死在旅途之中的文明，让萧宇想到了很多很多，对萧宇的灵魂造成了很深的触动。可是萧宇已经无法停下自己的脚步了。浩瀚广阔的星空，无边无际的宇宙，就像是美丽异常的罂粟花，明知道危险，可是还是有不计其数的文明，包括萧宇在内都踏了进去，并且一个个踊跃异常，生怕自己吸食毒品的速度要比其余的文明慢了一点。 以上。]]></content>
      <tags>
        <tag>乱七八糟</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[《我的安卓爬坑之旅》--高德地图遇到的坑]]></title>
    <url>%2F2016%2F12%2F18%2F%E3%80%8A%E6%88%91%E7%9A%84%E5%AE%89%E5%8D%93%E7%88%AC%E5%9D%91%E4%B9%8B%E6%97%85%E3%80%8B-%E9%AB%98%E5%BE%B7%E5%9C%B0%E5%9B%BE%E9%81%87%E5%88%B0%E7%9A%84%E5%9D%91-1%2F</url>
    <content type="text"><![CDATA[这篇博客是关于高德使用中遇到的问题，或许是因为开发文档中没有说明，或许是因为自己段位不够，反正就是遇到坑了。 ####生成key 生成key的时候，同一个app下，可以填入相同的包名、key名称等。注意不要用错了key 由于高德地图升级的原因，需要将原来没有整理过的key先整理，使其属于某个应用，才可以继续创建其他的key。 ####文档 仅在入门指南中提到了需要加入 &lt;service android:name=&quot;com.amap.api.location.APSService&quot;&gt;&lt;/service&gt;开发注意事项里面居然没有提到。最关键的是，没有加入这个service时，定位有时还能成功，只是不能连续定位。我看的时候时从开发注意事项开始看的，完全没有注意到这一点，后来在demo中看到了需要加入这个配置，才能生效。 文档里面只给出了部分关键代码和部分关键类，完全不知道这个类怎么实例化，怎么去调用方法，调用方法的时候需要传入哪种类型的参数。就我个人看来，看官方api文档还不如去看他们的demo，文档写的真心不算好。官方部分demo地址官方demo地址官方sdk以及开发文档、demo等相关下载官方sdk、开发文档以及demo以后遇到坑再补充吧，估计遇到的都是文档中没有标明但在demo中有示例的那种。]]></content>
      <tags>
        <tag>Android</tag>
        <tag>Android爬坑之旅</tag>
        <tag>高德地图</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[《我的安卓爬坑之旅》--融云IM遇到的坑]]></title>
    <url>%2F2016%2F12%2F01%2F%E3%80%8A%E6%88%91%E7%9A%84%E5%AE%89%E5%8D%93%E7%88%AC%E5%9D%91%E4%B9%8B%E6%97%85%E3%80%8B-%E8%9E%8D%E4%BA%91IM%E9%81%87%E5%88%B0%E7%9A%84%E5%9D%91%2F</url>
    <content type="text"><![CDATA[这篇博客是关于融云IM使用中遇到的问题，不算是坑，只能说是注意事项吧 后端向 在自己的应用”OurStories”中打算接入IM即时通讯功能，就使用了融云提供的sdk，需要自己写后台获取Token，这个比较简单，官方给出了Demo，按照自己的习惯，把demo里面的方法封装一下就可以使用了。 Token向 获取Token时可以在融云后台（登录自己帐号，控制台）可以设置Token有效期。 在初始情况下开发环境下最多只能有100个测试用户，当达到上限后可以点击添加用户的按钮，每次添加20人上限，生产环境没有上限。 开发环境和生产环境在融云后台是两套独立的环境，拥有不同的App Key和App Secret，当产品上线时不要忘记切换自己服务器和app的配置，另外，app的App Key和服务器端的App Key要一致。前端 Android向 由于集成融云的聊天界面个会话列表界面都是Fragment形式，在集成的过程中，包含该Fragment的Activity要继承自FragmentActivity，否则在开启聊天界面的时候会报如下异常： 1234Caused by: android.view.InflateException: Binary XML file line #6: Binary XML file line #6: Error inflating class fragment Caused by: android.view.InflateException: Binary XML file line #6: Error inflating class fragment Caused by: android.app.Fragment$InstantiationException: Trying to instantiate a class io.rong.imkit.fragment.ConversationFragment that is not a Fragment Caused by: java.lang.ClassCastException 融云在初始化的时候建议放在Applicatuon中进行，但是融云会开启3个进程，每个进程都会执行Application的OnCreate方法，建议在初始化自己的配置时检测以下进程，在自己的主进程中初始化自己的配置. 千万不要忘记配置包含融云Fragment的Activity的&lt;intent-filter&gt; 融云不同步也不会保存应用下的好友关系，需要自己的服务器保存 注意阅读融云的开发文档，注意每一个细节 有问题先去搜知识库，然后提工单。提工单的时候尽可能详细的描述自己的开发环境，遇到的问题以及异常日志。 非必要情况下，不要自己去反编译出融云的sdk，然后自己使用用其中的代码。]]></content>
      <tags>
        <tag>Android</tag>
        <tag>Android爬坑之旅</tag>
        <tag>融云IM</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[《我的安卓爬坑之旅》]]></title>
    <url>%2F2016%2F11%2F21%2F%E3%80%8A%E6%88%91%E7%9A%84%E5%AE%89%E5%8D%93%E7%88%AC%E5%9D%91%E4%B9%8B%E6%97%85%E3%80%8B%2F</url>
    <content type="text"><![CDATA[准备记录一下自己在工作学习中遇到的bug以及解决方案。不定期更新。内容包括但不限于android，J2EE，HTML，以及各种各样的需求。形式如下：bug：①出现bug的场景②尽可能放上代码③分析原因：源码及原理④解决方案：思路及尽可能的放上代码需求：①产品需求：尽可能详细描述产品需求，尽量能放上UI②分析可能的解决方案：思路③解决过程：自己的思路及解决方案和踩到的坑④解决方法：尽可能放上关键代码或者伪代码⑤其他：一些意想不到的事。 大家也可以发邮件到我的邮箱，把自己遇到的问题和大家分享一下email: huangyuan@huangyuanlove.com]]></content>
      <tags>
        <tag>Android</tag>
        <tag>Android爬坑之旅</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[hexo+gitpage搭建自己的博客(三)]]></title>
    <url>%2F2016%2F10%2F30%2Fhexo-gitpage%E6%90%AD%E5%BB%BA%E8%87%AA%E5%B7%B1%E7%9A%84%E5%8D%9A%E5%AE%A2-%E4%B8%89%2F</url>
    <content type="text"><![CDATA[前两篇介绍了怎么用gitpage+github搭建自己的博客，这次主要介绍怎么更换主题和加入评论、统计等。 更换主题首先将 yilia主题从github克隆到本地thems文件夹里面1git clone https://github.com/litten/hexo-theme-yilia.git themes/yilia 看一下当前博客目录的结构 其中_config.yml文件就是整个hexo系统的主配置文件另外刚才克隆的yilia主题就在thems文件夹下面首先修改根目录下的_config.yml文件，切换到yilia主题大概在文件的63-65行左右的位置1234# Extensions## Plugins: https://hexo.io/plugins/## Themes: https://hexo.io/themes/theme: yilia 将原来的theme后面的 landscape主题改成yilia重启服务后主题就切换到yilia了，下面是thems/yilia文件夹下的_config.yml文件的配置. 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566# Headermenu: 主页: / 简历: ""# SubNavsubnav: github: "https://github.com/huangyuanlove" #weibo: "#" #rss: "#" zhihu: "https://www.zhihu.com/people/huangyuan_xuan" #douban: "#" #mail: "#" #facebook: "#" #google: "#" #twitter: "#" #linkedin: "#"rss: /atom.xml# 是否需要修改 root 路径# 如果您的网站存放在子目录中，例如 http://yoursite.com/blog，# 请将您的 url 设为 http://yoursite.com/blog 并把 root 设为 /blog/。root:# Contentexcerpt_link: morefancybox: truemathjax: false# 是否开启动画效果animate: true# 是否在新窗口打开链接open_in_new: false# 自己添加的百度统计baidu_tongji: true# 网站iconfavicon: favicon.ico#你的头像urlavatar: ""#是否开启分享share_jia: falseshare_addthis: false#多说评论duoshuo:# 如不需要，将该项置为false# 比如#smart_menu:# friends: falsesmart_menu: innerArchive: '所有文章' tagcloud: '标签' #friends: '友链' aboutme: '关于我'friends:aboutme: &lt;a href="http://www.huangyuanlove.com"&gt;什么懂都点的Android攻城狮&lt;/a&gt; 以上是yilia主题的配置说明接入百度统计首先到百度统计平台 申请一个帐号，按照提示填写完自己网站的信息，在网站中心左边栏点击代码获取，得到统计访问量的代码。新建themes/yilia/layout/_partial/baidu_tongji.ejs文件，内容如下：12345&lt;% if (theme.baidu_tongji) &#123; %&gt;&lt;script&gt; 统计访问量的代码&lt;/script&gt;&lt;% &#125; %&gt; 然后编辑themes/yilia/_config.yml文件，添加一行baidu_tongji: true，注意冒号后面有空格。编辑themes/yilia/layout/_partial/head.ejs 在 &lt;/head&gt; 前添加&lt;%- partial(&quot;baidu_tongji&quot;) %&gt;重启部署代码即可。安装完成20分钟后就可以在后台看到统计的信息了，如果看不到统计信息，请检查是否配置正确，检测方式点这里 http://tieba.baidu.com/p/3775626020以上是添加百度统计的方式添加多说评论到多说 申请帐号使用三方登录完成后，点击我要安装，根据提示填写完信息记住站点名称，将站点名称填入 thems/yilia/_config.yml文件里面多说评论之后，注意冒号后面有空格。保存重新部署就可以看到评论框了。至于评论样式，可以在后台管理页面中的设置选项中设置。后台管理中还可以管理评论内容，添加敏感词汇过滤等。以上是添加多说评论的过程。 以上]]></content>
      <tags>
        <tag>hexo</tag>
        <tag>gitpage</tag>
        <tag>blog</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[hexo+gitpage搭建自己的博客(二)]]></title>
    <url>%2F2016%2F10%2F25%2Fhexo-gitpage%E6%90%AD%E5%BB%BA%E8%87%AA%E5%B7%B1%E7%9A%84%E5%8D%9A%E5%AE%A2-%E4%BA%8C%2F</url>
    <content type="text"><![CDATA[之前我们已经安装好了hexo，接下来就是初始化了。123hexo init &lt;dir&gt;cd &lt;dir&gt;npm install 现在hexo就安装完成了，在存放hexo的文件夹目录下执行 hexo s，就可以启动hexo的服务，启动之后有提示，在浏览器中输入127.0.0.1:4000就可以看到最初的效果了，如下 对了，还要发布到github。前提准备是在上一篇中已经创建好了github的仓库。接下来在存放hexo资源的文件夹下(以下用 heox_blog这个文件夹代替)执行npm install hexo-deployer-git --save修改hexo_blog文件夹下的_config.yml文件在末尾添加1234deploy: type: git repository: git@github.com:your name/your name.github.io.git branch: master 注意，type，repository，branch冒号后面都有一个空格。保存后执行123hexo cleanhexo ghexo d 就可以将写好的博客部署到github上了。（部署到github时建议按照顺序执行以上命令） 12345hexo generate == hexo g --&gt;将md文件解析成静态的html文件hexo deploy == hexo d --&gt; 将文件部署到githubhexo server == hexo s --&gt; 启动本地hexo服务hexo clean --&gt; 清除缓存hexo new &quot;title&quot; --&gt; 创建新的文章，文件在`hexo_blog/source/_posts`文件夹下 以上]]></content>
      <tags>
        <tag>hexo</tag>
        <tag>gitpage</tag>
        <tag>blog</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[hexo+gitpage搭建自己的博客(一)]]></title>
    <url>%2F2016%2F10%2F21%2Fhexo-gitpage%E6%90%AD%E5%BB%BA%E8%87%AA%E5%B7%B1%E7%9A%84%E5%8D%9A%E5%AE%A2-%E4%B8%80%2F</url>
    <content type="text"><![CDATA[不说环境直接写配置的行为都是耍流氓按照惯例,先说自己的环境:ubunu,然后就没有然后了. hexo类似wordpress的博客框架,gitpage是github的一个服务,请原谅我这个不大准确的表达,事实上真的差不多.安装hexo需要安装nodejs,使用gitpage需要git,至于如何安装git,在原来的csdn博客上有,点击这里 http://blog.csdn.net/huangyuan_xuan/article/details/49125597.之后需要在自己的github上创建一个仓库,名称结构如下:username.github.io,例如我的github主页是https://github.com/huangyuanlove,那么我的gitpage就是huangyuanlove.github.io.到这里,默认大家的gitpage和git已经配置好了,包括sshkey之类的东西. 我安装node是用nvm(node version manager)安装的,然后使用node中的npm(node package manager)安装hexo.windows下安装请转这里 https://github.com/coreybutler/nvm-windows首先安装nvm: wget -qO- https://raw.github.com/creationix/nvm/master/install.sh | sh 安装时间长短视网速而定,我安装了大概十多分钟,然后重启一下终端.然后使用 nvm ls-remote查看一下有哪些本版可以安装,我当时安装的最新版是6.6.0,现在不知道是哪一版,如b下找一个合适的版本使用如下命令安装nvm install version,例如 nvm install 6.6.0,安装时间还是视网速而定,我也忘了装了多长时间了.安装完成之后是这样的之后npm install -g hexo安装hexo,-g参数是全局安装安装完成之后使用hexo -v查看hexo的版本号到此hexo安装完成,接下来就是初始化,进行配置了.下一篇再说吧,睡觉了. 以上.]]></content>
      <tags>
        <tag>hexo</tag>
        <tag>gitpage</tag>
        <tag>blog</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[如何获取csdn中个人所有文章标题及链接]]></title>
    <url>%2F2016%2F10%2F19%2F%E5%A6%82%E4%BD%95%E8%8E%B7%E5%8F%96csdn%E4%B8%AD%E4%B8%AA%E4%BA%BA%E6%89%80%E6%9C%89%E6%96%87%E7%AB%A0%E6%A0%87%E9%A2%98%E5%8F%8A%E9%93%BE%E6%8E%A5%2F</url>
    <content type="text"><![CDATA[小伙伴问如何把自己csdn上的文章标题和超链接都扒下来,问我是不是一个个点开之后抄过去的…当然不是,做为一个爱(sha)好(dou)广(dong)泛(dian)的程序员,怎么会用这么麻烦的方法. 本来打算写java模拟登录之后获取网页源码,然后再用jsoup去解析,得到自己需要的数据.原来就这么干过,好像是写学校的绩点计算器来着吧,就是输入帐号密码就能查到自己的成绩和绩点的那种.翻出来代码看了看太麻烦了,想到自己最近在看python,就想着用python来解决,但是问题又来了,python不熟啊,就算写出来了也得看网页源码,找到规律才行,讲道理的说挺烦这东西的.最后,还是用js来解决,毕竟这种事也干过,也不是多麻烦.登录自己的帐号,找到文章列表,打开控制台窗口,忘了说一下自己的环境了ubuntu,chrom,找到文章标题和超链接的部分,如下图:发现所有的文章标题和超链接结构如下:12345 &lt;span class="link_title"&gt; &lt;a href="/huangyuan_xuan/article/details/51935666"&gt; 初步编写IDEA\AndroidStudio翻译插件 &lt;/a&gt;&lt;/span&gt; 另外,界面中还引入了jQuery这个三方库,这就更简单了:找到开发者工具的控制台(console),写入下面两行代码12345var aTags = $(".link_title &gt; a")for(var i = 0;i&lt;50;i++)&#123; console.log("[" + aTags[i].text.trim() + "](" + aTags[i].href +") "+ aTags[i].href) +"&lt;br/&gt;" &#125; ok,执行结果如下 在控制台写的代码第一行是使用jQuery库找到所有文章的超链接集合,第二行是按照markdown超链接的语法打印出来文章标题和超链接,至于循环中的50这个数字,一页最多只有50篇文章,我偷懒了,建议使用aTags.length 以上]]></content>
      <tags>
        <tag>csdn</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[原CSDN博客]]></title>
    <url>%2F2016%2F10%2F16%2F%E5%8E%9FCSDN%E5%8D%9A%E5%AE%A2%2F</url>
    <content type="text"><![CDATA[不打算在csdn上面写博客了,转到gitpage上面,自己用hexo搭建了博客系统.现在把原csdn的博客链接抄在下面 使用openfire搭建IM聊天系统(一) http://blog.csdn.net/huangyuan_xuan/article/details/52549416 浅谈使用单元素的枚举类型实现单例模式 http://blog.csdn.net/huangyuan_xuan/article/details/52193006 初步编写IDEA\AndroidStudio翻译插件 http://blog.csdn.net/huangyuan_xuan/article/details/51935666 多线程 的理解（一） http://blog.csdn.net/huangyuan_xuan/article/details/50881452 运行时数据区域 http://blog.csdn.net/huangyuan_xuan/article/details/50570461 虚拟机字节码执行引擎 http://blog.csdn.net/huangyuan_xuan/article/details/50569443 虚拟机类加载机制 http://blog.csdn.net/huangyuan_xuan/article/details/50550725 垃圾收集器与内存分配策略 http://blog.csdn.net/huangyuan_xuan/article/details/50513881 JDK的一些命令行工具 http://blog.csdn.net/huangyuan_xuan/article/details/50513861 MongoDB基础 http://blog.csdn.net/huangyuan_xuan/article/details/50155345 tomcat图形化界面管理及数据源配置 http://blog.csdn.net/huangyuan_xuan/article/details/49859151 android 四大图片缓存原理、特性对比 http://blog.csdn.net/huangyuan_xuan/article/details/49362701 github分支管理 http://blog.csdn.net/huangyuan_xuan/article/details/49356523 github 远程仓库 http://blog.csdn.net/huangyuan_xuan/article/details/49356505 github建立本地与远程仓库的连接 http://blog.csdn.net/huangyuan_xuan/article/details/49336403 Git 本地版本控制 http://blog.csdn.net/huangyuan_xuan/article/details/49162309 安装github http://blog.csdn.net/huangyuan_xuan/article/details/49125597 ubuntu 14.04 apt-get install 不能自动补全解决办法 http://blog.csdn.net/huangyuan_xuan/article/details/48915299 String的一点小东西 http://blog.csdn.net/huangyuan_xuan/article/details/48116365 wireshark error: There are no interfaces on which a capture can be done. http://blog.csdn.net/huangyuan_xuan/article/details/46632395 windows下使用cmd（命令行）发送邮件 http://blog.csdn.net/huangyuan_xuan/article/details/46564319 Notepad++ 搭建java编译环境 http://blog.csdn.net/huangyuan_xuan/article/details/45936413 JVM虚拟机 http://blog.csdn.net/huangyuan_xuan/article/details/44537233 servlet向浏览器输出验证码图片 http://blog.csdn.net/huangyuan_xuan/article/details/43817631 ubuntu14.04开热点共享网络 http://blog.csdn.net/huangyuan_xuan/article/details/43759585 UNIX/linux的find命令细节 http://blog.csdn.net/huangyuan_xuan/article/details/43739353 编写shell时，提示let：not found http://blog.csdn.net/huangyuan_xuan/article/details/43490373 cmd命令大全 http://blog.csdn.net/huangyuan_xuan/article/details/42804537 华为 ap ac设备配置命令 http://blog.csdn.net/huangyuan_xuan/article/details/41647447 更改SQLserver的登录方式 http://blog.csdn.net/huangyuan_xuan/article/details/41085629 汇编FLAG寄存器简介 http://blog.csdn.net/huangyuan_xuan/article/details/40949147 汇编指令——转移指令 http://blog.csdn.net/huangyuan_xuan/article/details/40949119 汇编指令 http://blog.csdn.net/huangyuan_xuan/article/details/40949109 汇编寻址方式 http://blog.csdn.net/huangyuan_xuan/article/details/40949087 一段汇编小程序及说明——将数据，代码，栈放入不同的段 http://blog.csdn.net/huangyuan_xuan/article/details/40949075 一段简单汇编语言程序及说明 http://blog.csdn.net/huangyuan_xuan/article/details/40949069 8086寄存器 http://blog.csdn.net/huangyuan_xuan/article/details/40949063 oracle创建实例化数据库或者连接别的远程主机数据库提示“无监听程序”的解决办法 http://blog.csdn.net/huangyuan_xuan/article/details/40857207 安装tomcat提示Faild to install Tomcat7 service 解决办法 http://blog.csdn.net/huangyuan_xuan/article/details/40821859 mysql事物处理和管理配置 http://blog.csdn.net/huangyuan_xuan/article/details/40821521 mysql 连接查询 http://blog.csdn.net/huangyuan_xuan/article/details/40783341 MySQL常用命令 http://blog.csdn.net/huangyuan_xuan/article/details/40783331 ubuntu下MySQL键值不支持中文解决办法 http://blog.csdn.net/huangyuan_xuan/article/details/40783317 Myeclipse新建webservice客户端 http://blog.csdn.net/huangyuan_xuan/article/details/39992799 MyEclips新建webservice http://blog.csdn.net/huangyuan_xuan/article/details/39992723 intellij IDEA更换主题为Darcula后中文项目名称变口（方框）的解决办法 http://blog.csdn.net/huangyuan_xuan/article/details/39896009 java模拟登录校内成绩查询网站，将获得的HTML代码用jsoup解析 http://blog.csdn.net/huangyuan_xuan/article/details/39723251 Ubuntu14.04 LTS更新源 http://blog.csdn.net/huangyuan_xuan/article/details/39119797 ubuntu14.04开机自动挂载windows磁盘的配置方法 http://blog.csdn.net/huangyuan_xuan/article/details/39118723 java实现MD5和sha1加密 http://blog.csdn.net/huangyuan_xuan/article/details/39081435 22 PPP协议 http://blog.csdn.net/huangyuan_xuan/article/details/38427607 21 串行接口封装 http://blog.csdn.net/huangyuan_xuan/article/details/38427547 20 internet connection http://blog.csdn.net/huangyuan_xuan/article/details/38427527 19 广域网 WAN http://blog.csdn.net/huangyuan_xuan/article/details/38423675 java的JDK的安装配置图文详解 http://blog.csdn.net/huangyuan_xuan/article/details/38405103 18 ACL访问控制列表（access control list） http://blog.csdn.net/huangyuan_xuan/article/details/38387045 17 NAT转换 http://blog.csdn.net/huangyuan_xuan/article/details/38342675 16 DHCP http://blog.csdn.net/huangyuan_xuan/article/details/38278825 Java常见错误列表 http://blog.csdn.net/huangyuan_xuan/article/details/37957229 LXLE Linux取代Windows XP的11个大招 http://blog.csdn.net/huangyuan_xuan/article/details/37937957 jQuery语法简介 http://blog.csdn.net/huangyuan_xuan/article/details/37738127 cookie简介 http://blog.csdn.net/huangyuan_xuan/article/details/37728211 DOM 简介 http://blog.csdn.net/huangyuan_xuan/article/details/37699891 vim 命令 http://blog.csdn.net/huangyuan_xuan/article/details/28880287 我们大神都这样——提问的智慧 http://blog.csdn.net/huangyuan_xuan/article/details/28276437 初学C语言的人看不懂的关机代码 http://blog.csdn.net/huangyuan_xuan/article/details/27972015 ubuntu连接路由器无线网络，却不能上网 http://blog.csdn.net/huangyuan_xuan/article/details/27792089 sublime-text2的中英文对照表（附带个人的配置习惯） http://blog.csdn.net/huangyuan_xuan/article/details/26969041 电脑蓝屏代码大全 http://blog.csdn.net/huangyuan_xuan/article/details/26246709 VC6.0 快捷键整理 http://blog.csdn.net/huangyuan_xuan/article/details/26245513 玩游戏无法全屏 http://blog.csdn.net/huangyuan_xuan/article/details/26245135 15 Ospf http://blog.csdn.net/huangyuan_xuan/article/details/26244991 14 EIGRP 配置 http://blog.csdn.net/huangyuan_xuan/article/details/26244541 13 ERGIP http://blog.csdn.net/huangyuan_xuan/article/details/26244439 12 rip-2 配置命令 http://blog.csdn.net/huangyuan_xuan/article/details/26244201 11 rip -1 http://blog.csdn.net/huangyuan_xuan/article/details/26244031 10动态路由 http://blog.csdn.net/huangyuan_xuan/article/details/26243735 9静态路由 http://blog.csdn.net/huangyuan_xuan/article/details/26243487 8网络拓扑结构 http://blog.csdn.net/huangyuan_xuan/article/details/26243293 7VLSM子网划分 http://blog.csdn.net/huangyuan_xuan/article/details/26243041 6常用网络相关命令 http://blog.csdn.net/huangyuan_xuan/article/details/26242799 5数据包发送流程 http://blog.csdn.net/huangyuan_xuan/article/details/26242589 网线 http://blog.csdn.net/huangyuan_xuan/article/details/26242183 osi七层网络模型4 http://blog.csdn.net/huangyuan_xuan/article/details/26242101 osi七层网络模型3 http://blog.csdn.net/huangyuan_xuan/article/details/26242015 osi七层网络模型2 http://blog.csdn.net/huangyuan_xuan/article/details/26241831 OSI七层网络模型1 http://blog.csdn.net/huangyuan_xuan/article/details/26241631 sublime-text2 编译java出错 Decode error - output not utf-8的解决办法 http://blog.csdn.net/huangyuan_xuan/article/details/26164349 安装虚拟机报错解决办法 TheVMware Authorization Service is not running http://blog.csdn.net/huangyuan_xuan/article/details/26162201 我的vim配置 http://blog.csdn.net/huangyuan_xuan/article/details/26162083 sublime text 2 搭建java运行环境 http://blog.csdn.net/huangyuan_xuan/article/details/26161983 ubuntu的一点命令 http://blog.csdn.net/huangyuan_xuan/article/details/26160973 以后主要就在gitpage上写博客了. 以上]]></content>
      <tags>
        <tag>csdn</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[2016年国庆-在深圳]]></title>
    <url>%2F2016%2F10%2F08%2F2016%E5%9B%BD%E5%BA%86%2F</url>
    <content type="text"><![CDATA[国庆之前,辞了工作,跑到深圳找妹子玩了几天.妹子在哈工大深圳校区读研究生,去了之后也没有出去逛,吃饭,图书馆,写作业,折腾hexo写博客.也就在校园里逛了一下,拍了几张照片.在深圳市南山区的大学城里面,好像是有清华北大哈工大三所研究生院校组成的,据说哈工大深研院开始招本科生了.南门 ,没去其他的门,就从这边进去的,别问为啥,近. 哈工大深研院的标志?不知道是不是标志性建筑 图书馆,吐槽一下,图书馆的书好少.电梯的海报上面说是有电影放映,但是我们沉迷于学习无法自拔,理所当然的错过了. 图书馆门口的植物标本,我也不知道是啥,装作看懂的样子 食堂,食堂的饭菜还是不错的,听说非学校人员也能在里面办卡,只是比学生买饭要贵40%.表示理解. 北大汇丰商学院,就在图书馆旁边小树林里面有蛇,晚上去吃饭的时候路过的小树林,里面真的有蛇,亲眼所见,大概有食指粗细,一尺来长,黑灰色.可惜没拍到.清华大学深研院,不知道是不是这么叫的,吃完晚饭去瞻仰了一下 本打算去蹭课来着,但是看着妹子的作业就不想去了,我觉得我应该听不大懂. 就这些,待了貌似有四五天的样子,然后就滚回北京找工作了. 以上.]]></content>
      <tags>
        <tag>乱七八糟</tag>
      </tags>
  </entry>
</search>
